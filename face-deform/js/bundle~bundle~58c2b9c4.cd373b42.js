/*! For license information please see bundle~bundle~58c2b9c4.cd373b42.js.LICENSE.txt */
(("undefined"!=typeof self?self:this).webpackJsonp=("undefined"!=typeof self?self:this).webpackJsonp||[]).push([[7],{111:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({sigmoid_:function(t){const e=Object(s.a)(t,"x","sigmoid"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sigmoid(e);return n([r]),r}),n,null,a.qc)}})},112:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(0),c=n(4);const o=Object(c.a)({fft_:function(t){Object(s.assert)("complex64"===t.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`));const e={input:t};return r.a.runKernelFunc((e=>{const n=t.shape[t.shape.length-1],r=t.size/n,a=t.as2D(r,n);return e.fft(a).reshape(t.shape)}),e,null,a.Y)}})},113:function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(0),a=n(47),s=n(30),c=n(88),o=n(4),u=n(83),i=n(7),l=n(28),f=n(68),b=n(52),h=n(21),p=n(112);const d=Object(o.a)({rfft_:function(t,e){Object(r.assert)("float32"===t.dtype,(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let n=t.shape[t.shape.length-1];const o=t.size/n;let d;if(null!=e&&e<n){const r=t.shape.map((t=>0)),a=t.shape.map((t=>t));a[t.shape.length-1]=e,d=Object(l.a)(t,r,a),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,d=Object(s.a)([t,Object(b.a)(r)],t.shape.length-1),n=e}else d=t;const O=Object(h.a)(d),j=Object(i.a)(Object(a.a)(d,O),[o,n]),m=Object(p.a)(j),g=Math.floor(n/2)+1,w=Object(u.a)(m),k=Object(c.a)(m),x=Object(f.a)(w,[g,n-g],w.shape.length-1),v=Object(f.a)(k,[g,n-g],k.shape.length-1),y=d.shape.slice();return y[d.shape.length-1]=g,Object(i.a)(Object(a.a)(x[0],v[0]),y)}})},114:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(3),a=n(0),s=n(4),c=n(7);const o=Object(s.a)({squeeze_:function(t,e){const n=Object(r.a)(t,"x","squeeze");return Object(c.a)(n,Object(a.squeezeShape)(n.shape,e).newShape)}})},115:function(t,e,n){"use strict";n.d(e,"a",(function(){return j}));var r=n(3),a=n(0),s=n(42),c=n(18),o=n(64),u=n(101),i=n(4),l=n(60),f=n(7),b=n(14),h=n(48),p=n(27),d=n(12);function O(t,e,n=null){if(0===t.rank)return Object(s.a)(t);if(1!==t.rank&&null===n)return O(Object(f.a)(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return Object(d.a)(Object(s.a)(t),n);if(e===1/0)return Object(o.a)(Object(s.a)(t),n);if(e===-1/0)return Object(u.a)(Object(s.a)(t),n);if("euclidean"===e||2===e)return Object(h.a)(Object(d.a)(Object(l.a)(Object(s.a)(t),Object(b.a)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return Object(o.a)(Object(d.a)(Object(s.a)(t),n[0]),n[1]-1);if(e===1/0)return Object(o.a)(Object(d.a)(Object(s.a)(t),n[1]),n[0]);if(e===-1/0)return Object(u.a)(Object(d.a)(Object(s.a)(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return Object(h.a)(Object(d.a)(Object(p.a)(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const j=Object(i.a)({norm_:function(t,e="euclidean",n=null,s=!1){const o=O(t=Object(r.a)(t,"x","norm"),e,n);let u=o.shape;if(s){const e=Object(a.parseAxisParam)(n,t.shape);u=c.e(o.shape,e)}return Object(f.a)(o,u)}})},119:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(10),o=n(4);const u=Object(o.a)({relu6_:function(t){const e=Object(s.a)(t,"x","relu6"),n={x:e};return r.a.runKernelFunc(((t,n)=>(n([e]),"bool"===e.dtype?Object(c.a)(e,"int32"):t.relu6(e))),n,null,a.dc)}})},12:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(18),u=n(10),i=n(4),l=n(7),f=n(23);const b=Object(i.a)({sum_:function(t,e=null,n=!1){let i=Object(s.a)(t,"x","sum");"bool"===i.dtype&&(i=Object(u.a)(i,"int32"));const b={x:i},h={axis:e,keepDims:n};return r.a.runKernelFunc(((t,r)=>{r([i]);const a=Object(c.parseAxisParam)(e,i.shape),s=Object(o.f)(a,i.rank);let u=a,b=i;null!=s&&(b=Object(f.a)(i,s),u=Object(o.g)(u.length,i.rank));let h=t.sum(b,u);if(n){const t=Object(o.e)(h.shape,a);h=Object(l.a)(h,t)}return h}),b,null,a.Gc,h)}})},120:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({prelu_:function(t,e){const n=Object(s.a)(t,"x","prelu"),c=Object(s.a)(e,"alpha","prelu"),o={x:n,alpha:c};return r.a.runKernelFunc(((t,e)=>{const r=t.prelu(n,c);return e([n,c]),r}),o,null,a.Xb)}})},122:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({unsortedSegmentSum_:function(t,e,n){const o=Object(s.a)(t,"x","unsortedSegmentSum"),u=Object(s.a)(e,"segmentIds","unsortedSegmentSum","int32");Object(c.assert)(Object(c.isInt)(n),(()=>"numSegments must be of dtype int"));const i={x:o,segmentIds:u},l={numSegments:n};return r.a.runKernelFunc(((t,e)=>{const r=t.unsortedSegmentSum(o,u,n);return e([u]),r}),i,null,a.Nc,l)}})},124:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({pad_:function(t,e,n=0){const c=Object(s.a)(t,"x","pad");if(0===c.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:e,constantValue:n},u={x:c};return r.a.runKernelFunc(((t,r)=>(r([c]),t.pad(c,e,n))),u,null,a.Vb,o)}})},13:function(t,e,n){"use strict";n.d(e,"a",(function(){return r.a})),n.d(e,"b",(function(){return a.a})),n.d(e,"c",(function(){return s.a})),n.d(e,"d",(function(){return c.a})),n.d(e,"e",(function(){return o.a})),n.d(e,"f",(function(){return u.a})),n.d(e,"i",(function(){return i.a})),n.d(e,"j",(function(){return l.a})),n.d(e,"k",(function(){return f.a})),n.d(e,"l",(function(){return b.a})),n.d(e,"m",(function(){return h.a})),n.d(e,"n",(function(){return p.a})),n.d(e,"o",(function(){return d.a})),n.d(e,"p",(function(){return O.a})),n.d(e,"q",(function(){return j.a})),n.d(e,"r",(function(){return m.a})),n.d(e,"s",(function(){return g.a})),n.d(e,"h",(function(){return Q})),n.d(e,"g",(function(){return y}));var r=n(22),a=n(81),s=n(62),c=n(30),o=n(270),u=n(17),i=n(9),l=n(7),f=n(14),b=n(111),h=n(28),p=n(57),d=n(15),O=n(96),j=n(67),m=n(97),g=n(87),w=n(113),k=n(112),x=n(99),v=n(165),y=n(303),E=n(4);function $(t,e,n){const r=1-t%2,a=new Float32Array(t);for(let s=0;s<t;++s){const c=2*Math.PI*s/(t+r-1);a[s]=e-n*Math.cos(c)}return Object(j.a)(a,"float32")}Object(E.a)({hammingWindow_:function(t){return $(t,.54,.46)}});const S=Object(E.a)({hannWindow_:function(t){return $(t,.5,.5)}});var A=n(166);const _=Object(E.a)({frame_:function(t,e,n,r=!1,a=0){let s=0;const o=[];for(;s+e<=t.size;)o.push(Object(h.a)(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,u=Object(c.a)([Object(h.a)(t,s,e-r),Object(A.a)([r],a)]);o.push(u),s+=n}return 0===o.length?Object(m.a)([],[0,e]):Object(l.a)(Object(c.a)(o),[o.length,e])}});Object(E.a)({stft_:function(t,e,n,r,a=S){var s;null==r&&(s=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const o=_(t,e,n),u=Object(i.a)(o,a(e)),l=[];for(let t=0;t<o.shape[0];t++)l.push(Object(w.a)(Object(h.a)(u,[t,0],[1,e]),r));return Object(c.a)(l)}});var F=n(307),z=n(305),M=n(306),T=n(308),N=n(309),K=n(310),q=n(311),D=n(312),I=n(313),C=n(202),P=n(201),W=n(314),H=n(315),L=n(316),R=n(317),G=n(41),U=n(318),B=n(319),V=n(320),X=n(321),J=n(322),Y=n(323),Z=n(324);k.a,x.a,w.a,v.a;const Q={flipLeftRight:z.a,resizeNearestNeighbor:P.a,resizeBilinear:C.a,rotateWithOffset:M.a,cropAndResize:F.a,nonMaxSuppression:T.a,nonMaxSuppressionAsync:N.a,nonMaxSuppressionWithScore:K.a,nonMaxSuppressionWithScoreAsync:q.a,nonMaxSuppressionPadded:D.a,nonMaxSuppressionPaddedAsync:I.a};W.a,H.a,L.a,R.a,G.a,U.a,B.a,V.a,X.a,J.a,Y.a,Z.a},14:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var r=n(0),a=n(78);function s(t,e){if((Object(r.isTypedArray)(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&Object(r.isTypedArray)(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(a.a)(t,[],[],e)}},144:function(t,e,n){"use strict";n.r(e),n.d(e,"validateUpdateShape",(function(){return a})),n.d(e,"validateInput",(function(){return s})),n.d(e,"calculateShapes",(function(){return c}));var r=n(0);function a(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,a=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(t.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+t.length-r)throw new Error(s+" update.rank != "+(a+t.length-r));for(let t=0;t<a;++t)if(n.shape[t]!==e.shape[t])throw new Error(s+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-a;++e)if(n.shape[e+a]!==t[e+r])throw new Error(s+` updates.shape[${e+a}] (${n.shape[e+a]}) != shape[${e+a}] (${t[e+a]})`)}function s(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}a(n,e,t)}function c(t,e,n){const a=e.shape.length,s=a>1?e.shape[a-1]:1,c=n.length;let o=1;for(let t=s;t<c;++t)o*=n[t];const u=s<1?1:s;return{sliceRank:s,numUpdates:Object(r.sizeFromShape)(e.shape)/u,sliceSize:o,strides:[...Object(r.computeStrides)(n.slice(0,s)),1],outputSize:Object(r.sizeFromShape)(n)}}},146:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(0),c=n(67),o=n(52);function u(t,e,n=1,u="float32"){if(0===n)throw new Error("Cannot have a step of zero");const i={start:t,stop:e,step:n,dtype:u};return r.a.runKernelFunc((()=>{if(t===e||t<e&&n<0||e<t&&n>1)return Object(o.a)([0],u);const r=Math.abs(Math.ceil((e-t)/n)),a=Object(s.makeZerosTypedArray)(r,u);e<t&&1===n&&(n=-1),a[0]=t;for(let t=1;t<a.length;t++)a[t]=a[t-1]+n;return Object(c.a)(a,u)}),{},null,a.Zb,i)}},147:function(t,e,n){"use strict";n.d(e,"b",(function(){return r})),n.d(e,"a",(function(){return a}));const r=1.7580993408473768,a=1.0507009873554805},15:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(19),c=n(3),o=n(4);const u=Object(o.a)({sub_:function(t,e){let n=Object(c.a)(t,"a","sub"),o=Object(c.a)(e,"b","sub");[n,o]=Object(s.b)(n,o);const u={a:n,b:o};return r.a.runKernelFunc(((t,e)=>{const r=t.subtract(n,o);return e([n,o]),r}),u,null,a.Fc)}})},163:function(t,e,n){"use strict";function r(t,e=!1){console.log(t.toString(e))}n.d(e,"a",(function(){return r}))},164:function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var r=n(0);function a(t,e,n=0){let a=[];if("number"==typeof e)Object(r.assert)(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);Object(r.assert)(s<=1,(()=>"There should be only one negative value in split array."));const c=e.indexOf(-1);if(-1!==c){const r=e.reduce(((t,e)=>e>0?t+e:t));e[c]=t.shape[n]-r}Object(r.assert)(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=e}return a}},165:function(t,e,n){"use strict";n.d(e,"a",(function(){return p}));var r=n(47),a=n(30),s=n(88),c=n(9),o=n(4),u=n(83),i=n(7),l=n(84),f=n(14),b=n(28),h=n(99);const p=Object(o.a)({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let o;if(e<=2){const r=Object(i.a)(t,[n,e]);o=Object(h.a)(r)}else{const p=[n,2*(e-1)],d=Object(i.a)(Object(u.a)(t),[n,e]),O=Object(i.a)(Object(s.a)(t),[n,e]),j=Object(l.a)(Object(b.a)(d,[0,1],[n,e-2]),1),m=Object(c.a)(Object(l.a)(Object(b.a)(O,[0,1],[n,e-2]),1),Object(f.a)(-1)),g=Object(a.a)([d,j],1),w=Object(a.a)([O,m],1),k=Object(i.a)(Object(r.a)(g,w),[p[0],p[1]]);o=Object(h.a)(k)}if(o=Object(u.a)(o),3===t.rank&&0!==t.shape[0]){const e=o,n=t.shape[0];o=Object(i.a)(o,[n,o.shape[0]/n,o.shape[1]]),e.dispose()}return o}})},169:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(3),a=n(0),s=n(78);function c(t,e,n){if(Object(a.assertNonNull)(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const c=Object(r.c)(t,n);if(3!==c.length&&1!==c.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===c.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(s.a)(t,e,c,n)}},170:function(t,e,n){"use strict";n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return s}));var r=n(0);const a=30;function s(t){return t<=a?t:Object(r.nearestDivisor)(t,Math.floor(Math.sqrt(t)))}},171:function(t,e,n){"use strict";n.r(e),n.d(e,"segOpComputeOptimalWindowSize",(function(){return s})),n.d(e,"computeOutShape",(function(){return c})),n.d(e,"collectGatherOpShapeInfo",(function(){return o}));var r=n(0),a=n(170);function s(t,e){let n,s=!1;for(t<=a.a?(n=t,s=!0):n=Object(r.nearestDivisor)(t,Math.floor(Math.sqrt(t)));!s;)n>e||n===t?s=!0:n=Object(r.nearestDivisor)(t,n+1);return n}function c(t,e,n){const r=[],a=t.length;for(let s=0;s<a;s++)s!==e?r.push(t[s]):r.push(n);return r}function o(t,e,n){const r=t.shape[n],a=[];let s=1,c=1;for(let e=0;e<n;e++)a.push(t.shape[e]),s*=t.shape[e];for(let t=0;t<e.rank;t++)a.push(e.shape[t]);for(let e=n+1;e<t.rank;e++)a.push(t.shape[e]),c*=t.shape[e];return{batchSize:s,sliceSize:c,dimSize:r,outputShape:a}}},172:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({sin_:function(t){const e=Object(s.a)(t,"x","sin"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sin(e);return n([e]),r}),n,null,a.sc)}})},173:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({sinh_:function(t){const e=Object(s.a)(t,"x","sinh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sinh(e);return n([e]),r}),n,null,a.tc)}})},174:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({rsqrt_:function(t){const e=Object(s.a)(t,"x","rsqrt"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.rsqrt(e);return n([e]),r}),n,null,a.mc)}})},190:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({softplus_:function(t){const e=Object(s.a)(t,"x","softplus"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.softplus(e);return n([e]),r}),n,null,a.wc)}})},192:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(4),o=n(7);const u=Object(c.a)({oneHot_:function(t,e,n=1,c=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const u=Object(s.a)(t,"indices","oneHot","int32"),i=[...u.shape,e],l={indices:u},f={depth:e,onValue:n,offValue:c};return r.a.runKernelFunc(((t,r)=>(r([u]),Object(o.a)(t.oneHot(Object(o.a)(u,[u.size]),e,n,c),i))),l,null,a.Tb,f)}})},193:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var r=n(3),a=n(0),s=n(127),c=n(95),o=n(16),u=n(129),i=n(4),l=n(7),f=n(92);const b=Object(i.a)({pool_:function(t,e,n,i,b,h){null==b&&(b=[1,1]),null==h&&(h=1),0===i&&(i="valid");const p=Object(r.a)(t,"x","maxPool");let d=p,O=!1;3===p.rank&&(O=!0,d=Object(l.a)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),a.assert(o.h(h,b),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${h} and dilations '${b}'`));const j=o.e(d.shape,e,h,b,i),m=[j.dilationHeight,j.dilationWidth];let g;g="same"===i?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))).map((t=>t-1)),r=n.map((t=>Math.floor(t/2))),a=n.map(((t,e)=>t-r[e]));return n.map(((t,e)=>[r[e],a[e]]))}([j.filterHeight,j.filterWidth],m):[[0,0],[0,0]];const w=1===m[0]&&1===m[1],[k,x]=function(t,e,n){const r=n.map((t=>t[0])),a=n.map((t=>t[1])),s=t.concat(r,a),c=e.map(((t,e)=>(t-s[e]%t)%t)),o=a.map(((t,e)=>t+c[e])),u=e.map(((t,e)=>[r[e],o[e]])),i=e.map(((t,e)=>[0,c[e]]));return[u,i]}([j.inHeight,j.inWidth],m,g),v=w?i:"valid",y=w?d:Object(f.a)(d,m,k),E=("avg"===n?()=>Object(s.a)(y,e,h,v):()=>Object(u.a)(y,e,h,v))(),$=w?E:Object(c.a)(E,m,x);return O?Object(l.a)($,[$.shape[1],$.shape[2],$.shape[3]]):$}})},194:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(18),u=n(10),i=n(4),l=n(7),f=n(23);const b=Object(i.a)({prod_:function(t,e=null,n=!1){let i=Object(s.a)(t,"x","prod");const b={x:i},h={axis:e,keepDims:n};return r.a.runKernelFunc((t=>{"bool"===i.dtype&&(i=Object(u.a)(i,"int32"));const r=Object(c.parseAxisParam)(e,i.shape),a=Object(o.f)(r,i.rank);let s=r,b=i;null!=a&&(b=Object(f.a)(i,a),s=Object(o.g)(s.length,i.rank));let h=t.prod(b,s);if(n){const t=Object(o.e)(h.shape,r);h=Object(l.a)(h,t)}return h}),b,null,a.Yb,h)}})},195:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({selu_:function(t){const e=Object(s.a)(t,"x","selu"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.selu(e);return n([e]),r}),n,null,a.pc)}})},196:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(3),a=n(0),s=n(61),c=n(75),o=n(4),u=n(7);const i=Object(o.a)({separableConv2d_:function(t,e,n,o,i,l=[1,1],f="NHWC"){const b=Object(r.a)(t,"x","separableConv2d"),h=Object(r.a)(e,"depthwiseFilter","separableConv2d"),p=Object(r.a)(n,"pointwiseFilter","separableConv2d");let d=b,O=!1;if(3===b.rank&&(O=!0,d=Object(u.a)(b,[1,b.shape[0],b.shape[1],b.shape[2]])),"NCHW"===f)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");a.assert(4===d.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`)),a.assert(4===h.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${h.rank}.`)),a.assert(4===p.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${h.rank}.`)),a.assert(1===p.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`)),a.assert(1===p.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`));const j=h.shape[2],m=h.shape[3];a.assert(p.shape[2]===j*m,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${j*m}, but got ${p.shape[2]}.`));const g=Object(c.a)(d,h,o,i,f,l),w=Object(s.a)(g,p,1,"valid",f);return O?Object(u.a)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})},197:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({topk_:function(t,e=1,n=!0){const c=Object(s.a)(t,"x","topk");if(0===c.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const o=c.shape[c.shape.length-1];if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);const u={x:c},i={k:e,sorted:n},[l,f]=r.a.runKernelFunc((t=>t.topk(c,e,n)),u,null,a.Kc,i);return{values:l,indices:f}}})},21:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({zerosLike_:function(t){const e=Object(s.a)(t,"x","zerosLike"),n={x:e};return r.a.runKernelFunc((t=>t.zerosLike(e)),n,null,a.Oc)}})},23:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({transpose_:function(t,e){const n=Object(s.a)(t,"x","transpose");if(null==e&&(e=n.shape.map(((t,e)=>e)).reverse()),c.assert(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`)),e.forEach((t=>{c.assert(t>=0&&t<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`))})),n.rank<=1)return n.clone();const o={x:n},u={perm:e};return r.a.runKernelFunc((t=>t.transpose(n,e)),o,null,a.Lc,u)}})},27:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(3),s=n(4);const c=Object(s.a)({square_:function(t){const e=Object(a.a)(t,"x","square"),n=[e];return r.a.runKernelFunc(((t,n)=>(n([e]),t.square(e))),{x:e},null,"Square",{},n,[])}})},272:function(t,e,n){"use strict";function r(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}n.d(e,"a",(function(){return r}))},28:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(4),o=n(49);const u=Object(c.a)({slice_:function(t,e,n){const c=Object(s.a)(t,"x","slice");if(0===c.rank)throw new Error("Slicing scalar is not possible");const[u,i]=o.parseSliceParams(c,e,n);o.assertParamsValid(c,u,i);const l={x:c},f={begin:e,size:n};return r.a.runKernelFunc(((t,e)=>(e([c]),t.slice(c,u,i))),l,null,a.uc,f)}})},293:function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(5),a=n(2),s=n(3),c=n(47),o=n(88),u=n(4),i=n(83),l=n(21);const f=Object(u.a)({onesLike_:function(t){const e=Object(s.a)(t,"x","onesLike"),n={x:e};return r.a.runKernelFunc(((t,n)=>{if("complex64"===e.dtype){const t=f(Object(i.a)(e)),n=Object(l.a)(Object(o.a)(e));return Object(c.a)(t,n)}return t.onesLike(e)}),n,null,a.Ub)}})},294:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({reciprocal_:function(t){const e=Object(s.a)(t,"x","reciprocal"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.reciprocal(e);return n([e]),r}),n,null,a.bc)}})},295:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({round_:function(t){const e=Object(s.a)(t,"x","round"),n={x:e};return r.a.runKernelFunc((t=>t.round(e)),n,null,a.lc)}})},296:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({sign_:function(t){const e=Object(s.a)(t,"x","sign"),n={x:e};return r.a.runKernelFunc((t=>t.sign(e)),n,null,a.rc)}})},297:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({softmax_:function(t,e=-1){const n=Object(s.a)(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const c={logits:n},o={dim:e};return r.a.runKernelFunc(((t,r)=>{const a=t.softmax(n,e);return r([a]),a}),c,null,a.vc,o)}})},298:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),c=n(4),o=n(7),u=n(28),i=n(49);const l=Object(c.a)({stridedSlice_:function(t,e,n,c,l=0,f=0,b=0,h=0,p=0){let d=Object(s.a)(t,"x","stridedSlice");const O={x:d},j={begin:e,end:n,strides:c,beginMask:l,endMask:f,ellipsisMask:b,newAxisMask:h,shrinkAxisMask:p};return r.a.runKernelFunc((t=>{null==c&&(c=new Array(e.length));const r=Object(i.maskToAxes)(b);if(r.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==b&&0!==h)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==b&&0!==p)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const a=d.rank-e.length,s=Object(i.maskToAxes)(h),O=d.shape.slice();s.forEach((t=>{e[t]=0,n[t]=1,O.splice(t,0,1)})),d=Object(o.a)(d,O);const{begin:j,end:m,strides:g}=Object(i.getNormalizedAxes)(d.shape,r,a,e,n,c,l,f,b);e=j,n=m,c=g;const w=Object(i.maskToAxes)(p);w.forEach((t=>{n[t]=e[t]+1,c[t]=1}));const k=Object(i.computeOutShape)(e,n,c),x=k.filter(((t,e)=>-1===w.indexOf(e)));if(c.every((t=>1===t)))return Object(o.a)(Object(u.a)(d,e,k),x);const v=t.stridedSlice(d,e,n,c);return Object(o.a)(v,x)}),O,null,a.Ec,j)}})},299:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({tan_:function(t){const e=Object(s.a)(t,"x","tan"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.tan(e);return n([e]),r}),n,null,a.Hc)}})},300:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({tanh_:function(t){const e=Object(s.a)(t,"x","tanh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.tanh(e);return n([r]),r}),n,null,a.Ic)}})},34:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(100),u=n(11),i=n(4);const l=Object(i.a)({where_:function(t,e,n){const i=Object(s.a)(e,"a","where"),l=Object(s.a)(n,"b","where"),f=Object(s.a)(t,"condition","where","bool"),b=Object(u.a)(i.shape,l.shape),h=Object(o.a)(i,b),p=Object(o.a)(l,b);1===f.rank&&Object(c.assert)(f.shape[0]===i.shape[0],(()=>"The first dimension of `a` must match the size of `condition`.")),1!==f.rank&&Object(c.assertShapesMatch)(f.shape,p.shape,"Error in where: ");const d={condition:f,t:h,e:p};return r.a.runKernelFunc(((t,e)=>{const n=t.select(f,h,p);return e([f]),n}),d,null,a.oc)}})},4:function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var r=n(5);function a(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const a=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...t)=>{r.a.startScope(n);try{const e=a(...t);return e instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r.a.endScope(e),e}catch(t){throw r.a.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}},48:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({sqrt_:function(t){const e=Object(s.a)(t,"x","sqrt"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sqrt(e);return n([e]),r}),n,null,a.Ac)}})},49:function(t,e,n){"use strict";n.r(e),n.d(e,"assertParamsValid",(function(){return a})),n.d(e,"maskToAxes",(function(){return s})),n.d(e,"computeOutShape",(function(){return c})),n.d(e,"stridesWithElidedDims",(function(){return o})),n.d(e,"getNormalizedAxes",(function(){return l})),n.d(e,"startIndicesWithElidedDims",(function(){return f})),n.d(e,"stopIndicesWithElidedDims",(function(){return b})),n.d(e,"stridesForAxis",(function(){return h})),n.d(e,"startForAxis",(function(){return p})),n.d(e,"stopForAxis",(function(){return d})),n.d(e,"isSliceContinous",(function(){return O})),n.d(e,"computeFlatOffset",(function(){return j})),n.d(e,"parseSliceParams",(function(){return m}));var r=n(0);function a(t,e,n){r.assert(t.rank===e.length,(()=>`Error in slice${t.rank}D: Length of begin ${e} must match the rank of the array (${t.rank}).`)),r.assert(t.rank===n.length,(()=>`Error in slice${t.rank}D: Length of size ${n} must match the rank of the array (${t.rank}).`));for(let a=0;a<t.rank;++a)r.assert(e[a]+n[a]<=t.shape[a],(()=>`Error in slice${t.rank}D: begin[${a}] + size[${a}] (${e[a]+n[a]}) would overflow input.shape[${a}] (${t.shape[a]})`))}function s(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function c(t,e,n){const r=[];for(let a=0;a<t.length;a++)r[a]=Math.ceil((e[a]-t[a])/n[a]);return r}function o(t,e,n,r){const a=[...t];for(let t=a.length;t<r.length;t++)a.push(1);for(let t=0;t<n;t++)0===t?a[e]=1:(a.splice(e,0,1),a.pop());return a}function u(t,e,n){return n<=t?n:n-(e-1)}function i(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function l(t,e,n,r,a,s,c,u,i){const l=t.length;let O=new Array(l),j=new Array(l),m=new Array(l);if(e.length&&n>0){const i=e[0],l=n+1;O=f(c,i,l,r,t),j=b(u,i,l,a,t),m=o(s,i,l,t)}else for(let e=0;e<l;e++)O[e]=p(c,r,s,t,e,i),j[e]=d(u,a,s,t,e,i),m[e]=h(s,e,i);return{begin:O,end:j,strides:m}}function f(t,e,n,r,a){const s=[...a],c=i(n,e);for(let a=0;a<s.length;a++)if(c.indexOf(a)>-1)s[a]=0;else{const c=u(e,n,a);let o=r[c];t&1<<c&&(o=0),s[a]=o}return s}function b(t,e,n,a,s){const c=[...s],o=i(n,e);for(let r=0;r<c.length;r++)if(o.indexOf(r)>-1)c[r]=Number.MAX_SAFE_INTEGER;else{const s=u(e,n,r);let o=a[s];t&1<<s&&(o=Number.MAX_SAFE_INTEGER),c[r]=o}for(let t=0;t<c.length;t++){const e=s[t];c[t]<0&&(c[t]+=e),c[t]=r.clamp(0,c[t],s[t])}return c}function h(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function p(t,e,n,a,s,c){let o=e[s];const u=n[s]||1;(t&1<<s||c&1<<s||null==o)&&(o=u>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const i=a[s];return o<0&&(o+=i),o=r.clamp(0,o,i-1),o}function d(t,e,n,a,s,c){let o=e[s];const u=n[s]||1;(t&1<<s||c&1<<s||null==o)&&(o=u>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const i=a[s];return o<0&&(o+=i),o=u>0?r.clamp(0,o,i):r.clamp(-1,o,i-1),o}function O(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let a=r+1;a<n.length;a++)if(e[a]>0||n[a]!==t[a])return!1;return!0}function j(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function m(t,e,n){let a,s;return a="number"==typeof e?[e,...new Array(t.rank-1).fill(0)]:e.length<t.rank?e.concat(new Array(t.rank-e.length).fill(0)):e.slice(),a.forEach((t=>{r.assert(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(t.rank).fill(-1):"number"==typeof n?[n,...new Array(t.rank-1).fill(-1)]:n.length<t.rank?n.concat(new Array(t.rank-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(r.assert(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-a[n]))),[a,s]}},52:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(0),s=n(47);function c(t,e="float32"){if("complex64"===e){const e=c(t,"float32"),n=c(t,"float32");return Object(s.a)(e,n)}const n=Object(a.makeZerosTypedArray)(Object(a.sizeFromShape)(t),e);return r.a.makeTensor(n,t,e)}},527:function(t,e,n){"use strict";n(142);var r=n(20),a=n(199),s=n(200),c=n(86);class o{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(Object(r.b)().get("IS_BROWSER")){Object(r.b)().setPlatform("browser",new o);try{c.a.registerManager(s.a.URL_SCHEME,new s.b)}catch(t){}try{c.a.registerManager(a.a.URL_SCHEME,new a.b)}catch(t){}}},531:function(t,e,n){"use strict";(function(t){var e=n(20);const r=()=>n(532);let a;class s{constructor(){this.util=n(533),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return null!=Object(e.b)().global.fetch?Object(e.b)().global.fetch(t,n):(null==a&&(a=r()),a(t,n))}now(){const e=t.hrtime();return 1e3*e[0]+e[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}Object(e.b)().get("IS_NODE")&&Object(e.b)().setPlatform("node",new s)}).call(this,n(106))},57:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(3),a=n(0),s=n(30),c=n(44),o=n(4);const u=Object(o.a)({stack_:function(t,e=0){const n=Object(r.b)(t,"tensors","stack");if(a.assert(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),1===n.length)return Object(c.a)(n[0],e);const o=n[0].rank,u=n[0].shape,i=n[0].dtype;a.assert(e<=o,(()=>"Axis must be <= rank of the tensor")),n.forEach((t=>{a.assertShapesMatch(u,t.shape,"All tensors passed to stack must have matching shapes"),a.assert(i===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const l=n.map((t=>Object(c.a)(t,e)));return Object(s.a)(l,e)}})},60:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(19),c=n(3),o=n(4);const u=Object(o.a)({pow_:function(t,e){let n=Object(c.a)(t,"base","pow"),o=Object(c.a)(e,"exp","pow");[n,o]=Object(s.b)(n,o);const u={a:n,b:o};return r.a.runKernelFunc(((t,e)=>{const r=t.pow(n,o);return e([n,o,r]),r}),u,null,a.Wb)}})},63:function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var r=n(0);function a(t,e,n,a,s,c){null==a&&(a=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==c&&(c=0);const o=t.shape[0];return n=Math.min(n,o),r.assert(0<=a&&a<=1,(()=>`iouThreshold must be in [0, 1], but was '${a}'`)),r.assert(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),r.assert(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),r.assert(1===e.rank,(()=>"scores must be a 1D tensor")),r.assert(e.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`)),r.assert(0<=c&&c<=1,(()=>`softNmsSigma must be in [0, 1], but was '${c}'`)),{maxOutputSize:n,iouThreshold:a,scoreThreshold:s,softNmsSigma:c}}},67:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(3),a=n(0),s=n(78);function c(t,e){Object(a.assertNonNull)(t);const n=Object(r.c)(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(s.a)(t,null,n,e)}},68:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(4),u=n(164);const i=Object(o.a)({split_:function(t,e,n=0){const o=Object(s.a)(t,"x","split"),i={x:o},l={numOrSizeSplits:e,axis:n};return r.a.runKernelFunc(((t,r)=>{const a=Object(c.parseAxisParam)(n,o.shape)[0],s=Object(u.a)(o,e,a);return t.split(o,s,a)}),i,null,a.zc,l)}})},7:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({reshape_:function(t,e){const n=Object(s.a)(t,"x","reshape",null);e=c.inferFromImplicitShape(e,n.size),c.assert(n.size===c.sizeFromShape(e),(()=>"new shape and old shape must have the same number of elements."));const o={x:n},u={shape:e};return r.a.runKernelFunc(((t,r)=>(r([n]),t.reshape(n,e))),o,null,a.ec,u)}})},72:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(0),s=n(47),c=n(52);function o(t,e="float32"){if("complex64"===e){const e=o(t,"float32"),n=Object(c.a)(t,"float32");return Object(s.a)(e,n)}const n=Object(a.makeOnesTypedArray)(Object(a.sizeFromShape)(t),e);return r.a.makeTensor(n,t,e)}},73:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(4),o=n(10);const u=Object(c.a)({relu_:function(t){const e=Object(s.a)(t,"x","relu"),n={x:e};return r.a.runKernelFunc(((t,n)=>(n([e]),"bool"===e.dtype?Object(o.a)(e,"int32"):t.relu(e))),n,null,a.cc)}})},74:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({step_:function(t,e=0){const n=Object(s.a)(t,"x","step"),c={x:n},o={alpha:e};return r.a.runKernelFunc((t=>t.step(n,e)),c,null,a.Dc,o)}})},78:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var r=n(5),a=n(0);function s(t,e,n,s){if(null==s&&(s=Object(a.inferDtype)(t)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(a.isTypedArray)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Object(a.assertNonNegativeIntegerDimensions)(e);const t=Object(a.sizeFromShape)(e),r=Object(a.sizeFromShape)(n);Object(a.assert)(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],s=t!==n.length-1||r!==Object(a.sizeFromShape)(e.slice(t));Object(a.assert)(n[t]===e[t]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return Object(a.isTypedArray)(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==s?Object(a.toTypedArray)(t,s):Object(a.flatten)(t,[],!0),r.a.makeTensor(t,e,s)}},79:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({tile_:function(t,e){const n=Object(s.a)(t,"x","tile",null);c.assert(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const o=[n],u={x:n},i={reps:e};return r.a.runKernelFunc(((t,r)=>{const a=t.tile(n,e);return r([n]),a}),u,null,a.Jc,i,o)}})},83:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(5),a=n(2),s=n(3),c=n(4);const o=Object(c.a)({real_:function(t){const e=Object(s.a)(t,"input","real"),n={input:e};return r.a.runKernelFunc((t=>t.real(e)),n,null,a.ac)}})},84:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(62),u=n(4),i=n(7);const l=Object(u.a)({reverse_:function(t,e){const n=Object(s.a)(t,"x","reverse"),u={x:n},l={dims:e};return r.a.runKernelFunc((t=>{const r=Object(c.parseAxisParam)(e,n.shape);if(0===n.rank)return Object(o.a)(n);const a=t.reverse(n,r);return Object(i.a)(a,n.shape)}),u,null,a.jc,l)}})},87:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({unstack_:function(t,e=0){const n=Object(s.a)(t,"x","unstack");c.assert(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`)),e<0&&(e+=n.shape.length);const o={value:n},u={axis:e};return r.a.runKernelFunc((t=>t.unstack(n,e)),o,null,a.Mc,u)}})},89:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(19),c=n(3),o=n(11),u=n(4);const i=Object(u.a)({notEqual_:function(t,e){let n=Object(c.a)(t,"a","notEqual"),u=Object(c.a)(e,"b","notEqual");[n,u]=Object(s.b)(n,u),Object(o.a)(n.shape,u.shape);const i={a:n,b:u};return r.a.runKernelFunc((t=>t.notEqual(n,u)),i,null,a.Sb)}})},91:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(19),c=n(3),o=n(11),u=n(4);const i=Object(u.a)({squaredDifference_:function(t,e){let n=Object(c.a)(t,"a","squaredDifference"),u=Object(c.a)(e,"b","squaredDifference");[n,u]=Object(s.b)(n,u),Object(o.a)(n.shape,u.shape);const i={a:n,b:u};return r.a.runKernelFunc(((t,e)=>{const r=t.squaredDifference(n,u);return e([n,u]),r}),i,null,a.Cc,{})}})},92:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({spaceToBatchND_:function(t,e,n){const o=Object(s.a)(t,"x","spaceToBatchND");c.assert(o.rank>=1+e.length,(()=>`input rank ${o.rank} should be > than [blockShape] ${e.length}`)),c.assert(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),c.assert(o.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]==0:t),!0),(()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const u={x:o},i={blockShape:e,paddings:n};return r.a.runKernelFunc((t=>t.spaceToBatchND(o,e,n)),u,null,a.xc,i)}})},96:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var r=n(3),a=n(78);function s(t,e,n){const s=Object(r.c)(t,n);return Object(a.a)(t,e,s,n)}},97:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(3),a=n(0),s=n(78);function c(t,e,n){if(Object(a.assertNonNull)(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const c=Object(r.c)(t,n);if(2!==c.length&&1!==c.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===c.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(s.a)(t,e,c,n)}},99:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(0),c=n(4),o=n(7);const u=Object(c.a)({ifft_:function(t){Object(s.assert)("complex64"===t.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`));const e={input:t};return r.a.runKernelFunc((e=>{const n=t.shape[t.shape.length-1],r=t.size/n,a=Object(o.a)(t,[r,n]),s=e.ifft(a);return Object(o.a)(s,t.shape)}),e,null,a.lb)}})}}]);
//# sourceMappingURL=bundle~bundle~58c2b9c4.cd373b42.js.map