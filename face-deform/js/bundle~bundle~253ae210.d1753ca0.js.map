{"version":3,"sources":["webpack:///./node_modules/@tensorflow/tfjs-core/dist/util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/tensor_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/tape.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/tensor_util_env.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/tensor_format.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/tensor.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/types.js"],"names":["shuffle","array","counter","length","temp","index","Math","random","clamp","min","x","max","nearestLargerEven","val","sum","arr","i","randUniform","a","b","r","distSquared","result","diff","Number","assert","expr","msg","Error","assertShapesMatch","shapeA","shapeB","errorMessagePrefix","arraysEqual","assertNonNull","flatten","skipTypedArray","Array","isArray","isTypedArray","push","sizeFromShape","shape","size","isScalarShape","n1","n2","isInt","tanh","Infinity","e2x","exp","sizeToSquarishShape","width","ceil","sqrt","createShuffledIndices","n","shuffledIndices","Uint32Array","rightPad","repeat","repeatedTry","checkFn","delayFn","maxCounter","Promise","resolve","reject","tryCount","tryFn","nextBackoff","setTimeout","inferFromImplicitShape","shapeProd","implicitIdx","newShape","slice","parseAxisParam","axis","rank","map","s","concat","every","ax","squeezeShape","keptDims","isEmptyArray","axes","sort","j","getTypedArrayFromDType","dtype","values","Float32Array","Int32Array","Uint8Array","getArrayFromDType","checkConversionForErrors","vals","num","isNaN","isFinite","isValidDtype","hasEncodingLoss","oldType","newType","bytesPerElement","bytesFromStringArray","bytes","forEach","isString","value","String","isBoolean","isNumber","inferDtype","isFunction","f","constructor","call","apply","nearestDivisor","start","computeStrides","strides","toTypedArray","getBool","noConversionNeeded","bool","round","createNestedArray","offset","ret","d","rest","len","reduce","acc","c","toNestedArray","makeOnesTypedArray","makeZerosTypedArray","makeZerosNestedTypedArray","prev","curr","now","platform","assertNonNegativeIntegerDimensions","dimSize","isInteger","fetch","path","requestInits","encodeString","encoding","encode","decodeString","decode","locToIndex","locs","indexToLoc","floor","makeTypesMatch","cast","getTensorsInContainer","list","walkTensorContainer","Set","container","seen","obj","iterable","k","has","add","getFilteredNodesXToY","tape","xs","y","tensorsFromX","nodesFromX","id","node","nodeInputs","inputs","inputName","input","anyInputFromX","outputs","output","tensorsLeadToY","nodesToY","filteredTape","prunedInputs","nodeInput","prunedNode","Object","assign","backpropagateGradients","tensorAccumulatedGradientMap","tidy","dys","o","gradTensor","gradient","kernelName","inputGradients","keys","dx","curGradient","dispose","inferShape","firstElem","deepAssertShapeConsistency","indices","join","subShape","assertDtype","expectedDtype","actualDType","argName","functionName","convertToTensor","parseAsDtype","inferredDtype","indexOf","type","name","inferredShape","makeTensor","convertToTensorArray","arg","t","base64","ieee754","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","prototype","encodingOrOffset","this","allocUnsafe","from","TypeError","ArrayBuffer","byteOffset","byteLength","undefined","fromArrayLike","fromArrayBuffer","string","isEncoding","actual","write","fromString","isBuffer","checked","copy","buffer","data","fromObject","assertSize","toString","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","read","buf","readUInt16BE","foundIndex","found","hexWrite","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","charCodeAt","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","fromByteArray","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","exports","SlowBuffer","alloc","INSPECT_MAX_BYTES","global","foo","subarray","e","typedArraySupport","poolSize","_augment","Symbol","species","defineProperty","configurable","fill","allocUnsafeSlow","_isBuffer","compare","pos","swap16","swap32","swap64","arguments","equals","inspect","match","target","thisStart","thisEnd","thisCopy","targetCopy","includes","toJSON","_arr","out","toHex","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","INVALID_BASE64_RE","leadSurrogate","toByteArray","trim","replace","stringtrim","base64clean","src","dst","b64","lens","getLens","validLen","placeHoldersLen","tmp","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","tensorToString","verbose","padPerCol","numCols","valuesOrTuples","createComplexTuples","row","valToString","computeMaxSizePerColumn","valsLines","subTensorToString","lines","l","pad","valStr","parseFloat","toFixed","boolNumToString","v","isLast","storagePerElement","firstValsSize","firstVals","lastVals","subshape","substrides","stride","sep","newLineSep","complexTuples","util","loc","trackerFn","opHandler","deprecationWarningFn","setTensorTracker","fn","setOpHandler","handler","setDeprecationWarningFn","dataId","kept","isDisposedInternal","rankType","dataSync","throwIfDisposed","_a","readSync","isDisposed","disposeTensor","print","clone","trainable","makeVariable","hasInstance","instance","initialValue","tensorId","super","newValue","incRef","disposeVariable","Function","Rank","UpcastInt32AndMap","UpcastBoolAndMap","UpcastFloat32AndMap","UpcastComplex64AndMap","upcastTypeMap","upcastType","typeA","typeB"],"mappings":"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","file":"js/bundle~bundle~253ae210.d1753ca0.js","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from './environment';\n/**\n * Shuffles the array in-place using Fisher-Yates algorithm.\n *\n * ```js\n * const a = [1, 2, 3, 4, 5];\n * tf.util.shuffle(a);\n * console.log(a);\n * ```\n *\n * @param array The array to shuffle in-place.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\n// tslint:disable-next-line:no-any\nexport function shuffle(array) {\n    let counter = array.length;\n    let temp = 0;\n    let index = 0;\n    // While there are elements in the array\n    while (counter > 0) {\n        // Pick a random index\n        index = (Math.random() * counter) | 0;\n        // Decrease counter by 1\n        counter--;\n        // And swap the last element with it\n        temp = array[counter];\n        array[counter] = array[index];\n        array[index] = temp;\n    }\n}\n/** Clamps a value to a specified range. */\nexport function clamp(min, x, max) {\n    return Math.max(min, Math.min(x, max));\n}\nexport function nearestLargerEven(val) {\n    return val % 2 === 0 ? val : val + 1;\n}\nexport function sum(arr) {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n/**\n * Returns a sample from a uniform [a, b) distribution.\n *\n * @param a The minimum support (inclusive).\n * @param b The maximum support (exclusive).\n * @return A pseudorandom number on the half-open interval [a,b).\n */\nexport function randUniform(a, b) {\n    const r = Math.random();\n    return (b * r) + (1 - r) * a;\n}\n/** Returns the squared Euclidean distance between two vectors. */\nexport function distSquared(a, b) {\n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n        const diff = Number(a[i]) - Number(b[i]);\n        result += diff * diff;\n    }\n    return result;\n}\n/**\n * Asserts that the expression is true. Otherwise throws an error with the\n * provided message.\n *\n * ```js\n * const x = 2;\n * tf.util.assert(x === 2, 'x is not 2');\n * ```\n *\n * @param expr The expression to assert (as a boolean).\n * @param msg A function that returns the message to report when throwing an\n *     error. We use a function for performance reasons.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function assert(expr, msg) {\n    if (!expr) {\n        throw new Error(typeof msg === 'string' ? msg : msg());\n    }\n}\nexport function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = '') {\n    assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);\n}\nexport function assertNonNull(a) {\n    assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);\n}\n// NOTE: We explicitly type out what T extends instead of any so that\n// util.flatten on a nested array of number doesn't try to infer T as a\n// number[][], causing us to explicitly type util.flatten<number>().\n/**\n *  Flattens an arbitrarily nested array.\n *\n * ```js\n * const a = [[1, 2], [3, 4], [5, [6, [7]]]];\n * const flat = tf.util.flatten(a);\n * console.log(flat);\n * ```\n *\n *  @param arr The nested array to flatten.\n *  @param result The destination array which holds the elements.\n *  @param skipTypedArray If true, avoids flattening the typed arrays. Defaults\n *      to false.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function flatten(arr, result = [], skipTypedArray = false) {\n    if (result == null) {\n        result = [];\n    }\n    if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {\n        for (let i = 0; i < arr.length; ++i) {\n            flatten(arr[i], result, skipTypedArray);\n        }\n    }\n    else {\n        result.push(arr);\n    }\n    return result;\n}\n/**\n * Returns the size (number of elements) of the tensor given its shape.\n *\n * ```js\n * const shape = [3, 4, 2];\n * const size = tf.util.sizeFromShape(shape);\n * console.log(size);\n * ```\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function sizeFromShape(shape) {\n    if (shape.length === 0) {\n        // Scalar.\n        return 1;\n    }\n    let size = shape[0];\n    for (let i = 1; i < shape.length; i++) {\n        size *= shape[i];\n    }\n    return size;\n}\nexport function isScalarShape(shape) {\n    return shape.length === 0;\n}\nexport function arraysEqual(n1, n2) {\n    if (n1 === n2) {\n        return true;\n    }\n    if (n1 == null || n2 == null) {\n        return false;\n    }\n    if (n1.length !== n2.length) {\n        return false;\n    }\n    for (let i = 0; i < n1.length; i++) {\n        if (n1[i] !== n2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isInt(a) {\n    return a % 1 === 0;\n}\nexport function tanh(x) {\n    // tslint:disable-next-line:no-any\n    if (Math.tanh != null) {\n        // tslint:disable-next-line:no-any\n        return Math.tanh(x);\n    }\n    if (x === Infinity) {\n        return 1;\n    }\n    else if (x === -Infinity) {\n        return -1;\n    }\n    else {\n        const e2x = Math.exp(2 * x);\n        return (e2x - 1) / (e2x + 1);\n    }\n}\nexport function sizeToSquarishShape(size) {\n    const width = Math.ceil(Math.sqrt(size));\n    return [width, Math.ceil(size / width)];\n}\n/**\n * Creates a new array with randomized indicies to a given quantity.\n *\n * ```js\n * const randomTen = tf.util.createShuffledIndices(10);\n * console.log(randomTen);\n * ```\n *\n * @param number Quantity of how many shuffled indicies to create.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function createShuffledIndices(n) {\n    const shuffledIndices = new Uint32Array(n);\n    for (let i = 0; i < n; ++i) {\n        shuffledIndices[i] = i;\n    }\n    shuffle(shuffledIndices);\n    return shuffledIndices;\n}\nexport function rightPad(a, size) {\n    if (size <= a.length) {\n        return a;\n    }\n    return a + ' '.repeat(size - a.length);\n}\nexport function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter) {\n    return new Promise((resolve, reject) => {\n        let tryCount = 0;\n        const tryFn = () => {\n            if (checkFn()) {\n                resolve();\n                return;\n            }\n            tryCount++;\n            const nextBackoff = delayFn(tryCount);\n            if (maxCounter != null && tryCount >= maxCounter) {\n                reject();\n                return;\n            }\n            setTimeout(tryFn, nextBackoff);\n        };\n        tryFn();\n    });\n}\n/**\n * Given the full size of the array and a shape that may contain -1 as the\n * implicit dimension, returns the inferred shape where -1 is replaced.\n * E.g. For shape=[2, -1, 3] and size=24, it will return [2, 4, 3].\n *\n * @param shape The shape, which may contain -1 in some dimension.\n * @param size The full size (number of elements) of the array.\n * @return The inferred shape where -1 is replaced with the inferred size.\n */\nexport function inferFromImplicitShape(shape, size) {\n    let shapeProd = 1;\n    let implicitIdx = -1;\n    for (let i = 0; i < shape.length; ++i) {\n        if (shape[i] >= 0) {\n            shapeProd *= shape[i];\n        }\n        else if (shape[i] === -1) {\n            if (implicitIdx !== -1) {\n                throw Error(`Shapes can only have 1 implicit size. ` +\n                    `Found -1 at dim ${implicitIdx} and dim ${i}`);\n            }\n            implicitIdx = i;\n        }\n        else if (shape[i] < 0) {\n            throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);\n        }\n    }\n    if (implicitIdx === -1) {\n        if (size > 0 && size !== shapeProd) {\n            throw Error(`Size(${size}) must match the product of shape ${shape}`);\n        }\n        return shape;\n    }\n    if (shapeProd === 0) {\n        throw Error(`Cannot infer the missing size in [${shape}] when ` +\n            `there are 0 elements`);\n    }\n    if (size % shapeProd !== 0) {\n        throw Error(`The implicit shape can't be a fractional number. ` +\n            `Got ${size} / ${shapeProd}`);\n    }\n    const newShape = shape.slice();\n    newShape[implicitIdx] = size / shapeProd;\n    return newShape;\n}\nexport function parseAxisParam(axis, shape) {\n    const rank = shape.length;\n    // Normalize input\n    axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);\n    // Check for valid range\n    assert(axis.every(ax => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but ` +\n        `got axis ${axis}`);\n    // Check for only integers\n    assert(axis.every(ax => isInt(ax)), () => `All values in axis param must be integers but ` +\n        `got axis ${axis}`);\n    // Handle negative axis.\n    return axis.map(a => a < 0 ? rank + a : a);\n}\n/** Reduces the shape by removing all dimensions of shape 1. */\nexport function squeezeShape(shape, axis) {\n    const newShape = [];\n    const keptDims = [];\n    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;\n    const axes = (axis == null || isEmptyArray) ?\n        null :\n        parseAxisParam(axis, shape).sort();\n    let j = 0;\n    for (let i = 0; i < shape.length; ++i) {\n        if (axes != null) {\n            if (axes[j] === i && shape[i] !== 1) {\n                throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);\n            }\n            if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {\n                newShape.push(shape[i]);\n                keptDims.push(i);\n            }\n            if (axes[j] <= i) {\n                j++;\n            }\n        }\n        if (shape[i] !== 1) {\n            newShape.push(shape[i]);\n            keptDims.push(i);\n        }\n    }\n    return { newShape, keptDims };\n}\nexport function getTypedArrayFromDType(dtype, size) {\n    let values = null;\n    if (dtype == null || dtype === 'float32') {\n        values = new Float32Array(size);\n    }\n    else if (dtype === 'int32') {\n        values = new Int32Array(size);\n    }\n    else if (dtype === 'bool') {\n        values = new Uint8Array(size);\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n    return values;\n}\nexport function getArrayFromDType(dtype, size) {\n    let values = null;\n    if (dtype == null || dtype === 'float32') {\n        values = new Float32Array(size);\n    }\n    else if (dtype === 'int32') {\n        values = new Int32Array(size);\n    }\n    else if (dtype === 'bool') {\n        values = new Uint8Array(size);\n    }\n    else if (dtype === 'string') {\n        values = new Array(size);\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n    return values;\n}\nexport function checkConversionForErrors(vals, dtype) {\n    for (let i = 0; i < vals.length; i++) {\n        const num = vals[i];\n        if (isNaN(num) || !isFinite(num)) {\n            throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);\n        }\n    }\n}\n/** Returns true if the dtype is valid. */\nexport function isValidDtype(dtype) {\n    return dtype === 'bool' || dtype === 'complex64' || dtype === 'float32' ||\n        dtype === 'int32' || dtype === 'string';\n}\n/**\n * Returns true if the new type can't encode the old type without loss of\n * precision.\n */\nexport function hasEncodingLoss(oldType, newType) {\n    if (newType === 'complex64') {\n        return false;\n    }\n    if (newType === 'float32' && oldType !== 'complex64') {\n        return false;\n    }\n    if (newType === 'int32' && oldType !== 'float32' && oldType !== 'complex64') {\n        return false;\n    }\n    if (newType === 'bool' && oldType === 'bool') {\n        return false;\n    }\n    return true;\n}\nexport function isTypedArray(a) {\n    return a instanceof Float32Array || a instanceof Int32Array ||\n        a instanceof Uint8Array;\n}\nexport function bytesPerElement(dtype) {\n    if (dtype === 'float32' || dtype === 'int32') {\n        return 4;\n    }\n    else if (dtype === 'complex64') {\n        return 8;\n    }\n    else if (dtype === 'bool') {\n        return 1;\n    }\n    else {\n        throw new Error(`Unknown dtype ${dtype}`);\n    }\n}\n/**\n * Returns the approximate number of bytes allocated in the string array - 2\n * bytes per character. Computing the exact bytes for a native string in JS is\n * not possible since it depends on the encoding of the html page that serves\n * the website.\n */\nexport function bytesFromStringArray(arr) {\n    if (arr == null) {\n        return 0;\n    }\n    let bytes = 0;\n    arr.forEach(x => bytes += x.length);\n    return bytes;\n}\n/** Returns true if the value is a string. */\nexport function isString(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexport function isBoolean(value) {\n    return typeof value === 'boolean';\n}\nexport function isNumber(value) {\n    return typeof value === 'number';\n}\nexport function inferDtype(values) {\n    if (Array.isArray(values)) {\n        return inferDtype(values[0]);\n    }\n    if (values instanceof Float32Array) {\n        return 'float32';\n    }\n    else if (values instanceof Int32Array || values instanceof Uint8Array) {\n        return 'int32';\n    }\n    else if (isNumber(values)) {\n        return 'float32';\n    }\n    else if (isString(values)) {\n        return 'string';\n    }\n    else if (isBoolean(values)) {\n        return 'bool';\n    }\n    return 'float32';\n}\nexport function isFunction(f) {\n    return !!(f && f.constructor && f.call && f.apply);\n}\nexport function nearestDivisor(size, start) {\n    for (let i = start; i < size; ++i) {\n        if (size % i === 0) {\n            return i;\n        }\n    }\n    return size;\n}\nexport function computeStrides(shape) {\n    const rank = shape.length;\n    if (rank < 2) {\n        return [];\n    }\n    // Last dimension has implicit stride of 1, thus having D-1 (instead of D)\n    // strides.\n    const strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n        strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    return strides;\n}\nexport function toTypedArray(a, dtype) {\n    if (dtype === 'string') {\n        throw new Error('Cannot convert a string[] to a TypedArray');\n    }\n    if (Array.isArray(a)) {\n        a = flatten(a);\n    }\n    if (env().getBool('DEBUG')) {\n        checkConversionForErrors(a, dtype);\n    }\n    if (noConversionNeeded(a, dtype)) {\n        return a;\n    }\n    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {\n        return new Float32Array(a);\n    }\n    else if (dtype === 'int32') {\n        return new Int32Array(a);\n    }\n    else if (dtype === 'bool') {\n        const bool = new Uint8Array(a.length);\n        for (let i = 0; i < bool.length; ++i) {\n            if (Math.round(a[i]) !== 0) {\n                bool[i] = 1;\n            }\n        }\n        return bool;\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n}\nfunction createNestedArray(offset, shape, a) {\n    const ret = new Array();\n    if (shape.length === 1) {\n        const d = shape[0];\n        for (let i = 0; i < d; i++) {\n            ret[i] = a[offset + i];\n        }\n    }\n    else {\n        const d = shape[0];\n        const rest = shape.slice(1);\n        const len = rest.reduce((acc, c) => acc * c);\n        for (let i = 0; i < d; i++) {\n            ret[i] = createNestedArray(offset + i * len, rest, a);\n        }\n    }\n    return ret;\n}\n// Provide a nested array of TypedArray in given shape.\nexport function toNestedArray(shape, a) {\n    if (shape.length === 0) {\n        // Scalar type should return a single number.\n        return a[0];\n    }\n    const size = shape.reduce((acc, c) => acc * c);\n    if (size === 0) {\n        // A tensor with shape zero should be turned into empty list.\n        return [];\n    }\n    if (size !== a.length) {\n        throw new Error(`[${shape}] does not match the input size ${a.length}.`);\n    }\n    return createNestedArray(0, shape, a);\n}\nfunction noConversionNeeded(a, dtype) {\n    return (a instanceof Float32Array && dtype === 'float32') ||\n        (a instanceof Int32Array && dtype === 'int32') ||\n        (a instanceof Uint8Array && dtype === 'bool');\n}\nexport function makeOnesTypedArray(size, dtype) {\n    const array = makeZerosTypedArray(size, dtype);\n    for (let i = 0; i < array.length; i++) {\n        array[i] = 1;\n    }\n    return array;\n}\nexport function makeZerosTypedArray(size, dtype) {\n    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {\n        return new Float32Array(size);\n    }\n    else if (dtype === 'int32') {\n        return new Int32Array(size);\n    }\n    else if (dtype === 'bool') {\n        return new Uint8Array(size);\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n}\n/**\n * Make nested `TypedArray` filled with zeros.\n * @param shape The shape information for the nested array.\n * @param dtype dtype of the array element.\n */\nexport function makeZerosNestedTypedArray(shape, dtype) {\n    const size = shape.reduce((prev, curr) => prev * curr, 1);\n    if (dtype == null || dtype === 'float32') {\n        return toNestedArray(shape, new Float32Array(size));\n    }\n    else if (dtype === 'int32') {\n        return toNestedArray(shape, new Int32Array(size));\n    }\n    else if (dtype === 'bool') {\n        return toNestedArray(shape, new Uint8Array(size));\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n}\n/**\n * Returns the current high-resolution time in milliseconds relative to an\n * arbitrary time in the past. It works across different platforms (node.js,\n * browsers).\n *\n * ```js\n * console.log(tf.util.now());\n * ```\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function now() {\n    return env().platform.now();\n}\nexport function assertNonNegativeIntegerDimensions(shape) {\n    shape.forEach(dimSize => {\n        assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got ` +\n            `shape [${shape}].`);\n    });\n}\n/**\n * Returns a platform-specific implementation of\n * [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n *\n * If `fetch` is defined on the global object (`window`, `process`, etc.),\n * `tf.util.fetch` returns that function.\n *\n * If not, `tf.util.fetch` returns a platform-specific solution.\n *\n * ```js\n * const resource = await tf.util.fetch('https://unpkg.com/@tensorflow/tfjs');\n * // handle response\n * ```\n *\n * @doc {heading: 'Util'}\n */\nexport function fetch(path, requestInits) {\n    return env().platform.fetch(path, requestInits);\n}\n/**\n * Encodes the provided string into bytes using the provided encoding scheme.\n *\n * @param s The string to encode.\n * @param encoding The encoding scheme. Defaults to utf-8.\n *\n * @doc {heading: 'Util'}\n */\nexport function encodeString(s, encoding = 'utf-8') {\n    encoding = encoding || 'utf-8';\n    return env().platform.encode(s, encoding);\n}\n/**\n * Decodes the provided bytes into a string using the provided encoding scheme.\n * @param bytes The bytes to decode.\n *\n * @param encoding The encoding scheme. Defaults to utf-8.\n *\n * @doc {heading: 'Util'}\n */\nexport function decodeString(bytes, encoding = 'utf-8') {\n    encoding = encoding || 'utf-8';\n    return env().platform.decode(bytes, encoding);\n}\n/**\n * Computes flat index for a given location (multidimentionsal index) in a\n * Tensor/multidimensional array.\n *\n * @param locs Location in the tensor.\n * @param rank Rank of the tensor.\n * @param strides Tensor strides.\n */\nexport function locToIndex(locs, rank, strides) {\n    if (rank === 0) {\n        return 0;\n    }\n    else if (rank === 1) {\n        return locs[0];\n    }\n    let index = locs[locs.length - 1];\n    for (let i = 0; i < locs.length - 1; ++i) {\n        index += strides[i] * locs[i];\n    }\n    return index;\n}\n/**\n * Computes the location (multidimensional index) in a tensor/multidimentional\n * array for a given flat index.\n *\n * @param index Index in flat array.\n * @param rank Rank of tensor.\n * @param strides Strides of tensor.\n */\nexport function indexToLoc(index, rank, strides) {\n    if (rank === 0) {\n        return [];\n    }\n    else if (rank === 1) {\n        return [index];\n    }\n    const locs = new Array(rank);\n    for (let i = 0; i < locs.length - 1; ++i) {\n        locs[i] = Math.floor(index / strides[i]);\n        index -= locs[i] * strides[i];\n    }\n    locs[locs.length - 1] = index;\n    return locs;\n}\n//# sourceMappingURL=util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tensor } from './tensor';\nimport { upcastType } from './types';\nimport { assert } from './util';\nexport function makeTypesMatch(a, b) {\n    if (a.dtype === b.dtype) {\n        return [a, b];\n    }\n    const dtype = upcastType(a.dtype, b.dtype);\n    return [a.cast(dtype), b.cast(dtype)];\n}\nexport function assertTypesMatch(a, b) {\n    assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and` +\n        ` second(${b.dtype}) input must match`);\n}\nexport function isTensorInList(tensor, tensorList) {\n    return tensorList.some(x => x.id === tensor.id);\n}\n/**\n * Extracts any `Tensor`s found within the provided object.\n *\n * @param container an object that may be a `Tensor` or may directly contain\n *   `Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. In general it\n *   is safe to pass any object here, except that `Promise`s are not\n *   supported.\n * @returns An array of `Tensors` found within the passed object. If the\n *   argument is simply a `Tensor', a list containing that `Tensor` is\n *   returned. If the object is not a `Tensor` or does not\n *   contain `Tensors`, an empty list is returned.\n */\nexport function getTensorsInContainer(result) {\n    const list = [];\n    const seen = new Set();\n    walkTensorContainer(result, list, seen);\n    return list;\n}\nfunction walkTensorContainer(container, list, seen) {\n    if (container == null) {\n        return;\n    }\n    if (container instanceof Tensor) {\n        list.push(container);\n        return;\n    }\n    if (!isIterable(container)) {\n        return;\n    }\n    // Iteration over keys works also for arrays.\n    const iterable = container;\n    for (const k in iterable) {\n        const val = iterable[k];\n        if (!seen.has(val)) {\n            seen.add(val);\n            walkTensorContainer(val, list, seen);\n        }\n    }\n}\n// tslint:disable-next-line:no-any\nfunction isIterable(obj) {\n    return Array.isArray(obj) || typeof obj === 'object';\n}\n//# sourceMappingURL=tensor_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from './util';\n/**\n * Computes a list of TapeNodes that connect x to y, filtering everything else\n * out and preserving the order of the original tape elements.\n *\n * @param tape The tape elements to filter.\n * @param xs The input Tensors.\n * @param y The output Tensor.\n */\nexport function getFilteredNodesXToY(tape, xs, y) {\n    // Forward pass to compute all the nodes and Tensors that are transitively a\n    // function of x.\n    const tensorsFromX = {};\n    const nodesFromX = {};\n    for (let i = 0; i < xs.length; i++) {\n        tensorsFromX[xs[i].id] = true;\n    }\n    for (let i = 0; i < tape.length; i++) {\n        const node = tape[i];\n        const nodeInputs = node.inputs;\n        for (const inputName in nodeInputs) {\n            const input = nodeInputs[inputName];\n            let anyInputFromX = false;\n            for (let j = 0; j < xs.length; j++) {\n                if (tensorsFromX[input.id]) {\n                    node.outputs.forEach(output => tensorsFromX[output.id] = true);\n                    anyInputFromX = true;\n                    nodesFromX[node.id] = true;\n                    break;\n                }\n            }\n            if (anyInputFromX) {\n                break;\n            }\n        }\n    }\n    // Backward pass to find all of the nodes and Tensors that lead to y.\n    const tensorsLeadToY = {};\n    tensorsLeadToY[y.id] = true;\n    const nodesToY = {};\n    for (let i = tape.length - 1; i >= 0; i--) {\n        const node = tape[i];\n        const nodeInputs = node.inputs;\n        // If any of the outputs lead to y, mark all of the inputs as leading to y.\n        for (let j = 0; j < node.outputs.length; j++) {\n            if (tensorsLeadToY[node.outputs[j].id]) {\n                for (const inputName in nodeInputs) {\n                    tensorsLeadToY[nodeInputs[inputName].id] = true;\n                    nodesToY[node.id] = true;\n                }\n                break;\n            }\n        }\n    }\n    // Return the paths that come from x and lead to y.\n    const filteredTape = [];\n    for (let i = 0; i < tape.length; i++) {\n        const node = tape[i];\n        if (nodesFromX[node.id] && nodesToY[node.id]) {\n            // Prune the inputs from the node that aren't a function of x.\n            const prunedInputs = {};\n            for (const inputName in node.inputs) {\n                const nodeInput = node.inputs[inputName];\n                if (tensorsFromX[nodeInput.id]) {\n                    prunedInputs[inputName] = nodeInput;\n                }\n            }\n            // Copy the node and overwrite inputsAndArgs to the pruned version.\n            const prunedNode = Object.assign({}, node);\n            prunedNode.inputs = prunedInputs;\n            prunedNode.outputs = node.outputs;\n            filteredTape.push(prunedNode);\n        }\n    }\n    return filteredTape;\n}\n/**\n * Backpropagate gradients through the filtered TapeNodes.\n *\n * @param tensorAccumulatedGradientMap A map of Tensor to its gradient. This map\n * is mutated by this method.\n * @param filteredTape The filtered TapeNodes to backprop through.\n */\nexport function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy, add) {\n    // Walk the tape backward and keep a map of Tensor to its gradient.\n    for (let i = filteredTape.length - 1; i >= 0; i--) {\n        const node = filteredTape[i];\n        const dys = [];\n        node.outputs.forEach(o => {\n            const gradTensor = tensorAccumulatedGradientMap[o.id];\n            if (gradTensor != null) {\n                dys.push(gradTensor);\n            }\n            else {\n                // This particular output is not in the back-propagation subgraph, so it\n                // does not affect the final output, thus we put null for its dy.\n                dys.push(null);\n            }\n        });\n        if (node.gradient == null) {\n            throw new Error(`Cannot compute gradient: gradient function not found ` +\n                `for ${node.kernelName}.`);\n        }\n        // Backprop dy through this node and accumulate gradients over the inputs.\n        const inputGradients = node.gradient(dys);\n        for (const inputName in node.inputs) {\n            if (!(inputName in inputGradients)) {\n                throw new Error(`Cannot backprop through input ${inputName}. ` +\n                    `Available gradients found: ${Object.keys(inputGradients)}.`);\n            }\n            // Call the gradient function.\n            const dx = tidy(() => inputGradients[inputName]());\n            if (dx.dtype !== 'float32') {\n                throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` +\n                    `${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);\n            }\n            const x = node.inputs[inputName];\n            if (!util.arraysEqual(dx.shape, x.shape)) {\n                throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` +\n                    `'${inputName}' has shape '${dx.shape}', which does not match ` +\n                    `the shape of the input '${x.shape}'`);\n            }\n            if (tensorAccumulatedGradientMap[x.id] == null) {\n                tensorAccumulatedGradientMap[x.id] = dx;\n            }\n            else {\n                const curGradient = tensorAccumulatedGradientMap[x.id];\n                tensorAccumulatedGradientMap[x.id] = add(curGradient, dx);\n                curGradient.dispose();\n            }\n        }\n    }\n}\n//# sourceMappingURL=tape.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { Tensor } from './tensor';\nimport { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';\nexport function inferShape(val, dtype) {\n    let firstElem = val;\n    if (isTypedArray(val)) {\n        return dtype === 'string' ? [] : [val.length];\n    }\n    if (!Array.isArray(val)) {\n        return []; // Scalar.\n    }\n    const shape = [];\n    while (Array.isArray(firstElem) ||\n        isTypedArray(firstElem) && dtype !== 'string') {\n        shape.push(firstElem.length);\n        firstElem = firstElem[0];\n    }\n    if (Array.isArray(val) &&\n        env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n        deepAssertShapeConsistency(val, shape, []);\n    }\n    return shape;\n}\nfunction deepAssertShapeConsistency(val, shape, indices) {\n    indices = indices || [];\n    if (!(Array.isArray(val)) && !isTypedArray(val)) {\n        assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` +\n            `but should be an array/TypedArray of ${shape[0]} elements`);\n        return;\n    }\n    assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` +\n        `but is an array of ${val.length} elements`);\n    assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +\n        `elements, but has ${val.length} elements`);\n    const subShape = shape.slice(1);\n    for (let i = 0; i < val.length; ++i) {\n        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n    }\n}\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\n    if (expectedDtype == null) {\n        return;\n    }\n    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||\n        expectedDtype === 'numeric' && actualDType === 'string') {\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must ` +\n            `be ${expectedDtype} tensor, but got ${actualDType} tensor`);\n    }\n}\nexport function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {\n    if (x instanceof Tensor) {\n        assertDtype(parseAsDtype, x.dtype, argName, functionName);\n        return x;\n    }\n    let inferredDtype = inferDtype(x);\n    // If the user expects a bool/int/float, use that info to update the\n    // inferredDtype when it is not a string.\n    if (inferredDtype !== 'string' &&\n        ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n        inferredDtype = parseAsDtype;\n    }\n    assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n    if ((x == null) ||\n        (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&\n            typeof x !== 'boolean' && typeof x !== 'string')) {\n        const type = x == null ? 'null' : x.constructor.name;\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` +\n            `Tensor or TensorLike, but got '${type}'`);\n    }\n    const inferredShape = inferShape(x, inferredDtype);\n    if (!isTypedArray(x) && !Array.isArray(x)) {\n        x = [x];\n    }\n    const skipTypedArray = true;\n    const values = inferredDtype !== 'string' ?\n        toTypedArray(x, inferredDtype) :\n        flatten(x, [], skipTypedArray);\n    return ENGINE.makeTensor(values, inferredShape, inferredDtype);\n}\nexport function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {\n    if (!Array.isArray(arg)) {\n        throw new Error(`Argument ${argName} passed to ${functionName} must be a ` +\n            '`Tensor[]` or `TensorLike[]`');\n    }\n    const tensors = arg;\n    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName), parseAsDtype);\n}\n//# sourceMappingURL=tensor_util_env.js.map","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n    const strides = computeStrides(shape);\n    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n    const rank = shape.length;\n    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n    const lines = ['Tensor'];\n    if (verbose) {\n        lines.push(`  dtype: ${dtype}`);\n        lines.push(`  rank: ${rank}`);\n        lines.push(`  shape: [${shape}]`);\n        lines.push(`  values:`);\n    }\n    lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n    return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n    const n = sizeFromShape(shape);\n    const numCols = strides[strides.length - 1];\n    const padPerCol = new Array(numCols).fill(0);\n    const rank = shape.length;\n    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n    if (rank > 1) {\n        for (let row = 0; row < n / numCols; row++) {\n            const offset = row * numCols;\n            for (let j = 0; j < numCols; j++) {\n                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n            }\n        }\n    }\n    return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n    let valStr;\n    if (Array.isArray(val)) {\n        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n    }\n    else if (isString(val)) {\n        valStr = `'${val}'`;\n    }\n    else if (dtype === 'bool') {\n        valStr = boolNumToString(val);\n    }\n    else {\n        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n    }\n    return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n    return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n    const storagePerElement = dtype === 'complex64' ? 2 : 1;\n    const size = shape[0];\n    const rank = shape.length;\n    if (rank === 0) {\n        if (dtype === 'complex64') {\n            const complexTuple = createComplexTuples(vals);\n            return [valToString(complexTuple[0], 0, dtype)];\n        }\n        if (dtype === 'bool') {\n            return [boolNumToString(vals[0])];\n        }\n        return [vals[0].toString()];\n    }\n    if (rank === 1) {\n        if (size > FORMAT_LIMIT_NUM_VALS) {\n            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n            let firstVals = Array.from(vals.slice(0, firstValsSize));\n            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n            if (dtype === 'complex64') {\n                firstVals = createComplexTuples(firstVals);\n                lastVals = createComplexTuples(lastVals);\n            }\n            return [\n                '[' +\n                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                        .join(', ') +\n                    ', ..., ' +\n                    lastVals\n                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n                        .join(', ') +\n                    ']'\n            ];\n        }\n        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :\n            Array.from(vals);\n        return [\n            '[' +\n                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                    .join(', ') +\n                ']'\n        ];\n    }\n    // The array is rank 2 or more.\n    const subshape = shape.slice(1);\n    const substrides = strides.slice(1);\n    const stride = strides[0] * storagePerElement;\n    const lines = [];\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n        }\n        lines.push('...');\n        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    else {\n        for (let i = 0; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    const sep = rank === 2 ? ',' : '';\n    lines[0] = '[' + lines[0] + sep;\n    for (let i = 1; i < lines.length - 1; i++) {\n        lines[i] = ' ' + lines[i] + sep;\n    }\n    let newLineSep = ',\\n';\n    for (let i = 2; i < rank; i++) {\n        newLineSep += '\\n';\n    }\n    lines[lines.length - 1] =\n        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n    return lines;\n}\nfunction createComplexTuples(vals) {\n    const complexTuples = [];\n    for (let i = 0; i < vals.length; i += 2) {\n        complexTuples.push([vals[i], vals[i + 1]]);\n    }\n    return complexTuples;\n}\n//# sourceMappingURL=tensor_format.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tensorToString } from './tensor_format';\nimport * as util from './util';\nimport { computeStrides, toNestedArray } from './util';\n/**\n * A mutable object, similar to `tf.Tensor`, that allows users to set values\n * at locations before converting to an immutable `tf.Tensor`.\n *\n * See `tf.buffer` for creating a tensor buffer.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class TensorBuffer {\n    constructor(shape, dtype, values) {\n        this.dtype = dtype;\n        this.shape = shape.slice();\n        this.size = util.sizeFromShape(shape);\n        if (values != null) {\n            const n = values.length;\n            util.assert(n === this.size, () => `Length of values '${n}' does not match the size ` +\n                `inferred by the shape '${this.size}'.`);\n        }\n        if (dtype === 'complex64') {\n            throw new Error(`complex64 dtype TensorBuffers are not supported. Please create ` +\n                `a TensorBuffer for the real and imaginary parts separately and ` +\n                `call tf.complex(real, imag).`);\n        }\n        this.values = values || util.getArrayFromDType(dtype, this.size);\n        this.strides = computeStrides(shape);\n    }\n    /**\n     * Sets a value in the buffer at a given location.\n     *\n     * @param value The value to set.\n     * @param locs  The location indices.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Creation'}\n     */\n    set(value, ...locs) {\n        if (locs.length === 0) {\n            locs = [0];\n        }\n        util.assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must ` +\n            `match the rank (${this.rank})`);\n        const index = this.locToIndex(locs);\n        this.values[index] = value;\n    }\n    /**\n     * Returns the value in the buffer at the provided location.\n     *\n     * @param locs The location indices.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Creation'}\n     */\n    get(...locs) {\n        if (locs.length === 0) {\n            locs = [0];\n        }\n        let i = 0;\n        for (const loc of locs) {\n            if (loc < 0 || loc >= this.shape[i]) {\n                const msg = `Requested out of range element at ${locs}. ` +\n                    `  Buffer shape=${this.shape}`;\n                throw new Error(msg);\n            }\n            i++;\n        }\n        let index = locs[locs.length - 1];\n        for (let i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return this.values[index];\n    }\n    locToIndex(locs) {\n        if (this.rank === 0) {\n            return 0;\n        }\n        else if (this.rank === 1) {\n            return locs[0];\n        }\n        let index = locs[locs.length - 1];\n        for (let i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return index;\n    }\n    indexToLoc(index) {\n        if (this.rank === 0) {\n            return [];\n        }\n        else if (this.rank === 1) {\n            return [index];\n        }\n        const locs = new Array(this.shape.length);\n        for (let i = 0; i < locs.length - 1; ++i) {\n            locs[i] = Math.floor(index / this.strides[i]);\n            index -= locs[i] * this.strides[i];\n        }\n        locs[locs.length - 1] = index;\n        return locs;\n    }\n    get rank() {\n        return this.shape.length;\n    }\n    /**\n     * Creates an immutable `tf.Tensor` object from the buffer.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Creation'}\n     */\n    toTensor() {\n        return trackerFn().makeTensor(this.values, this.shape, this.dtype);\n    }\n}\n// For tracking tensor creation and disposal.\nlet trackerFn = null;\n// Used by chaining methods to call into ops.\nlet opHandler = null;\n// Used to warn about deprecated methods.\nlet deprecationWarningFn = null;\n// This here so that we can use this method on dev branches and keep the\n// functionality at master.\n// tslint:disable-next-line:no-unused-expression\n[deprecationWarningFn];\n/**\n * An external consumer can register itself as the tensor tracker. This way\n * the Tensor class can notify the tracker for every tensor created and\n * disposed.\n */\nexport function setTensorTracker(fn) {\n    trackerFn = fn;\n}\n/**\n * An external consumer can register itself as the op handler. This way the\n * Tensor class can have chaining methods that call into ops via the op\n * handler.\n */\nexport function setOpHandler(handler) {\n    opHandler = handler;\n}\n/**\n * Sets the deprecation warning function to be used by this file. This way the\n * Tensor class can be a leaf but still use the environment.\n */\nexport function setDeprecationWarningFn(fn) {\n    deprecationWarningFn = fn;\n}\n/**\n * A `tf.Tensor` object represents an immutable, multidimensional array of\n * numbers that has a shape and a data type.\n *\n * See `tf.tensor` for details on how to create a `tf.Tensor`.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class Tensor {\n    constructor(shape, dtype, dataId, id) {\n        /** Whether this tensor has been globally kept. */\n        this.kept = false;\n        this.isDisposedInternal = false;\n        this.shape = shape.slice();\n        this.dtype = dtype || 'float32';\n        this.size = util.sizeFromShape(shape);\n        this.strides = computeStrides(shape);\n        this.dataId = dataId;\n        this.id = id;\n        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');\n    }\n    get rank() {\n        return this.shape.length;\n    }\n    /**\n     * Returns a promise of `tf.TensorBuffer` that holds the underlying data.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    async buffer() {\n        const vals = await this.data();\n        return opHandler.buffer(this.shape, this.dtype, vals);\n    }\n    /**\n     * Returns a `tf.TensorBuffer` that holds the underlying data.\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    bufferSync() {\n        return opHandler.buffer(this.shape, this.dtype, this.dataSync());\n    }\n    /**\n     * Returns the tensor data as a nested array. The transfer of data is done\n     * asynchronously.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    async array() {\n        const vals = await this.data();\n        return toNestedArray(this.shape, vals);\n    }\n    /**\n     * Returns the tensor data as a nested array. The transfer of data is done\n     * synchronously.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    arraySync() {\n        return toNestedArray(this.shape, this.dataSync());\n    }\n    /**\n     * Asynchronously downloads the values from the `tf.Tensor`. Returns a\n     * promise of `TypedArray` that resolves when the computation has finished.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    async data() {\n        this.throwIfDisposed();\n        const data = trackerFn().read(this.dataId);\n        if (this.dtype === 'string') {\n            const bytes = await data;\n            try {\n                return bytes.map(b => util.decodeString(b));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode the string bytes into utf-8. ' +\n                    'To get the original bytes, call tensor.bytes().');\n            }\n        }\n        return data;\n    }\n    /**\n     * Synchronously downloads the values from the `tf.Tensor`. This blocks the\n     * UI thread until the values are ready, which can cause performance issues.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    dataSync() {\n        this.throwIfDisposed();\n        const data = trackerFn().readSync(this.dataId);\n        if (this.dtype === 'string') {\n            try {\n                return data.map(b => util.decodeString(b));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode the string bytes into utf-8. ' +\n                    'To get the original bytes, call tensor.bytes().');\n            }\n        }\n        return data;\n    }\n    /** Returns the underlying bytes of the tensor's data. */\n    async bytes() {\n        this.throwIfDisposed();\n        const data = await trackerFn().read(this.dataId);\n        if (this.dtype === 'string') {\n            return data;\n        }\n        else {\n            return new Uint8Array(data.buffer);\n        }\n    }\n    /**\n     * Disposes `tf.Tensor` from memory.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        trackerFn().disposeTensor(this);\n        this.isDisposedInternal = true;\n    }\n    get isDisposed() {\n        return this.isDisposedInternal;\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error(`Tensor is disposed.`);\n        }\n    }\n    /**\n     * Prints the `tf.Tensor`. See `tf.print` for details.\n     *\n     * @param verbose Whether to print verbose information about the tensor,\n     *    including dtype and size.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    print(verbose = false) {\n        return opHandler.print(this, verbose);\n    }\n    /**\n     * Returns a copy of the tensor. See `tf.clone` for details.\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    clone() {\n        this.throwIfDisposed();\n        return opHandler.clone(this);\n    }\n    /**\n     * Returns a human-readable description of the tensor. Useful for logging.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    toString(verbose = false) {\n        const vals = this.dataSync();\n        return tensorToString(vals, this.shape, this.dtype, verbose);\n    }\n    cast(dtype) {\n        this.throwIfDisposed();\n        return opHandler.cast(this, dtype);\n    }\n    variable(trainable = true, name, dtype) {\n        this.throwIfDisposed();\n        return trackerFn().makeVariable(this, trainable, name, dtype);\n    }\n}\nObject.defineProperty(Tensor, Symbol.hasInstance, {\n    value: (instance) => {\n        // Implementation note: we should use properties of the object that will be\n        // defined before the constructor body has finished executing (methods).\n        // This is because when this code is transpiled by babel, babel will call\n        // classCallCheck before the constructor body is run.\n        // See https://github.com/tensorflow/tfjs/issues/3384 for backstory.\n        return !!instance && instance.data != null && instance.dataSync != null &&\n            instance.throwIfDisposed != null;\n    }\n});\n/**\n * A mutable `tf.Tensor`, useful for persisting state, e.g. for training.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class Variable extends Tensor {\n    constructor(initialValue, trainable, name, tensorId) {\n        super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);\n        this.trainable = trainable;\n        this.name = name;\n    }\n    /**\n     * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have\n     * the same shape and dtype as the old `tf.Tensor`.\n     *\n     * @param newValue New tensor to be assigned to this variable.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    assign(newValue) {\n        if (newValue.dtype !== this.dtype) {\n            throw new Error(`dtype of the new value (${newValue.dtype}) and ` +\n                `previous value (${this.dtype}) must match`);\n        }\n        if (!util.arraysEqual(newValue.shape, this.shape)) {\n            throw new Error(`shape of the new value (${newValue.shape}) and ` +\n                `previous value (${this.shape}) must match`);\n        }\n        trackerFn().disposeTensor(this);\n        this.dataId = newValue.dataId;\n        trackerFn().incRef(this, null /* backend */);\n    }\n    dispose() {\n        trackerFn().disposeVariable(this);\n        this.isDisposedInternal = true;\n    }\n}\nObject.defineProperty(Variable, Symbol.hasInstance, {\n    value: (instance) => {\n        return instance instanceof Tensor && instance.assign != null &&\n            instance.assign instanceof Function;\n    }\n});\n//# sourceMappingURL=tensor.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var Rank;\n(function (Rank) {\n    Rank[\"R0\"] = \"R0\";\n    Rank[\"R1\"] = \"R1\";\n    Rank[\"R2\"] = \"R2\";\n    Rank[\"R3\"] = \"R3\";\n    Rank[\"R4\"] = \"R4\";\n    Rank[\"R5\"] = \"R5\";\n    Rank[\"R6\"] = \"R6\";\n})(Rank || (Rank = {}));\n// Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\nvar UpcastInt32AndMap;\n(function (UpcastInt32AndMap) {\n    UpcastInt32AndMap[\"float32\"] = \"float32\";\n    UpcastInt32AndMap[\"int32\"] = \"int32\";\n    UpcastInt32AndMap[\"bool\"] = \"int32\";\n    UpcastInt32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\nvar UpcastBoolAndMap;\n(function (UpcastBoolAndMap) {\n    UpcastBoolAndMap[\"float32\"] = \"float32\";\n    UpcastBoolAndMap[\"int32\"] = \"int32\";\n    UpcastBoolAndMap[\"bool\"] = \"bool\";\n    UpcastBoolAndMap[\"complex64\"] = \"complex64\";\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\nvar UpcastFloat32AndMap;\n(function (UpcastFloat32AndMap) {\n    UpcastFloat32AndMap[\"float32\"] = \"float32\";\n    UpcastFloat32AndMap[\"int32\"] = \"float32\";\n    UpcastFloat32AndMap[\"bool\"] = \"float32\";\n    UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\nvar UpcastComplex64AndMap;\n(function (UpcastComplex64AndMap) {\n    UpcastComplex64AndMap[\"float32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"int32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"bool\"] = \"complex64\";\n    UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\nconst upcastTypeMap = {\n    'float32': UpcastFloat32AndMap,\n    'int32': UpcastInt32AndMap,\n    'bool': UpcastBoolAndMap,\n    'complex64': UpcastComplex64AndMap\n};\nexport function upcastType(typeA, typeB) {\n    if (typeA === 'string' || typeB === 'string') {\n        if (typeA === 'string' && typeB === 'string') {\n            return 'string';\n        }\n        throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n    }\n    return upcastTypeMap[typeA][typeB];\n}\n/** Returns the output type after summation. */\nexport function sumOutType(type) {\n    return upcastType(type, 'int32');\n}\n//# sourceMappingURL=types.js.map"],"sourceRoot":""}