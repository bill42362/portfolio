/*! For license information please see bundle~bundle~4b2d83a9.6ef3cb0b.js.LICENSE.txt */
(("undefined"!=typeof self?self:this).webpackJsonp=("undefined"!=typeof self?self:this).webpackJsonp||[]).push([[6],{101:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(18),u=n(4),i=n(7),b=n(23);const l=Object(u.a)({min_:function(t,e=null,n=!1){const u=Object(s.a)(t,"x","min"),l={x:u},O={axis:e,keepDims:n};return a.a.runKernelFunc(((t,a)=>{const r=Object(c.parseAxisParam)(e,u.shape);let s=r;const l=o.f(s,u.rank);let O=u;null!=l&&(O=Object(b.a)(u,l),s=o.g(s.length,u.rank));const p=t.min(O,s);null!=l&&O.dispose();let j=p;if(n){const t=o.e(j.shape,r);j=Object(i.a)(p,t),p.dispose()}return a([u,j]),j}),l,null,r.Kb,O)}})},110:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(4);const u=Object(o.a)({floorDiv_:function(t,e){let n=Object(c.a)(t,"a","floorDiv"),o=Object(c.a)(e,"b","floorDiv");[n,o]=Object(s.b)(n,o);const u={a:n,b:o};return a.a.runKernelFunc(((t,e)=>{const a=t.floorDiv(n,o);return e([n,o]),a}),u,null,r.cb)}})},116:function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var a=n(33),r=n(3),s=n(0),c=n(18),o=n(10),u=n(17),i=n(9),b=n(72),l=n(4),O=n(7),p=n(14),j=n(12);const h=Object(l.a)({mean_:function(t,e=null,n=!1){const l=Object(r.a)(t,"x","mean"),h=Object(s.parseAxisParam)(e,l.shape),d=Object(c.d)(l.shape,h)[1],f=Object(s.sizeFromShape)(d);return Object(a.a)((t=>{const a=Object(p.a)(f),r=a.dtype===t.dtype?t:Object(o.a)(t,a.dtype),s=Object(u.a)(r,a);return{value:Object(j.a)(s,e,n),gradFunc:e=>{const n=t.shape.slice();h.forEach((t=>{n[t]=1}));const a=Object(O.a)(e,n);return Object(u.a)(Object(i.a)(a,Object(b.a)(t.shape,"float32")),f)}}}))(l)}})},117:function(t,e,n){"use strict";n.d(e,"a",(function(){return j}));var a=n(3),r=n(0),s=n(22),c=n(18),o=n(39),u=n(69),i=n(64),b=n(4),l=n(7),O=n(15),p=n(12);const j=Object(b.a)({logSumExp_:function(t,e=null,n=!1){const b=Object(a.a)(t,"x","logSumExp"),j=Object(r.parseAxisParam)(e,b.shape),h=Object(i.a)(b,j,!0),d=Object(O.a)(b,h),f=Object(o.a)(d),m=Object(p.a)(f,j),g=Object(u.a)(m),k=Object(s.a)(Object(l.a)(h,g.shape),g);if(n){const t=Object(c.e)(k.shape,j);return Object(l.a)(k,t)}return k}})},125:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(4),u=n(7),i=n(171);const b=Object(o.a)({gather_:function(t,e,n=0){const o=Object(s.a)(t,"x","gather"),b=Object(s.a)(e,"indices","gather","int32"),l={x:o,indices:b},O={axis:n};return a.a.runKernelFunc(((t,e)=>{const a=Object(c.parseAxisParam)(n,o.shape)[0],r=Object(i.collectGatherOpShapeInfo)(o,b,a),s=t.gather(o,Object(u.a)(b,[b.size]),a);return e([o,b]),Object(u.a)(s,r.outputShape)}),l,null,r.ib,O)}})},126:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(4);const u=Object(o.a)({mod_:function(t,e){let n=Object(c.a)(t,"a","mod"),o=Object(c.a)(e,"b","mod");[n,o]=Object(s.b)(n,o);const u={a:n,b:o};return a.a.runKernelFunc(((t,e)=>{const a=t.mod(n,o);return e([n,o]),a}),u,null,r.Mb)}})},128:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(11),o=n(4);const u=Object(o.a)({logicalOr_:function(t,e){const n=Object(s.a)(t,"a","logicalOr","bool"),o=Object(s.a)(e,"b","logicalOr","bool");Object(c.a)(n.shape,o.shape);const u={a:n,b:o};return a.a.runKernelFunc((t=>t.logicalOr(n,o)),u,null,r.Bb)}})},129:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(16),u=n(4),i=n(7);const b=Object(u.a)({maxPool_:function(t,e,n,u,b){const l=Object(s.a)(t,"x","maxPool");let O=l,p=!1;3===l.rank&&(p=!0,O=Object(i.a)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),c.assert(4===O.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${O.rank}.`)),c.assert(o.h(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=b&&c.assert(c.isInt(u),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${b} but got pad ${u}.`));const j={x:O},h={filterSize:e,strides:n,pad:u,dimRoundingMode:b},d=a.a.runKernelFunc(((t,a)=>{const r=o.e(O.shape,e,n,1,u,b);let s;return s=1===r.filterWidth&&1===r.filterHeight&&c.arraysEqual(r.inShape,r.outShape)?O.clone():t.maxPool(O,r),a([O,s]),s}),j,null,r.Db,h);return p?Object(i.a)(d,[d.shape[1],d.shape[2],d.shape[3]]):d}})},161:function(t,e,n){"use strict";n.r(e),n.d(e,"prepareAndValidate",(function(){return r}));var a=n(0);function r(t,e){if(t.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[e.rank-1]>t.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank-1]} vs. ${t.rank}`);if(0===t.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const n=e.shape,r=n[n.length-1];let s=1;for(let t=0;t<n.length-1;++t)s*=n[t];const c=t.shape,o=n.slice();o.pop();let u=1;for(let e=r;e<t.rank;++e)u*=c[e],o.push(c[e]);const i=[...Object(a.computeStrides)(t.shape).map((t=>t/u)),1].slice(0,r);return[o,s,u,i]}},166:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(5),r=n(2);function s(t,e,n){const s={shape:t,value:e,dtype:n};return a.a.runKernelFunc((a=>a.fill(t,e,n)),{},null,r.Z,s)}},168:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({log1p_:function(t){const e=Object(s.a)(t,"x","log1p"),n={x:e};return a.a.runKernelFunc(((t,n)=>{const a=t.log1p(e);return n([e]),a}),n,null,r.xb)}})},175:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({floor_:function(t){const e=Object(s.a)(t,"x","floor"),n={x:e};return a.a.runKernelFunc((t=>t.floor(e)),n,null,r.bb)}})},188:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(3),r=n(77),s=n(9),c=n(4),o=n(14);const u=Object(c.a)({leakyRelu_:function(t,e=.2){const n=Object(a.a)(t,"x","leakyRelu");return Object(r.a)(Object(s.a)(Object(o.a)(e),n),n)}})},189:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(4),u=n(7);const i=Object(o.a)({localResponseNormalization_:function(t,e=5,n=1,o=1,i=.5){const b=Object(s.a)(t,"x","localResponseNormalization");c.assert(4===b.rank||3===b.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${b.rank}.`)),c.assert(c.isInt(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let l=b,O=!1;3===b.rank&&(O=!0,l=Object(u.a)(b,[1,b.shape[0],b.shape[1],b.shape[2]]));const p={x:l},j={depthRadius:e,bias:n,alpha:o,beta:i},h=a.a.runKernelFunc(((t,a)=>{const r=t.localResponseNormalization4D(l,e,n,o,i);return a([l,r]),r}),p,null,r.rb,j);return O?Object(u.a)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}})},191:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(3),r=n(11),s=n(58),c=n(94),o=n(128),u=n(4);const i=Object(u.a)({logicalXor_:function(t,e){const n=Object(a.a)(t,"a","logicalXor","bool"),u=Object(a.a)(e,"b","logicalXor","bool");return Object(r.a)(n.shape,u.shape),Object(s.a)(Object(o.a)(t,e),Object(c.a)(Object(s.a)(t,e)))}})},201:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(4),u=n(7);const i=Object(o.a)({resizeNearestNeighbor_:function(t,e,n=!1){const o=Object(s.a)(t,"images","resizeNearestNeighbor");c.assert(3===o.rank||4===o.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`)),c.assert(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),c.assert("float32"===o.dtype||"int32"===o.dtype,(()=>"`images` must have `int32` or `float32` as dtype"));let i=o,b=!1;3===o.rank&&(b=!0,i=Object(u.a)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const[l,O]=e,p={images:i},j={alignCorners:n,size:e},h=a.a.runKernelFunc(((t,e)=>(e([i]),t.resizeNearestNeighbor(i,l,O,n))),p,null,r.hc,j);return b?Object(u.a)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}})},202:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(4),u=n(7);const i=Object(o.a)({resizeBilinear_:function(t,e,n=!1){const o=Object(s.a)(t,"images","resizeBilinear");c.assert(3===o.rank||4===o.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`)),c.assert(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`));let i=o,b=!1;3===o.rank&&(b=!0,i=Object(u.a)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const[l,O]=e,p={images:i},j={alignCorners:n,size:e},h=a.a.runKernelFunc(((t,e)=>(e([i]),t.resizeBilinear(i,l,O,n))),p,null,r.fc,j);return b?Object(u.a)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}})},24:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(0),u=n(4),i=n(7);const b=Object(u.a)({matMul_:function(t,e,n=!1,u=!1){let b=Object(c.a)(t,"a","matMul"),l=Object(c.a)(e,"b","matMul");[b,l]=Object(s.b)(b,l),o.assert(b.rank>=2&&l.rank>=2&&b.rank===l.rank,(()=>`Error in matMul: inputs must have the same rank of at least 2, got ranks ${b.rank} and ${l.rank}.`));const O=n?b.shape[b.rank-2]:b.shape[b.rank-1],p=u?l.shape[l.rank-1]:l.shape[l.rank-2],j=n?b.shape[b.rank-1]:b.shape[b.rank-2],h=u?l.shape[l.rank-2]:l.shape[l.rank-1],d=b.shape.slice(0,-2),f=l.shape.slice(0,-2),m=o.sizeFromShape(d),g=o.sizeFromShape(f);o.assert(o.arraysEqual(d,f),(()=>`Error in matMul: outer dimensions (${d}) and (${f}) of Tensors with shapes ${b.shape} and ${l.shape} must match.`)),o.assert(O===p,(()=>`Error in matMul: inner shapes (${O}) and (${p}) of Tensors with shapes ${b.shape} and ${l.shape} and transposeA=${n} and transposeB=${u} must match.`));const k=b.shape.slice(0,-2).concat([j,h]),E=n?Object(i.a)(b,[m,O,j]):Object(i.a)(b,[m,j,O]),x=u?Object(i.a)(l,[g,h,p]):Object(i.a)(l,[g,p,h]),v={a:E,b:x},S={transposeA:n,transposeB:u},$=a.a.runKernelFunc(((t,e)=>(e([E,x]),t.batchMatMul(E,x,n,u))),v,null,r.s,S);return Object(i.a)($,k)}})},25:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({neg_:function(t){const e=Object(s.a)(t,"x","neg"),n={x:e};return a.a.runKernelFunc((t=>t.neg(e)),n,null,r.Ob)}})},288:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({isFinite_:function(t){const e=Object(s.a)(t,"x","isFinite"),n={x:e};return a.a.runKernelFunc((t=>t.isFinite(e)),n,null,r.ob)}})},289:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({isInf_:function(t){const e=Object(s.a)(t,"x","isInf"),n={x:e};return a.a.runKernelFunc((t=>t.isInf(e)),n,null,r.pb)}})},290:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({isNaN_:function(t){const e=Object(s.a)(t,"x","isNaN"),n={x:e};return a.a.runKernelFunc((t=>t.isNaN(e)),n,null,r.qb)}})},291:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(33),r=n(3),s=n(9),c=n(25),o=n(4),u=n(111),i=n(190);const b=Object(o.a)({logSigmoid_:function(t){const e=Object(r.a)(t,"x","logSigmoid");return Object(a.a)((t=>({value:Object(c.a)(Object(i.a)(Object(c.a)(t))),gradFunc:e=>Object(s.a)(e,Object(u.a)(Object(c.a)(t)))})))(e)}})},292:function(t,e,n){"use strict";n.d(e,"a",(function(){return p}));var a=n(5),r=n(2),s=n(3),c=n(10),o=n(39),u=n(69),i=n(64),b=n(4),l=n(15),O=n(12);const p=Object(b.a)({logSoftmax_:function(t,e=-1){const n=Object(s.a)(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);const b={logits:n},p={axis:e};return a.a.runKernelFunc(((n,a)=>{const r=Object(i.a)(t,e,!0),s=Object(l.a)(t,r),b=Object(l.a)(Object(c.a)(s,"float32"),Object(u.a)(Object(O.a)(Object(o.a)(s),e,!0)));return a([b]),b}),b,null,r.yb,p)}})},303:function(t,e,n){"use strict";n.r(e),n.d(e,"conv2d",(function(){return m})),n.d(e,"depthwiseConv2d",(function(){return x})),n.d(e,"matMul",(function(){return S}));var a=n(5),r=n(33),s=n(2),c=n(19),o=n(3),u=n(0),i=n(22),b=n(11),l=n(61),O=n(131),p=n(130),j=n(16),h=n(40),d=n(4),f=n(7);const m=Object(d.a)({fusedConv2d_:function({x:t,filter:e,strides:n,pad:d,dataFormat:m="NHWC",dilations:g=[1,1],dimRoundingMode:k,bias:E,activation:x="linear",preluActivationWeights:v}){if(x=x||"linear",!1===Object(h.d)(a.a.state.gradientDepth,x)){let a=Object(l.a)(t,e,n,d,m,g,k);return null!=E&&(a=Object(i.a)(a,E)),Object(h.a)(a,x,v)}const S=Object(o.a)(t,"x","conv2d"),$=Object(o.a)(e,"filter","conv2d");let _=S,N=!1;3===S.rank&&(N=!0,_=Object(f.a)(S,[1,S.shape[0],S.shape[1],S.shape[2]])),u.assert(4===_.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${_.rank}.`)),u.assert(4===$.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${$.rank}.`)),null!=k&&u.assert(u.isInt(d),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${k} but got pad ${d}.`)),u.assert(_.shape[3]===$.shape[2],(()=>`Error in conv2d: depth of input (${_.shape[3]}) must match input depth for filter ${$.shape[2]}.`)),u.assert(j.h(n,g),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${g}'`)),u.assert("NHWC"===m,(()=>`Error in conv2d: got dataFormat of ${m} but only NHWC is currently supported.`));const w=j.a(_.shape,$.shape,n,g,d,k);let M,F;null!=E&&(M=Object(o.a)(E,"bias","fused conv2d"),[M]=Object(c.b)(M,S),b.a(w.outShape,M.shape)),null!=v&&(F=Object(o.a)(v,"prelu weights","fused conv2d"));const y=(t,e)=>{const[a,r,s,c]=e,o=Object(h.c)(t,s,x);u.assert(j.i(g),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${g}'`));const i=[Object(p.a)(r.shape,o,a,n,d),Object(O.a)(r,o,a.shape,n,d)];if(null!=c){const t=Object(h.b)(c,o);i.push(t)}return i},I=t=>t.fusedConv2d({input:_,filter:$,convInfo:w,bias:M,activation:x,preluActivationWeights:F}),z={x:_,filter:$,bias:M,preluActivationWeights:F},A={strides:n,pad:d,dataFormat:m,dilations:g,dimRoundingMode:k,activation:x};if(null==E){return Object(r.a)(((t,e,n)=>{let r=a.a.runKernelFunc(I,z,null,s.fb,A);return n([e,t,r]),N&&(r=Object(f.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(_,$)}return Object(r.a)(((t,e,n,r)=>{let c=a.a.runKernelFunc(I,z,null,s.fb,A);return r([e,t,c,n]),N&&(c=Object(f.a)(c,[c.shape[1],c.shape[2],c.shape[3]])),{value:c,gradFunc:y}}))(_,$,M)}});var g=n(75),k=n(204),E=n(203);const x=Object(d.a)({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:l,dataFormat:O="NHWC",dilations:p=[1,1],dimRoundingMode:d,bias:m,activation:x="linear",preluActivationWeights:v}){if(!1===Object(h.d)(a.a.state.gradientDepth,x)){let a=Object(g.a)(t,e,n,l,O,p,d);return null!=m&&(a=Object(i.a)(a,m)),Object(h.a)(a,x,v)}const S=Object(o.a)(t,"x","depthwiseConv2d"),$=Object(o.a)(e,"filter","depthwiseConv2d");let _=S,N=!1;3===S.rank&&(N=!0,_=Object(f.a)(S,[1,S.shape[0],S.shape[1],S.shape[2]])),u.assert(4===_.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${_.rank}.`)),u.assert(4===$.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$.rank}.`)),u.assert(_.shape[3]===$.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${_.shape[3]}) must match the inChannels dimension in filter ${$.shape[2]}.`)),null==p&&(p=[1,1]),u.assert(j.h(n,p),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${p}'`)),null!=d&&u.assert(u.isInt(l),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${d} but got pad ${l}.`));const w=j.a(_.shape,$.shape,n,p,l,d,!0);let M,F;null!=m&&(M=Object(o.a)(m,"bias","fused conv2d"),[M]=Object(c.b)(M,S),b.a(w.outShape,M.shape)),null!=v&&(F=Object(o.a)(v,"prelu weights","fused depthwiseConv2d"));const y=(t,e)=>{u.assert(j.i(p),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${p}'`));const[n,a,r,s]=e,c=Object(h.c)(t,r,x),o=Object(E.a)(a.shape,c,n,w),i=Object(k.a)(a,c,n.shape,w);if(null!=s){return[o,i,Object(h.b)(M,c)]}return[o,i]},I=t=>t.fusedDepthwiseConv2D({input:_,filter:$,convInfo:w,bias:M,activation:x,preluActivationWeights:F}),z={x:_,filter:$,bias:M,preluActivationWeights:F},A={strides:n,pad:l,dataFormat:O,dilations:p,dimRoundingMode:d,activation:x};if(null==m){return Object(r.a)(((t,e,n)=>{let r=a.a.runKernelFunc(I,z,null,s.gb,A);return n([e,t,r]),N&&(r=Object(f.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(_,$)}return Object(r.a)(((t,e,n,r)=>{let c=a.a.runKernelFunc(I,z,null,s.gb,A);return r([e,t,c,n]),N&&(c=Object(f.a)(c,[c.shape[1],c.shape[2],c.shape[3]])),{value:c,gradFunc:y}}))(_,$,M)}});var v=n(24);const S=Object(d.a)({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:l=!1,bias:O,activation:p="linear",preluActivationWeights:j}){if(!1===Object(h.d)(a.a.state.gradientDepth,p)){let a=Object(v.a)(t,e,n,l);return null!=O&&(a=Object(i.a)(a,O)),Object(h.a)(a,p,j)}let d=Object(o.a)(t,"a","fused matMul"),m=Object(o.a)(e,"b","fused matMul");[d,m]=Object(c.b)(d,m);const g=n?d.shape[d.rank-2]:d.shape[d.rank-1],k=l?m.shape[m.rank-1]:m.shape[m.rank-2],E=n?d.shape[d.rank-1]:d.shape[d.rank-2],x=l?m.shape[m.rank-2]:m.shape[m.rank-1],S=d.shape.slice(0,-2),$=m.shape.slice(0,-2),_=u.sizeFromShape(S),N=u.sizeFromShape($);u.assert(d.rank>=2&&m.rank>=2&&d.rank===m.rank,(()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${d.rank} and ${m.rank}.`)),u.assert(u.arraysEqual(S,$),(()=>`Error in fused matMul: outer dimensions (${S}) and (${$}) of Tensors with shapes ${d.shape} and ${m.shape} must match.`)),u.assert(g===k,(()=>`Error in fused matMul: inner shapes (${g}) and (${k}) of Tensors with shapes ${d.shape} and ${m.shape} and transposeA=${n} and transposeB=${l} must match.`));const w=d.shape.slice(0,-2).concat([E,x]),M=n?Object(f.a)(d,[_,g,E]):Object(f.a)(d,[_,E,g]),F=l?Object(f.a)(m,[N,x,k]):Object(f.a)(m,[N,k,x]);let y,I;null!=O&&(y=Object(o.a)(O,"bias","fused matMul"),[y]=Object(c.b)(y,d),b.a(w,y.shape)),null!=j&&(I=Object(o.a)(j,"prelu weights","fused matMul"));const z=(t,e)=>{const[a,r,s,c]=e,o=Object(h.c)(Object(f.a)(t,s.shape),s,p);let u,i;if(n||l?!n&&l?(u=Object(v.a)(o,r,!1,!1),i=Object(v.a)(o,a,!0,!1)):n&&!l?(u=Object(v.a)(r,o,!1,!0),i=Object(v.a)(a,o,!1,!1)):(u=Object(v.a)(r,o,!0,!0),i=Object(v.a)(o,a,!0,!0)):(u=Object(v.a)(o,r,!1,!0),i=Object(v.a)(a,o,!0,!1)),null!=O){return[u,i,Object(h.b)(c,o)]}return[u,i]},A=t=>t.fusedBatchMatMul({a:M,b:F,transposeA:n,transposeB:l,bias:y,activation:p,preluActivationWeights:I}),R={a:M,b:F,bias:y,preluActivationWeights:I},T={transposeA:n,transposeB:l,activation:p};if(null==O){return Object(r.a)(((t,e,n)=>{const r=a.a.runKernelFunc(A,R,null,s.Pc,T);return n([t,e,r]),{value:Object(f.a)(r,w),gradFunc:z}}))(M,F)}return Object(r.a)(((t,e,n,r)=>{const c=a.a.runKernelFunc(A,R,null,s.Pc,T);return r([t,e,c,n]),{value:Object(f.a)(c,w),gradFunc:z}}))(M,F,y)}})},305:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({flipLeftRight_:function(t){const e=Object(s.a)(t,"image","flipLeftRight","float32");c.assert(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const n={image:e};return a.a.runKernel(r.ab,n,{})}})},306:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({rotateWithOffset_:function(t,e,n=0,o=.5){const u=Object(s.a)(t,"image","rotateWithOffset","float32");c.assert(4===u.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${u.rank}.`));const i={image:u},b={radians:e,fillValue:n,center:o};return a.a.runKernel(r.kc,i,b)}})},307:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(4);const u=Object(o.a)({cropAndResize_:function(t,e,n,o,u,i){const b=Object(s.a)(t,"image","cropAndResize"),l=Object(s.a)(e,"boxes","cropAndResize","float32"),O=Object(s.a)(n,"boxInd","cropAndResize","int32");u=u||"bilinear",i=i||0;const p=l.shape[0];c.assert(4===b.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${b.rank}.`)),c.assert(2===l.rank&&4===l.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${l.shape}.`)),c.assert(1===O.rank&&O.shape[0]===p,(()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${l.shape}.`)),c.assert(2===o.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${o.length}.`)),c.assert(o[0]>=1&&o[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${o}`)),c.assert("bilinear"===u||"nearest"===u,(()=>`method must be bilinear or nearest, but was ${u}`));const j={image:b,boxes:l,boxInd:O},h={method:u,extrapolationValue:i,cropSize:o};return a.a.runKernelFunc((t=>t.cropAndResize(b,l,O,o,u,i)),j,null,r.I,h)}})},308:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(63),o=n(4);const u=Object(o.a)({nonMaxSuppression_:function(t,e,n,o=.5,u=Number.NEGATIVE_INFINITY){const i=Object(s.a)(t,"boxes","nonMaxSuppression"),b=Object(s.a)(e,"scores","nonMaxSuppression"),l=Object(c.a)(i,b,n,o,u);n=l.maxOutputSize,o=l.iouThreshold,u=l.scoreThreshold;const O={maxOutputSize:n,iouThreshold:o,scoreThreshold:u};return a.a.runKernelFunc((t=>t.nonMaxSuppression(i,b,n,o,u)),{boxes:i,scores:b},null,r.Pb,O)}})},309:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var a=n(132),r=n(3),s=n(63);const c=async function(t,e,n,c=.5,o=Number.NEGATIVE_INFINITY){const u=Object(r.a)(t,"boxes","nonMaxSuppressionAsync"),i=Object(r.a)(e,"scores","nonMaxSuppressionAsync"),b=Object(s.a)(u,i,n,c,o);n=b.maxOutputSize,c=b.iouThreshold,o=b.scoreThreshold;const l=await Promise.all([u.data(),i.data()]),O=l[0],p=l[1],j=Object(a.a)(O,p,n,c,o);return u!==t&&u.dispose(),i!==e&&i.dispose(),j}},31:function(t,e,n){"use strict";var a;n.d(e,"a",(function(){return a})),function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(a||(a={}))},310:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(63),o=n(4);const u=Object(o.a)({nonMaxSuppressionWithScore_:function(t,e,n,o=.5,u=Number.NEGATIVE_INFINITY,i=0){const b=Object(s.a)(t,"boxes","nonMaxSuppression"),l=Object(s.a)(e,"scores","nonMaxSuppression"),O=Object(c.a)(b,l,n,o,u,i),p={boxes:b,scores:l},j={maxOutputSize:n=O.maxOutputSize,iouThreshold:o=O.iouThreshold,scoreThreshold:u=O.scoreThreshold,softNmsSigma:i=O.softNmsSigma},h=a.a.runKernel(r.Rb,p,j);return{selectedIndices:h[0],selectedScores:h[1]}}})},311:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var a=n(132),r=n(3),s=n(63);const c=async function(t,e,n,c=.5,o=Number.NEGATIVE_INFINITY,u=0){const i=Object(r.a)(t,"boxes","nonMaxSuppressionAsync"),b=Object(r.a)(e,"scores","nonMaxSuppressionAsync"),l=Object(s.a)(i,b,n,c,o,u);n=l.maxOutputSize,c=l.iouThreshold,o=l.scoreThreshold,u=l.softNmsSigma;const O=await Promise.all([i.data(),b.data()]),p=O[0],j=O[1],h=Object(a.c)(p,j,n,c,o,u);return i!==t&&i.dispose(),b!==e&&b.dispose(),h}},312:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(63),o=n(4);const u=Object(o.a)({nonMaxSuppressionPadded_:function(t,e,n,o=.5,u=Number.NEGATIVE_INFINITY,i=!1){const b=Object(s.a)(t,"boxes","nonMaxSuppression"),l=Object(s.a)(e,"scores","nonMaxSuppression"),O=Object(c.a)(b,l,n,o,u,null),p={boxes:b,scores:l},j={maxOutputSize:O.maxOutputSize,iouThreshold:O.iouThreshold,scoreThreshold:O.scoreThreshold,padToMaxOutputSize:i},h=a.a.runKernel(r.Qb,p,j);return{selectedIndices:h[0],validOutputs:h[1]}}})},313:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var a=n(132),r=n(3),s=n(63);const c=async function(t,e,n,c=.5,o=Number.NEGATIVE_INFINITY,u=!1){const i=Object(r.a)(t,"boxes","nonMaxSuppressionAsync"),b=Object(r.a)(e,"scores","nonMaxSuppressionAsync"),l=Object(s.a)(i,b,n,c,o,null),O=l.maxOutputSize,p=l.iouThreshold,j=l.scoreThreshold,[h,d]=await Promise.all([i.data(),b.data()]),f=Object(a.b)(h,d,O,p,j,u);return i!==t&&i.dispose(),b!==e&&b.dispose(),f}},314:function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var a=n(3),r=n(0),s=n(54),c=n(53),o=n(58),u=n(4),i=n(146),b=n(7),l=n(14),O=n(57),p=n(15),j=n(87),h=n(34),d=n(52);const f=Object(u.a)({bandPart_:function(t,e,n){Object(r.assert)(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),Object(r.assert)(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const u=Object(a.a)(t,"a","bandPart");Object(r.assert)(u.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${u.rank}.`));const f=u.shape,[m,g]=u.shape.slice(-2);if(!(e<=m))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${m}).`);if(!(n<=g))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${g}).`);e<0&&(e=m),n<0&&(n=g);const k=Object(b.a)(Object(i.a)(0,m,1,"int32"),[-1,1]),E=Object(i.a)(0,g,1,"int32"),x=Object(p.a)(k,E),v=Object(o.a)(Object(c.a)(x,Object(l.a)(+e,"int32")),Object(s.a)(x,Object(l.a)(-n,"int32"))),S=Object(d.a)([m,g],u.dtype);return Object(b.a)(Object(O.a)(Object(j.a)(Object(b.a)(u,[-1,m,g])).map((t=>Object(h.a)(v,t,S)))),f)}})},315:function(t,e,n){"use strict";n.d(e,"a",(function(){return j}));var a=n(5),r=n(0),s=n(17),c=n(9),o=n(115),u=n(4),i=n(68),b=n(114),l=n(57),O=n(15),p=n(12);const j=Object(u.a)({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Object(r.assert)(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)Object(r.assert)(t[e].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`))}else e=!0,t=Object(i.a)(t,t.shape[0],0).map((t=>Object(b.a)(t,[0])));Object(r.assert)(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],u=t;for(let e=0;e<t.length;++e)n.push(a.a.tidy((()=>{let t=u[e];if(e>0)for(let a=0;a<e;++a){const e=Object(c.a)(Object(p.a)(Object(c.a)(n[a],t)),n[a]);t=Object(O.a)(t,e)}return Object(s.a)(t,Object(o.a)(t,"euclidean"))})));return e?Object(l.a)(n,0):n}})},316:function(t,e,n){"use strict";n.d(e,"a",(function(){return $}));var a=n(5),r=n(29),s=n(0),c=n(62),o=n(30),u=n(17),i=n(167),b=n(43),l=n(24),O=n(9),p=n(25),j=n(115),h=n(4),d=n(7),f=n(28),m=n(57),g=n(15),k=n(97),E=n(23),x=n(87),v=n(34);function S(t,e=!1){return a.a.tidy((()=>{Object(s.assert)(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],h=t.shape[1];let d=Object(i.a)(n),m=Object(c.a)(t);const x=Object(k.a)([[1]],[1,1]);let S=Object(c.a)(x);const $=n>=h?h:n;for(let t=0;t<$;++t){const e=m,s=S,i=d;[S,m,d]=a.a.tidy((()=>{const e=Object(f.a)(m,[t,t],[n-t,1]),a=Object(j.a)(e),r=Object(f.a)(m,[t,t],[1,1]),s=Object(v.a)(Object(b.a)(r,0),Object(k.a)([[-1]]),Object(k.a)([[1]])),i=Object(g.a)(r,Object(O.a)(s,a)),$=Object(u.a)(e,i);S=1===$.shape[0]?Object(c.a)(x):Object(o.a)([x,Object(f.a)($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const _=Object(p.a)(Object(u.a)(Object(l.a)(s,i),a)),N=Object(f.a)(m,[t,0],[n-t,h]),w=Object(O.a)(_,S),M=Object(E.a)(S);if(0===t)m=Object(g.a)(N,Object(l.a)(w,Object(l.a)(M,N)));else{const e=Object(g.a)(N,Object(l.a)(w,Object(l.a)(M,N)));m=Object(o.a)([Object(f.a)(m,[0,0],[t,h]),e],0)}const F=Object(E.a)(w),y=Object(f.a)(d,[0,t],[n,d.shape[1]-t]);if(0===t)d=Object(g.a)(y,Object(l.a)(Object(l.a)(y,S),F));else{const e=Object(g.a)(y,Object(l.a)(Object(l.a)(y,S),F));d=Object(o.a)([Object(f.a)(d,[0,0],[n,t]),e],1)}return[S,m,d]})),Object(r.b)([e,s,i])}return!e&&n>h&&(d=Object(f.a)(d,[0,0],[n,h]),m=Object(f.a)(m,[0,0],[h,h])),[d,m]}))}const $=Object(h.a)({qr_:function(t,e=!1){if(Object(s.assert)(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return S(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),a=Object(x.a)(Object(d.a)(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],s=[];a.forEach((t=>{const[n,a]=S(t,e);r.push(n),s.push(a)}));return[Object(d.a)(Object(m.a)(r,0),t.shape),Object(d.a)(Object(m.a)(s,0),t.shape)]}}})},317:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(3),r=n(0),s=n(42),c=n(31),o=n(4),u=n(15),i=n(41);const b=Object(o.a)({absoluteDifference_:function(t,e,n,o=c.a.SUM_BY_NONZERO_WEIGHTS){const b=Object(a.a)(t,"labels","absoluteDifference"),l=Object(a.a)(e,"predictions","absoluteDifference");let O=null;null!=n&&(O=Object(a.a)(n,"weights","absoluteDifference")),Object(r.assertShapesMatch)(b.shape,l.shape,"Error in absoluteDifference: ");const p=Object(s.a)(Object(u.a)(b,l));return Object(i.a)(p,O,o)}})},318:function(t,e,n){"use strict";n.d(e,"a",(function(){return O}));var a=n(3),r=n(0),s=n(31),c=n(9),o=n(4),u=n(14),i=n(15),b=n(12),l=n(41);const O=Object(o.a)({cosineDistance_:function(t,e,n,o,O=s.a.SUM_BY_NONZERO_WEIGHTS){const p=Object(a.a)(t,"labels","cosineDistance"),j=Object(a.a)(e,"predictions","cosineDistance");let h=null;null!=o&&(h=Object(a.a)(o,"weights","cosineDistance")),Object(r.assertShapesMatch)(p.shape,j.shape,"Error in cosineDistance: ");const d=Object(u.a)(1),f=Object(i.a)(d,Object(b.a)(Object(c.a)(p,j),n,!0));return Object(l.a)(f,h,O)}})},319:function(t,e,n){"use strict";n.d(e,"a",(function(){return O}));var a=n(3),r=n(0),s=n(31),c=n(9),o=n(4),u=n(73),i=n(14),b=n(15),l=n(41);const O=Object(o.a)({hingeLoss_:function(t,e,n,o=s.a.SUM_BY_NONZERO_WEIGHTS){let O=Object(a.a)(t,"labels","hingeLoss");const p=Object(a.a)(e,"predictions","hingeLoss");let j=null;null!=n&&(j=Object(a.a)(n,"weights","hingeLoss")),Object(r.assertShapesMatch)(O.shape,p.shape,"Error in hingeLoss: ");const h=Object(i.a)(1);O=Object(b.a)(Object(c.a)(Object(i.a)(2),O),h);const d=Object(u.a)(Object(b.a)(h,Object(c.a)(O,p)));return Object(l.a)(d,j,o)}})},320:function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var a=n(3),r=n(0),s=n(42),c=n(22),o=n(31),u=n(90),i=n(9),b=n(4),l=n(14),O=n(27),p=n(15),j=n(41);const h=Object(b.a)({huberLoss_:function(t,e,n,b=1,h=o.a.SUM_BY_NONZERO_WEIGHTS){const d=Object(a.a)(t,"labels","huberLoss"),f=Object(a.a)(e,"predictions","huberLoss");let m=null;null!=n&&(m=Object(a.a)(n,"weights","huberLoss")),Object(r.assertShapesMatch)(d.shape,f.shape,"Error in huberLoss: ");const g=Object(l.a)(b),k=Object(s.a)(Object(p.a)(f,d)),E=Object(u.a)(k,g),x=Object(p.a)(k,E),v=Object(c.a)(Object(i.a)(Object(l.a)(.5),Object(O.a)(E)),Object(i.a)(g,x));return Object(j.a)(v,m,h)}})},321:function(t,e,n){"use strict";n.d(e,"a",(function(){return j}));var a=n(3),r=n(0),s=n(22),c=n(69),o=n(31),u=n(9),i=n(25),b=n(4),l=n(14),O=n(15),p=n(41);const j=Object(b.a)({logLoss_:function(t,e,n,b=1e-7,j=o.a.SUM_BY_NONZERO_WEIGHTS){const h=Object(a.a)(t,"labels","logLoss"),d=Object(a.a)(e,"predictions","logLoss");let f=null;null!=n&&(f=Object(a.a)(n,"weights","logLoss")),Object(r.assertShapesMatch)(h.shape,d.shape,"Error in logLoss: ");const m=Object(l.a)(1),g=Object(l.a)(b),k=Object(i.a)(Object(u.a)(h,Object(c.a)(Object(s.a)(d,g)))),E=Object(u.a)(Object(O.a)(m,h),Object(c.a)(Object(s.a)(Object(O.a)(m,d),g))),x=Object(O.a)(k,E);return Object(p.a)(x,f,j)}})},322:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(3),r=n(0),s=n(31),c=n(4),o=n(91),u=n(41);const i=Object(c.a)({meanSquaredError_:function(t,e,n,c=s.a.SUM_BY_NONZERO_WEIGHTS){const i=Object(a.a)(t,"labels","meanSquaredError"),b=Object(a.a)(e,"predictions","meanSquaredError");let l=null;null!=n&&(l=Object(a.a)(n,"weights","meanSquaredError")),Object(r.assertShapesMatch)(i.shape,b.shape,"Error in meanSquaredError: ");const O=Object(o.a)(i,b);return Object(u.a)(O,l,c)}})},323:function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var a=n(3),r=n(0),s=n(42),c=n(22),o=n(39),u=n(168),i=n(31),b=n(9),l=n(25),O=n(4),p=n(73),j=n(14),h=n(15),d=n(41);const f=Object(O.a)({sigmoidCrossEntropy_:function(t,e,n,O=0,f=i.a.SUM_BY_NONZERO_WEIGHTS){let m=Object(a.a)(t,"multiClassLabels","sigmoidCrossEntropy");const g=Object(a.a)(e,"logits","sigmoidCrossEntropy");let k=null;if(null!=n&&(k=Object(a.a)(n,"weights","sigmoidCrossEntropy")),Object(r.assertShapesMatch)(m.shape,g.shape,"Error in sigmoidCrossEntropy: "),O>0){const t=Object(j.a)(O),e=Object(j.a)(1),n=Object(j.a)(.5);m=Object(c.a)(Object(b.a)(m,Object(h.a)(e,t)),Object(b.a)(n,t))}const E=function(t,e){const n=Object(a.a)(t,"labels","sigmoidCrossEntropyWithLogits"),i=Object(a.a)(e,"logits","sigmoidCrossEntropyWithLogits");Object(r.assertShapesMatch)(n.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: ");const O=Object(p.a)(i),j=Object(b.a)(i,n),d=Object(u.a)(Object(o.a)(Object(l.a)(Object(s.a)(i))));return Object(c.a)(Object(h.a)(O,j),d)}(m,g);return Object(d.a)(E,k,f)}})},324:function(t,e,n){"use strict";n.d(e,"a",(function(){return E}));var a=n(33),r=n(3),s=n(0),c=n(22),o=n(18),u=n(10),i=n(17),b=n(39),l=n(117),O=n(31),p=n(9),j=n(25),h=n(4),d=n(7),f=n(14),m=n(15),g=n(12),k=n(41);const E=Object(h.a)({softmaxCrossEntropy_:function(t,e,n,h=0,E=O.a.SUM_BY_NONZERO_WEIGHTS){let x=Object(r.a)(t,"onehotLabels","softmaxCrossEntropy");const v=Object(r.a)(e,"logits","softmaxCrossEntropy");let S=null;if(null!=n&&(S=Object(r.a)(n,"weights","softmaxCrossEntropy")),Object(s.assertShapesMatch)(x.shape,v.shape,"Error in softmaxCrossEntropy: "),h>0){const t=Object(f.a)(h),e=Object(f.a)(1),n=Object(f.a)(x.shape[1]);x=Object(c.a)(Object(p.a)(x,Object(m.a)(e,t)),Object(i.a)(t,n))}const $=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Object(a.a)(((t,e,a)=>{const r=Object(l.a)(e,[n],!0),s=Object(m.a)(Object(u.a)(e,"float32"),r);a([t,s]);const c=Object(j.a)(Object(p.a)(s,t));return{value:Object(g.a)(c,[n]),gradFunc:(t,e)=>{const[a,r]=e,s=Object(o.e)(t.shape,[n]);return[Object(p.a)(Object(d.a)(t,s),Object(m.a)(Object(u.a)(a,"float32"),Object(b.a)(r))),Object(p.a)(Object(d.a)(t,s),Object(m.a)(Object(b.a)(r),Object(u.a)(a,"float32")))]}}}))(t,e)}(x,v);return Object(k.a)($,S,E)}})},376:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var a=n(5),r=n(2),s=n(4);const c=Object(s.a)({localResponseNormalizationBackprop_:function(t,e,n,s=5,c=1,o=1,u=.5){const i={x:t,y:e,dy:n},b={depthRadius:s,bias:c,alpha:o,beta:u};return a.a.runKernelFunc((a=>a.LRNGrad(n,t,e,s,c,o,u)),i,null,r.sb,b)}})},379:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(16),u=n(4),i=n(7);const b=Object(u.a)({maxPool3dBackprop_:function(t,e,n,u,b,l=[1,1,1],O,p){const j=Object(s.a)(t,"dy","maxPool3dBackprop"),h=Object(s.a)(e,"input","maxPool3dBackprop"),d=Object(s.a)(n,"output","maxPool3dBackprop");let f=j,m=h,g=d,k=!1;4===h.rank&&(k=!0,f=Object(i.a)(j,[1,j.shape[0],j.shape[1],j.shape[2],j.shape[3]]),m=Object(i.a)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),g=Object(i.a)(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),c.assert(5===f.rank,(()=>`Error in maxPool3dBackprop: dy must be rank 5 but got rank ${f.rank}.`)),c.assert(5===m.rank,(()=>`Error in maxPool3dBackprop: input must be rank 5 but got rank ${m.rank}.`)),c.assert(5===g.rank,(()=>`Error in maxPool3dBackprop: output must be rank 5 but got rank ${g.rank}.`)),c.assert(o.h(b,l),(()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${b} and dilations '${l}'`)),null!=p&&c.assert(c.isInt(O),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${p} but got pad ${O}.`));const E={dy:f,input:m,output:g},x={filterSize:u,strides:b,dilations:l,pad:O,dimRoundingMode:p},v=a.a.runKernelFunc((t=>{const e=o.f(m.shape,u,b,l,O,p);return t.maxPool3dBackprop(f,m,g,e)}),E,null,r.Fb,x);return k?Object(i.a)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}})},381:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(16),u=n(4);const i=Object(u.a)({maxPoolBackprop_:function(t,e,n,u,i,b,l){const O=Object(s.a)(t,"dy","maxPoolBackprop"),p=Object(s.a)(e,"input","maxPoolBackprop"),j=Object(s.a)(n,"output","maxPoolBackprop");c.assert(p.rank===O.rank,(()=>`Rank of input (${p.rank}) does not match rank of dy (${O.rank})`)),c.assert(4===O.rank,(()=>`Error in maxPoolBackprop: dy must be rank 4 but got rank ${O.rank}.`)),c.assert(4===p.rank,(()=>`Error in maxPoolBackprop: input must be rank 4 but got rank ${p.rank}.`)),null!=l&&c.assert(c.isInt(b),(()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${l} but got pad ${b}.`));const h={dy:O,input:p,output:j},d={filterSize:u,strides:i,pad:b,dimRoundingMode:l};return a.a.runKernelFunc((t=>{const e=o.e(p.shape,u,i,1,b,l);return t.maxPoolBackprop(O,p,j,e)}),h,null,r.Gb,d)}})},40:function(t,e,n){"use strict";n.d(e,"c",(function(){return O})),n.d(e,"b",(function(){return p})),n.d(e,"a",(function(){return j})),n.d(e,"d",(function(){return h}));var a=n(11),r=n(118),s=n(9),c=n(120),o=n(73),u=n(119),i=n(7),b=n(74),l=n(12);function O(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return Object(s.a)(t,Object(b.a)(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function p(t,e){let n=e;const r=a.c(t.shape,e.shape);return r.length>0&&(n=Object(l.a)(n,r)),Object(i.a)(n,t.shape)}function j(t,e,n){if("linear"===e)return t;if("relu"===e)return Object(o.a)(t);if("elu"===e)return Object(r.a)(t);if("relu6"===e)return Object(u.a)(t);if("prelu"===e)return Object(c.a)(t,n);throw new Error(`Unknown fused activation ${e}.`)}const h=(t,e)=>!(t>0)||"linear"===e},41:function(t,e,n){"use strict";n.d(e,"a",(function(){return j}));var a=n(3),r=n(10),s=n(17),c=n(31),o=n(116),u=n(9),i=n(89),b=n(72),l=n(4),O=n(14),p=n(12);const j=Object(l.a)({computeWeightedLoss_:function(t,e,n=c.a.SUM_BY_NONZERO_WEIGHTS){const l=Object(a.a)(t,"losses","computeWeightedLoss");let j=null;null!=e&&(j=Object(a.a)(e,"weights","computeWeightedLoss"));const h=null==j?l:Object(u.a)(l,j);if(n===c.a.NONE)return h;if(n===c.a.SUM)return Object(p.a)(h);if(n===c.a.MEAN){if(null==j)return Object(o.a)(h);{const t=l.size/j.size,e=Object(s.a)(Object(p.a)(h),Object(p.a)(j));return t>1?Object(s.a)(e,Object(O.a)(t)):e}}if(n===c.a.SUM_BY_NONZERO_WEIGHTS){if(null==j)return Object(s.a)(Object(p.a)(h),Object(O.a)(l.size));{const t=Object(u.a)(j,Object(b.a)(l.shape)),e=Object(r.a)(Object(p.a)(Object(i.a)(t,Object(O.a)(0))),"float32");return Object(s.a)(Object(p.a)(h),e)}}throw Error(`Unknown reduction: ${n}`)}})},43:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(11),u=n(4);const i=Object(u.a)({greater_:function(t,e){let n=Object(c.a)(t,"a","greater"),u=Object(c.a)(e,"b","greater");[n,u]=Object(s.b)(n,u),Object(o.a)(n.shape,u.shape);const i={a:n,b:u};return a.a.runKernelFunc((t=>t.greater(n,u)),i,null,r.jb)}})},53:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(11),u=n(4);const i=Object(u.a)({lessEqual_:function(t,e){let n=Object(c.a)(t,"a","lessEqual"),u=Object(c.a)(e,"b","lessEqual");[n,u]=Object(s.b)(n,u),Object(o.a)(n.shape,u.shape);const i={a:n,b:u};return a.a.runKernelFunc(((t,e)=>{const a=t.lessEqual(n,u);return e([n,u]),a}),i,null,r.ub)}})},54:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(11),u=n(4);const i=Object(u.a)({greaterEqual_:function(t,e){let n=Object(c.a)(t,"a","greaterEqual"),u=Object(c.a)(e,"b","greaterEqual");[n,u]=Object(s.b)(n,u),Object(o.a)(n.shape,u.shape);const i={a:n,b:u};return a.a.runKernelFunc(((t,e)=>{const a=t.greaterEqual(n,u);return e([n,u]),a}),i,null,r.kb)}})},58:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(3),c=n(11),o=n(4);const u=Object(o.a)({logicalAnd_:function(t,e){const n=Object(s.a)(t,"a","logicalAnd","bool"),o=Object(s.a)(e,"b","logicalAnd","bool");Object(c.a)(n.shape,o.shape);const u={a:n,b:o};return a.a.runKernelFunc((t=>t.logicalAnd(n,o)),u,null,r.zb)}})},64:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var a=n(5),r=n(2),s=n(3),c=n(0),o=n(18),u=n(4),i=n(7),b=n(23);const l=Object(u.a)({max_:function(t,e=null,n=!1){const u=Object(s.a)(t,"x","max"),l={x:u},O={reductionIndices:e,keepDims:n};return a.a.runKernelFunc(((t,a)=>{let r=c.parseAxisParam(e,u.shape);const s=o.f(r,u.rank);let l=u;null!=s&&(l=Object(b.a)(u,s),r=o.g(r.length,l.rank));const O=t.max(l,r);null!=s&&l.dispose();let p=O;if(n){const t=o.e(p.shape,c.parseAxisParam(e,u.shape));p=Object(i.a)(p,t),O.dispose()}return a([u,p]),p}),l,null,r.Cb,O)}})},69:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({log_:function(t){const e=Object(s.a)(t,"x","log"),n={x:e};return a.a.runKernelFunc(((t,n)=>{const a=t.log(e);return n([e]),a}),n,null,r.wb)}})},77:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(11),u=n(10),i=n(4);const b=Object(i.a)({maximum_:function(t,e){let n=Object(c.a)(t,"a","maximum"),i=Object(c.a)(e,"b","maximum");[n,i]=Object(s.b)(n,i),"bool"===n.dtype&&(n=Object(u.a)(n,"int32"),i=Object(u.a)(i,"int32")),Object(o.a)(n.shape,i.shape);const b={a:n,b:i};return a.a.runKernelFunc(((t,e)=>{const a=t.maximum(n,i);return e([n,i]),a}),b,null,r.Ib)}})},88:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({imag_:function(t){const e=Object(s.a)(t,"input","imag"),n={input:e};return a.a.runKernelFunc((t=>t.imag(e)),n,null,r.nb)}})},9:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(4);const u=Object(o.a)({mul_:function(t,e){let n=Object(c.a)(t,"a","mul"),o=Object(c.a)(e,"b","mul");[n,o]=Object(s.b)(n,o);const u={a:n,b:o};return a.a.runKernelFunc(((t,e)=>{const a=t.multiply(n,o);return e([n,o]),a}),u,null,r.Nb)}})},90:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(11),u=n(10),i=n(4);const b=Object(i.a)({minimum_:function(t,e){let n=Object(c.a)(t,"a","minimum"),i=Object(c.a)(e,"b","minimum");[n,i]=Object(s.b)(n,i),"bool"===n.dtype&&(n=Object(u.a)(n,"int32"),i=Object(u.a)(i,"int32")),Object(o.a)(n.shape,i.shape);const b={a:n,b:i};return a.a.runKernelFunc(((t,e)=>{const a=t.minimum(n,i);return e([n,i]),a}),b,null,r.Lb)}})},93:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(5),r=n(2),s=n(19),c=n(3),o=n(11),u=n(4);const i=Object(u.a)({less_:function(t,e){let n=Object(c.a)(t,"a","less"),u=Object(c.a)(e,"b","less");[n,u]=Object(s.b)(n,u),Object(o.a)(n.shape,u.shape);const i={a:n,b:u};return a.a.runKernelFunc((t=>t.less(n,u)),i,null,r.tb)}})},94:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var a=n(5),r=n(2),s=n(3),c=n(4);const o=Object(c.a)({logicalNot_:function(t){const e=Object(s.a)(t,"x","logicalNot","bool"),n={x:e};return a.a.runKernelFunc((t=>t.logicalNot(e)),n,null,r.Ab)}})}}]);
//# sourceMappingURL=bundle~bundle~4b2d83a9.6ef3cb0b.js.map