/*! For license information please see bundle~bundle~748942c6.5037132a.js.LICENSE.txt */
(("undefined"!=typeof self?self:this).webpackJsonp=("undefined"!=typeof self?self:this).webpackJsonp||[]).push([[8],{143:function(e,t){},424:function(e,t,a){"use strict";t.a=a.p+"wasm/tfjs-backend-wasm.23f1afb1.wasm"},425:function(e,t,a){"use strict";t.a=a.p+"wasm/tfjs-backend-wasm-simd.6ceec37b.wasm"},426:function(e,t,a){"use strict";t.a=a.p+"wasm/tfjs-backend-wasm-threaded-simd.7a3d6568.wasm"},427:function(e,t,a){"use strict";a.d(t,"a",(function(){return Yt}));var n,r,s=a(1);let i;!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(n||(n={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid"}(r||(r={}));const d={kernelName:s.Qb,backendName:"wasm",setupFunc:function(e){i=e.wasm.cwrap(s.Qb,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{a:s,b:d,bias:u,preluActivationWeights:o}=t;if("float32"!==s.dtype||"float32"!==d.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:c,transposeB:p,activation:l,leakyreluAlpha:m}=n,b=a.dataIdMap.get(s.dataId).id,h=a.dataIdMap.get(d.dataId).id;let f=0;if(null!=u){const e=a.dataIdMap.get(u.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}const k=null==o?0:a.dataIdMap.get(o.dataId).id,g=r[l];if(null==g)throw new Error(`${l} activation not yet supported for FusedConv2D in the wasm backend.`);const w=c?s.shape[2]:s.shape[1],y=p?d.shape[1]:d.shape[2],I=s.shape[0],A=a.makeOutput([I,w,y],s.dtype),S=a.dataIdMap.get(A.dataId).id,M=new Uint8Array(new Int32Array(s.shape).buffer),x=new Uint8Array(new Int32Array(d.shape).buffer);return i(b,M,s.shape.length,h,x,d.shape.length,c,p,g,f,k,m||0,S),A}};function u(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(a){t=a.wasm.cwrap(e,null,["number","number"])},kernelFunc:function(e){const{backend:a,inputs:{x:n}}=e,r=a.dataIdMap.get(n.dataId).id,i=a.makeOutput(n.shape,n.dtype),d=a.dataIdMap.get(i.dataId).id;return 0===s.yc.sizeFromShape(i.shape)||t(r,d),i}}}const o=u(s.a);function c(e,t,a){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(i){const{backend:d,inputs:u}=i,{a:o,b:c}=u,p=d.dataIdMap.get(o.dataId).id,l=d.dataIdMap.get(c.dataId).id,m=null!=a?a:o.dtype,b=s.Sb.assertAndGetBroadcastShape(o.shape,c.shape),h=d.makeOutput(b,m);if(0===s.yc.sizeFromShape(b))return h;const f=new Uint8Array(new Int32Array(o.shape).buffer),k=new Uint8Array(new Int32Array(c.shape).buffer),g=d.dataIdMap.get(h.dataId).id,w=()=>r(p,f,o.shape.length,l,k,c.shape.length,n[o.dtype],g);if(t&&"float32"===o.dtype)return w(),h;const y=s.Sb.getBroadcastDims(o.shape,b),I=s.Sb.getBroadcastDims(c.shape,b),A=y.every(((e,t)=>e===t)),S=I.every(((e,t)=>e===t));if(A&&S)return w(),h;throw new Error(`Broadcasting along outer dims is not yet supported for ${o.dtype} ${e}.`)}}}const p=c(s.b,!0);let l;const m={kernelName:s.c,backendName:"wasm",setupFunc:function(e){l=e.wasm.cwrap(s.c,null,["array","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a}=e,r=a.makeOutput(t[0].shape,t[0].dtype);if(0===s.yc.sizeFromShape(r.shape))return r;const i=t.map((e=>a.dataIdMap.get(e.dataId).id)),d=new Uint8Array(new Int32Array(i).buffer),u=a.dataIdMap.get(r.dataId).id;return l(d,i.length,n[r.dtype],u),r}};function b(e){const{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype),r=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(n).set(r),n}const h={kernelName:s.I,backendName:"wasm",kernelFunc:b};let f;function k(e){const{inputs:t,backend:a,attrs:r}=e,[s,i]=function(e,t){const a=[],n=[];for(let r=0;r<e.length;++r)1!==e[r]&&a.push(e[r]),1!==e[t[r]]&&n.push(t[r]);for(let e=0;e<n.length;++e){let t=-1;for(let a=0;a<n.length;++a)n[a]>=e&&(-1===t||n[t]>n[a])&&(t=a);n[t]=e}return[a,n]}(t.x.shape,r.perm);let d=!0;for(let e=0;e<i.length;e++)i[e]!==e&&(d=!1);const u=function(e,t){const a=new Array(e.length);for(let n=0;n<a.length;n++)a[n]=e[t[n]];return a}(t.x.shape,r.perm),o={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(d){const e=b({inputs:t,backend:a});return e.shape=u,e}const c=a.makeOutput(u,o.dtype),p=a.dataIdMap.get(o.dataId).id,l=a.dataIdMap.get(c.dataId).id,m=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(o.shape).buffer);return f(p,h,o.shape.length,n[o.dtype],l,m,i.length),c}const g={kernelName:s.Nb,backendName:"wasm",kernelFunc:k,setupFunc:function(e){f=e.wasm.cwrap(s.Nb,null,["number","array","number","number","number","array","number"])}};function w(e,t,a){const n=e.shape,r=e.shape.length,i=s.yc.parseAxisParam(t,n);let d=i;const u=s.Sb.getAxesPermutation(d,r);let o=null,c=!1;if(null!=u){const t=new Array(r);for(let e=0;e<t.length;e++)t[e]=n[u[e]];d=s.Sb.getInnerMostAxes(d.length,r),o=k({inputs:{x:e},attrs:{perm:u},backend:a});const i=a.dataIdMap.get(e.dataId).id;a.dataIdMap.get(o.dataId).id!==i&&(c=!0)}return{transposed:o,originalAxes:i,axes:d,inputWasTransposed:c}}let y;const I={kernelName:s.d,backendName:"wasm",setupFunc:function(e){y=e.wasm.cwrap(s.d,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a;let u=t.dataIdMap.get(d.dataId).id,o=d;const{transposed:c,axes:p,originalAxes:l,inputWasTransposed:m}=w(d,r,t);if(m){o=c,u=t.dataIdMap.get(c.dataId).id}const b=o.shape.length;s.Sb.assertAxesAreInnerMostDims("all",p,b);const[h,f]=s.Sb.computeOutAndReduceShapes(o.shape,p),k=s.yc.sizeFromShape(f),g=t.makeOutput(h,d.dtype);if(0!==s.yc.sizeFromShape(o.shape)){const e=t.dataIdMap.get(g.dataId).id;y(u,k,e)}if(m&&t.disposeData(c.dataId),i){const e=s.Sb.expandShapeToKeepDim(g.shape,l);g.shape=e}return g}};let A;const S={kernelName:s.e,backendName:"wasm",setupFunc:function(e){A=e.wasm.cwrap(s.e,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a;let u=t.dataIdMap.get(d.dataId).id,o=d;const{transposed:c,axes:p,originalAxes:l,inputWasTransposed:m}=w(d,r,t);if(m){o=c,u=t.dataIdMap.get(c.dataId).id}const b=o.shape.length;s.Sb.assertAxesAreInnerMostDims("any",p,b);const[h,f]=s.Sb.computeOutAndReduceShapes(o.shape,p),k=s.yc.sizeFromShape(f),g=t.makeOutput(h,d.dtype);if(0!==s.yc.sizeFromShape(o.shape)){const e=t.dataIdMap.get(g.dataId).id;A(u,k,e)}if(m&&t.disposeData(c.dataId),i){const e=s.Sb.expandShapeToKeepDim(g.shape,l);g.shape=e}return g}};let M;const x={kernelName:s.f,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{axis:i}=r,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,inputWasTransposed:m}=w(d,i,t);if(m){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e)}const b=c.shape.slice(0,-1),h=t.makeOutput(b,"int32"),f=t.dataIdMap.get(h.dataId).id,k=s.yc.sizeFromShape(h.shape),g=c.shape[l[0]];return M(o,n[c.dtype],k,g,f),m&&t.disposeData(p.dataId),h},setupFunc:function(e){M=e.wasm.cwrap(s.f,null,["number","number","number","number","number"])}};let F;const N={kernelName:s.g,backendName:"wasm",setupFunc:function(e){F=e.wasm.cwrap(s.g,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,r=t.x,i=n.dataIdMap.get(r.dataId).id,{filterSize:d,strides:u,pad:o,dimRoundingMode:c}=a,p=s.Sb.computePool2DInfo(r.shape,d,u,1,o,c),l=p.filterHeight,m=p.filterWidth,b=p.padInfo.top,h=p.padInfo.right,f=p.padInfo.bottom,k=p.padInfo.left,g=p.strideHeight,w=p.strideWidth,y=p.inChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(1!==p.dilationWidth||1!==p.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);const I=n.makeOutput(p.outShape,"float32"),A=n.dataIdMap.get(I.dataId).id;return F(i,r.shape[0],r.shape[1],r.shape[2],l,m,b,h,f,k,g,w,y,A),I}};function v(e){const{inputs:t,attrs:a}=e,{x:n}=t,{shape:r}=a,i=s.yc.sizeFromShape(n.shape),d=s.yc.inferFromImplicitShape(r,i);return s.yc.assert(i===s.yc.sizeFromShape(d),(()=>`new shape: ${d}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(n.dataId),{dataId:n.dataId,shape:d,dtype:n.dtype}}const O={kernelName:s.nb,backendName:"wasm",kernelFunc:v};let C;const z={kernelName:s.h,backendName:"wasm",setupFunc:function(e){C=e.wasm.cwrap(s.h,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{a:r,b:i}=t,{transposeA:d,transposeB:u}=n;if("float32"!==r.dtype||"float32"!==i.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const o=r.shape.length,c=i.shape.length,p=d?r.shape[o-2]:r.shape[o-1],l=u?i.shape[c-1]:i.shape[c-2],m=d?r.shape[o-1]:r.shape[o-2],b=u?i.shape[c-2]:i.shape[c-1],h=r.shape.slice(0,-2),f=i.shape.slice(0,-2),k=s.yc.sizeFromShape(h),g=s.yc.sizeFromShape(f),w=k===g||1===k||1===g;s.yc.assert(o>=2&&c>=2&&w,(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${f}).`));const y=(k>g?r.shape.slice(0,-2):i.shape.slice(0,-2)).concat([m,b]);s.yc.assert(p===l,(()=>`Error in matMul: inner shapes (${p}) and (${l}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${d} and transposeB=${u} must match.`));const I=u?[g,b,l]:[g,l,b],A=v({inputs:{x:r},backend:a,attrs:{shape:d?[k,p,m]:[k,m,p]}}),S=v({inputs:{x:i},backend:a,attrs:{shape:I}}),M=a.dataIdMap.get(A.dataId).id,x=a.dataIdMap.get(S.dataId).id,F=d?A.shape[2]:A.shape[1],N=u?S.shape[1]:S.shape[2],O=Math.max(k,g),z=a.makeOutput([O,F,N],A.dtype),D=a.dataIdMap.get(z.dataId).id,T=new Uint8Array(new Int32Array(A.shape).buffer),U=new Uint8Array(new Int32Array(S.shape).buffer);return C(M,T,A.shape.length,x,U,S.shape.length,d,u,D),a.disposeData(A.dataId),a.disposeData(S.dataId),z.shape=y,z}};function D(e){const{inputs:{x:t},attrs:{dtype:a},backend:n}=e,r=n.makeOutput(t.shape,a),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}const T={kernelName:s.i,backendName:"wasm",kernelFunc:D},U=u(s.j);let W;const H={kernelName:s.k,backendName:"wasm",setupFunc:function(e){W=e.wasm.cwrap(s.k,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=n,d=a.dataIdMap.get(r.dataId).id,u=a.makeOutput(r.shape,r.dtype),o=a.dataIdMap.get(u.dataId).id;return W(d,s,i,o),u}};function E(e){const{inputs:t,backend:a}=e,n=s.yc.parseAxisParam(e.attrs.axis,t[0].shape)[0];let r=s.Sb.computeOutShape(t.map((e=>e.shape)),n);const i=t.filter((e=>s.yc.sizeFromShape(e.shape)>0));if(1===i.length)return b({inputs:{x:i[0]},backend:a});const d=a.makeOutput(r,t[0].dtype);if(0===s.yc.sizeFromShape(r))return d;const u=i.map((e=>e.shape));if(s.Sb.assertParamsConsistent(u,n),"string"===i[0].dtype){const e=i.map((e=>{const t=s.yc.sizeFromShape(e.shape.slice(n));return v({inputs:{x:e},backend:a,attrs:{shape:[-1,t]}})})),u=e.map((e=>({vals:a.readSync(e.dataId),shape:e.shape})));r=s.Sb.computeOutShape(e.map((e=>e.shape)),1);const o=1===e[0].shape[0],c=function(e,t,a,n){const r=s.yc.getArrayFromDType(a,s.yc.sizeFromShape(t));if(n&&"string"!==a){let t=0;e.forEach((e=>{const a=s.yc.sizeFromShape(e.shape);r.set(e.vals,t),t+=a}))}else{let n=0;e.forEach((e=>{const i="string"===a?s.Sb.fromUint8ToStringArray(e.vals):e.vals;let d=0;for(let a=0;a<e.shape[0];++a){const s=a*t[1]+n;for(let t=0;t<e.shape[1];++t)r[s+t]=i[d++]}n+=e.shape[1]}))}return r}(u,r,t[0].dtype,o),p=s.Sb.computeOutShape(i.map((e=>e.shape)),n);d.shape=p;return a.dataIdMap.get(d.dataId).stringBytes=s.Sb.fromStringArrayToUint8(c),e.forEach((e=>a.disposeData(e.dataId))),d}const o=s.yc.sizeFromShape(i[0].shape.slice(0,n));let c=0;const p=i.map((e=>{const t=s.yc.sizeFromShape(e.shape.slice(n));return c+=t,t})),l=i.map((e=>a.typedArrayFromHeap(e))),m=a.typedArrayFromHeap(d);for(let e=0;e<o;e++){let t=e*c;for(let a=0;a<l.length;a++){const n=p[a],r=e*n,s=l[a].subarray(r,r+n);m.set(s,t),t+=n}}return d}const P={kernelName:s.l,backendName:"wasm",kernelFunc:E};let R;const $={kernelName:s.m,backendName:"wasm",setupFunc:function(e){R=e.wasm.cwrap(s.m,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:r,filter:i}=t,d=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(i.dataId).id,{strides:o,dilations:c,pad:p,dimRoundingMode:l,dataFormat:m}=a,b=s.Sb.convertConv2DDataFormat(m),h=s.Sb.computeConv2DInfo(r.shape,i.shape,o,c,p,l,!1,b),f=h.filterHeight,k=h.filterWidth,g=h.padInfo.top,w=h.padInfo.right,y=h.padInfo.bottom,I=h.padInfo.left,A=h.dilationHeight,S=h.dilationWidth,M=h.strideHeight,x=h.strideWidth,F=h.inChannels,N=h.outChannels,v="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);const O=n.makeOutput(h.outShape,"float32"),C=n.dataIdMap.get(O.dataId).id;return R(d,r.shape[0],r.shape[1],r.shape[2],u,f,k,g,w,y,I,v,A,S,M,x,F,N,C),O}};let j;const L={kernelName:s.n,backendName:"wasm",setupFunc:function(e){j=e.wasm.cwrap(s.n,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{dy:r,filter:i}=a,{strides:d,pad:u,dataFormat:o,dimRoundingMode:c,inputShape:p}=n,l=s.Sb.convertConv2DDataFormat(o),m=s.Sb.computeConv2DInfo(p,i.shape,d,1,u,c,!1,l),{batchSize:b,filterHeight:h,filterWidth:f,inChannels:k,inHeight:g,inWidth:w,outChannels:y,outHeight:I,outWidth:A,strideHeight:S,strideWidth:M}=m,x=h-1-m.padInfo.top,F=f-1-m.padInfo.left,N="channelsLast"===m.dataFormat,v=s.yc.computeStrides(m.inShape),O=s.yc.computeStrides(r.shape),[C,z,D]=s.yc.computeStrides(i.shape),T=v[0],U=N?v[1]:v[2],W=N?v[2]:1,H=N?1:v[1],E=O[0],P=N?O[1]:O[2],R=N?O[2]:1,$=N?1:O[1],L=t.makeOutput(m.inShape,"float32"),B=t.dataIdMap.get(L.dataId).id,_=t.dataIdMap.get(r.dataId).id,V=t.dataIdMap.get(i.dataId).id;return j(_,V,b,h,f,g,w,k,I,A,y,S,M,x,F,C,z,D,T,U,W,H,E,P,R,$,B),L}},B=u(s.o);var _;let V;!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(_||(_={}));const q={kernelName:s.p,backendName:"wasm",setupFunc:function(e){V=e.wasm.cwrap(s.p,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{method:r,extrapolationValue:s,cropSize:i}=n,{image:d,boxes:u,boxInd:o}=a,c=u.shape[0],[p,l]=i,m=[c,p,l,d.shape[3]];let b,h=t.dataIdMap.get(d.dataId);"float32"!==d.dtype&&(b=D({backend:t,inputs:{x:d},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(b.dataId));const f=h.id,k=t.dataIdMap.get(u.dataId).id,g=t.dataIdMap.get(o.dataId).id,w=t.makeOutput(m,"float32"),y=t.dataIdMap.get(w.dataId).id,I=new Uint8Array(new Int32Array(d.shape).buffer);return V(f,k,g,c,I,p,l,_[r],s,y),null!=b&&t.disposeData(b.dataId),w}};let G;const K={kernelName:s.q,backendName:"wasm",setupFunc:function(e){G=e.wasm.cwrap(s.q,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:r}=e,{x:i}=t,{axis:d,exclusive:u,reverse:o}=r,c=i.shape.length;s.yc.assert("float32"===i.dtype||"int32"===i.dtype,(()=>`cumsum does not support ${i.dtype} tensors in the WASM backend`));const p=s.Sb.getAxesPermutation([d],c);let l=i;null!==p&&(l=k({inputs:{x:i},attrs:{perm:p},backend:a}));const m=s.Sb.getInnerMostAxes(1,c)[0];s.Sb.assertAxesAreInnerMostDims("cumsum",[m],c);const b=a.makeOutput(l.shape,l.dtype),h=l.shape[m],f=a.dataIdMap.get(l.dataId).id,g=a.dataIdMap.get(b.dataId).id;G(f,u?1:0,o?1:0,h,g,n[i.dtype]);let w=b;if(null!==p){w=k({inputs:{x:b},attrs:{perm:s.Sb.getUndoAxesPermutation(p)},backend:a}),a.disposeData(l.dataId),a.disposeData(b.dataId)}return w}};let X;const Y={kernelName:s.s,backendName:"wasm",setupFunc:function(e){X=e.wasm.cwrap(s.s,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{x:r}=a,{blockSize:i,dataFormat:d}=n;s.yc.assert(i>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`));const u=r.shape[0],o="NHWC"===d?r.shape[1]:r.shape[2],c="NHWC"===d?r.shape[2]:r.shape[3],p="NHWC"===d?r.shape[3]:r.shape[1],l=o*i,m=c*i,b=p/(i*i),h="NHWC"===d?[u,l,m,b]:[u,b,l,m],f=t.makeOutput(h,"float32"),k=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(s.yc.computeStrides(r.shape)).buffer),w=new Uint8Array(new Int32Array(h).buffer),y=new Uint8Array(new Int32Array(s.yc.computeStrides(h)).buffer),I=t.dataIdMap.get(f.dataId).id;return X(k,i,"NHWC"===d?1:0,g,r.shape.length-1,w,y,h.length,I),f}};let Z;const Q={kernelName:s.t,backendName:"wasm",setupFunc:function(e){Z=e.wasm.cwrap(s.t,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:r,filter:i}=t,d=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(i.dataId).id,{strides:o,dilations:c,pad:p,dimRoundingMode:l}=a,m=null==c?[1,1]:c,b=s.Sb.computeConv2DInfo(r.shape,i.shape,o,m,p,l,!0),h=b.filterHeight,f=b.filterWidth,k=b.padInfo.top,g=b.padInfo.right,w=b.padInfo.bottom,y=b.padInfo.left,I=b.dilationHeight,A=b.dilationWidth,S=b.strideHeight,M=b.strideWidth,x=b.inChannels,F=b.outChannels,N="SAME"===b.padInfo.type?1:0;if("channelsLast"!==b.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${b.dataFormat}'. Please use 'channelsLast'.`);const v=n.makeOutput(b.outShape,"float32"),O=n.dataIdMap.get(v.dataId).id;return Z(d,r.shape[0],r.shape[1],r.shape[2],u,h,f,k,g,w,y,N,I,A,S,M,x,F,O),v}},J=c(s.u,!1,"bool"),ee=u(s.v);function te(e){const{inputs:t,attrs:a,backend:n}=e,{input:r}=t,{dim:i}=a,d=r.shape.length,u=r.shape.slice();let o=i;return i<0&&(s.yc.assert(-(d+1)<=i,(()=>`Axis must be in the interval [${-(d+1)}, ${d}]`)),o=d+i+1),u.splice(o,0,1),v({inputs:{x:r},backend:n,attrs:{shape:u}})}const ae={kernelName:s.ExpandDims,backendName:"wasm",kernelFunc:te};const ne={kernelName:s.x,backendName:"wasm",kernelFunc:function(e){const{attrs:{shape:t,value:a,dtype:n},backend:r}=e,s=r.makeOutput(t,n);return r.typedArrayFromHeap(s).fill(a),s}};let re;const se={kernelName:s.y,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a}=e,{image:n}=t,r=a.makeOutput(n.shape,n.dtype),s=a.dataIdMap.get(n.dataId).id,i=a.dataIdMap.get(r.dataId).id,[d,u,o,c]=n.shape;return re(s,d,u,o,c,i),r},setupFunc:function(e){re=e.wasm.cwrap(s.y,null,["number","number","number","number","number","number"])}},ie=u(s.z),de=c(s.A,!1);let ue;const oe={kernelName:s.B,backendName:"wasm",setupFunc:function(e){ue=e.wasm.cwrap(s.B,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{varianceEpsilon:r}=n,{x:i,mean:d,variance:u,offset:o,scale:c}=a,p=t.dataIdMap.get(i.dataId).id,l=t.dataIdMap.get(d.dataId).id,m=t.dataIdMap.get(u.dataId).id,b=null!=o?t.dataIdMap.get(o.dataId).id:0,h=null!=c?t.dataIdMap.get(c.dataId).id:0,f=t.makeOutput(i.shape,i.dtype);if(0===s.yc.sizeFromShape(i.shape))return f;const k=t.dataIdMap.get(f.dataId).id;return ue(p,l,m,b,h,r,k),f}};let ce;const pe={kernelName:s.C,backendName:"wasm",setupFunc:function(e){ce=e.wasm.cwrap(s.C,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:i,filter:d,bias:u,preluActivationWeights:o}=t,{strides:c,pad:p,dilations:l,dataFormat:m,dimRoundingMode:b,activation:h,leakyreluAlpha:f}=a,k=s.Sb.computeConv2DInfo(i.shape,d.shape,c,l,p,b),g=r[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);const w=n.dataIdMap.get(i.dataId).id,y=n.dataIdMap.get(d.dataId).id,I=k.outChannels;let A=0;if(null!=u){const e=n.dataIdMap.get(u.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==I)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);A=e.id}const S=k.filterHeight,M=k.filterWidth,x=k.padInfo.top,F=k.padInfo.right,N=k.padInfo.bottom,v=k.padInfo.left,O=k.dilationHeight,C=k.dilationWidth,z=k.strideHeight,D=k.strideWidth,T=k.inChannels,U="SAME"===k.padInfo.type?1:0,W=k.batchSize,H=k.inHeight,E=k.inWidth;if("NHWC"!==m)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);const P=n.makeOutput(k.outShape,"float32"),R=n.dataIdMap.get(P.dataId).id,$=null==o?0:n.dataIdMap.get(o.dataId).id;return ce(w,W,H,E,y,S,M,A,x,F,N,v,U,O,C,z,D,T,I,g,$,f||0,R),P}};let le;const me={kernelName:s.D,backendName:"wasm",setupFunc:function(e){le=e.wasm.cwrap(s.D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:i,filter:d,bias:u,preluActivationWeights:o}=t,{strides:c,pad:p,dilations:l,dataFormat:m,dimRoundingMode:b,activation:h,leakyreluAlpha:f}=a,k=s.Sb.computeConv2DInfo(i.shape,d.shape,c,l,p,b,!0),g=r[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const w=n.dataIdMap.get(i.dataId).id,y=n.dataIdMap.get(d.dataId).id,I=k.outChannels;let A=0;if(null!=u){const e=n.dataIdMap.get(u.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==I)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);A=e.id}const S=k.filterHeight,M=k.filterWidth,x=k.padInfo.top,F=k.padInfo.right,N=k.padInfo.bottom,v=k.padInfo.left,O=k.dilationHeight,C=k.dilationWidth,z=k.strideHeight,D=k.strideWidth,T=k.inChannels,U="SAME"===k.padInfo.type?1:0,W=k.batchSize,H=k.inHeight,E=k.inWidth;if("NHWC"!==m)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);const P=n.makeOutput(k.outShape,"float32"),R=n.dataIdMap.get(P.dataId).id,$=null==o?0:n.dataIdMap.get(o.dataId).id;return le(w,W,H,E,y,S,M,A,x,F,N,v,U,O,C,z,D,T,I,g,$,f||0,R),P}};let be;const he={kernelName:s.E,backendName:"wasm",setupFunc:function(e){be=e.wasm.cwrap(s.E,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:a}=e,{params:r,indices:i}=a,[d,u,o,c]=s.cc.prepareAndValidate(r,i),p=t.makeOutput(d,r.dtype);if(0===u)return p;const l=i.shape,m=l[l.length-1],b=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(i.dataId).id,f=new Uint8Array(new Int32Array(c).buffer),k=t.dataIdMap.get(p.dataId).id;return be(b,n[r.dtype],h,u,m,o,f,k),p}};let fe;const ke={kernelName:s.F,backendName:"wasm",setupFunc:function(e){fe=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{x:i,indices:d}=a,{axis:u,batchDims:o}=r,c=s.yc.parseAxisParam(u,i.shape)[0],p=s.Sb.segment_util.collectGatherOpShapeInfo(i,d,c,o),l=v({inputs:{x:i},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),m=s.yc.sizeFromShape(d.shape),b=v({inputs:{x:d},attrs:{shape:[p.batchSize,m/p.batchSize]},backend:t}),h=[p.batchSize,p.outerSize,m/p.batchSize,p.sliceSize],f=t.makeOutput(h,i.dtype);if(0===s.yc.sizeFromShape(i.shape))return f;const k=l.shape.length-1,g=t.dataIdMap.get(l.dataId).id,w=t.dataIdMap.get(b.dataId).id,y=t.dataIdMap.get(f.dataId).id,I=new Uint8Array(new Int32Array(s.yc.computeStrides(l.shape)).buffer),A=new Uint8Array(new Int32Array(s.yc.computeStrides(h)).buffer);return fe(g,n[i.dtype],I,k,w,p.batchSize,A,y),t.disposeData(l.dataId),t.disposeData(b.dataId),f.shape=p.outputShape,f}},ge=c(s.G,!1,"bool"),we=c(s.H,!1,"bool");let ye;const Ie={kernelName:s.LeakyRelu,backendName:"wasm",setupFunc:function(e){ye=e.wasm.cwrap(s.LeakyRelu,null,["number","number","number"])},kernelFunc:function(e){const{inputs:{x:t},attrs:{alpha:a},backend:n}=e,r=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(t.shape,t.dtype);if(0!==s.yc.sizeFromShape(t.shape)){const e=n.dataIdMap.get(i.dataId).id;ye(r,a,e)}return i}},Ae=c(s.L,!1,"bool"),Se=c(s.M,!1,"bool"),Me=u(s.N),xe=c(s.O,!1,"bool");let Fe;const Ne={kernelName:s.P,backendName:"wasm",setupFunc:function(e){Fe=e.wasm.cwrap(s.P,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{reductionIndices:r,keepDims:i}=n,{x:d}=a;let u=t.dataIdMap.get(d.dataId).id,o=d;const{transposed:c,axes:p,originalAxes:l,inputWasTransposed:m}=w(d,r,t);if(m){o=c,u=t.dataIdMap.get(c.dataId).id}const b=o.shape.length;s.Sb.assertAxesAreInnerMostDims("max",p,b);const[h,f]=s.Sb.computeOutAndReduceShapes(o.shape,p),k=s.yc.sizeFromShape(f),g=t.makeOutput(h,d.dtype);if(0!==s.yc.sizeFromShape(o.shape)){const e=t.dataIdMap.get(g.dataId).id;Fe(u,k,e)}if(m&&t.disposeData(c.dataId),i){const e=s.Sb.expandShapeToKeepDim(g.shape,l);g.shape=e}return g}},ve=c(s.R,!1);let Oe;const Ce={kernelName:s.Q,backendName:"wasm",setupFunc:function(e){Oe=e.wasm.cwrap(s.Q,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,r=t.x,i=n.dataIdMap.get(r.dataId).id,{filterSize:d,strides:u,pad:o,dimRoundingMode:c}=a,p=s.Sb.computePool2DInfo(r.shape,d,u,1,o,c),l=p.filterHeight,m=p.filterWidth,b=p.padInfo.top,h=p.padInfo.right,f=p.padInfo.bottom,k=p.padInfo.left,g=p.dilationHeight,w=p.dilationWidth,y=p.strideHeight,I=p.strideWidth,A=p.inChannels,S=p.outChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);const M=n.makeOutput(p.outShape,"float32"),x=n.dataIdMap.get(M.dataId).id;return Oe(i,r.shape[0],r.shape[1],r.shape[2],l,m,b,h,f,k,g,w,y,I,A,S,x),M}};let ze;const De={kernelName:s.S,backendName:"wasm",setupFunc:function(e){ze=e.wasm.cwrap(s.S,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,originalAxes:m,inputWasTransposed:b}=w(d,r,t);let h=l;if(b){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e,h=s.Sb.getInnerMostAxes(h.length,c.shape.length))}s.Sb.assertAxesAreInnerMostDims("mean",h,c.shape.length);const[f,k]=s.Sb.computeOutAndReduceShapes(c.shape,h),g=s.yc.sizeFromShape(k);let y=c;"float32"!==c.dtype&&(y=D({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),o=t.dataIdMap.get(y.dataId).id);const I=t.makeOutput(f,"float32");if(0!==s.yc.sizeFromShape(c.shape)){const e=t.dataIdMap.get(I.dataId).id;ze(o,g,e)}if(b&&t.disposeData(p.dataId),i){const e=s.Sb.expandShapeToKeepDim(I.shape,m);I.shape=e}return"float32"!==c.dtype&&t.disposeData(y.dataId),I}};let Te;const Ue={kernelName:s.T,backendName:"wasm",setupFunc:function(e){Te=e.wasm.cwrap(s.T,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,originalAxes:m,inputWasTransposed:b}=w(d,r,t);if(b){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e)}const h=c.shape.length;s.Sb.assertAxesAreInnerMostDims("min",l,h);const[f,k]=s.Sb.computeOutAndReduceShapes(c.shape,l),g=s.yc.sizeFromShape(k),y=t.makeOutput(f,c.dtype);if(0!==s.yc.sizeFromShape(c.shape)){const e=t.dataIdMap.get(y.dataId).id;Te(o,g,e)}if(b&&t.disposeData(p.dataId),i){const e=s.Sb.expandShapeToKeepDim(y.shape,m);y.shape=e}return y}},We=c(s.U,!1);var He;let Ee;!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(He||(He={}));const Pe={kernelName:s.MirrorPad,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:a,attrs:{paddings:r,mode:s}}=e,i=r.map(((e,a)=>e[0]+t.shape[a]+e[1])),d=a.dataIdMap.get(t.dataId).id,u=a.makeOutput(i,t.dtype),o=a.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),l=r.map((e=>e[1])),m=new Uint8Array(new Int32Array(p).buffer),b=new Uint8Array(new Int32Array(l).buffer);return Ee(d,c,t.shape.length,n[t.dtype],m,b,He[s],o),u},setupFunc:function(e){Ee=e.wasm.cwrap(s.MirrorPad,null,["number","array","number","number","array","array","number","number"])}},Re=c(s.W,!0),$e=u(s.Neg);function je(e,t){const a=new Int32Array(e.wasm.HEAPU8.buffer,t,4),n=a[0],r=a[1],s=a[2],i=a[3];return e.wasm._free(t),{pSelectedIndices:n,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}let Le;const Be={kernelName:s.Y,backendName:"wasm",setupFunc:function(e){Le=e.wasm.cwrap(s.Y,"number",["number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=n,{boxes:d,scores:u}=a,o=t.dataIdMap.get(d.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=Le(o,c,s,r,i),{pSelectedIndices:l,selectedSize:m,pSelectedScores:b,pValidOutputs:h}=je(t,p);return t.wasm._free(b),t.wasm._free(h),t.makeOutput([m],"int32",l)}};let _e;const Ve={kernelName:s.Z,backendName:"wasm",setupFunc:function(e){_e=e.wasm.cwrap(s.Z,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:d}=n,{boxes:u,scores:o}=a,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(o.dataId).id,l=_e(c,p,s,r,i,d),{pSelectedIndices:m,selectedSize:b,pSelectedScores:h,pValidOutputs:f}=je(t,l);return t.wasm._free(h),[t.makeOutput([b],"int32",m),t.makeOutput([],"int32",f)]}};let qe;const Ge={kernelName:s.ab,backendName:"wasm",setupFunc:function(e){qe=e.wasm.cwrap(s.ab,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:d}=n,{boxes:u,scores:o}=a,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(o.dataId).id,l=qe(c,p,s,r,i,d),{pSelectedIndices:m,selectedSize:b,pSelectedScores:h,pValidOutputs:f}=je(t,l);return t.wasm._free(f),[t.makeOutput([b],"int32",m),t.makeOutput([b],"float32",h)]}},Ke=c(s.bb,!1,"bool");let Xe;const Ye={kernelName:s.cb,backendName:"wasm",setupFunc:function(e){Xe=e.wasm.cwrap(s.cb,null,["number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{indices:r}=t,{depth:s,onValue:i,offValue:d}=n,u=a.makeOutput([...r.shape,s],"int32"),o=a.dataIdMap.get(u.dataId).id,c=a.dataIdMap.get(r.dataId).id;return Xe(c,s,i,d,o),u}};const Ze={kernelName:s.db,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype);return a.typedArrayFromHeap(n).fill(1),n}};const Qe={kernelName:s.Pack,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{axis:r}=n;if(1===t.length)return te({inputs:{input:t[0]},backend:a,attrs:{dim:r}});const i=t[0].shape,d=t[0].dtype;t.forEach((e=>{s.yc.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),s.yc.assert(d===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],o=E({inputs:t.map((e=>{const t=te({inputs:{input:e},backend:a,attrs:{dim:r}});return u.push(t),t})),backend:a,attrs:{axis:r}});return u.forEach((e=>a.disposeData(e.dataId))),o}};let Je;const et={kernelName:s.fb,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:a,attrs:{paddings:r,constantValue:s}}=e,i=r.map(((e,a)=>e[0]+t.shape[a]+e[1])),d=a.dataIdMap.get(t.dataId).id,u=a.makeOutput(i,t.dtype),o=a.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),l=r.map((e=>e[1])),m=new Uint8Array(new Int32Array(p).buffer),b=new Uint8Array(new Int32Array(l).buffer);return Je(d,c,t.shape.length,n[t.dtype],m,b,s,o),u},setupFunc:function(e){Je=e.wasm.cwrap(s.fb,null,["number","array","number","number","array","array","number","number"])}},tt=c(s.gb,!1);let at;const nt={kernelName:s.hb,backendName:"wasm",setupFunc:function(e){at=e.wasm.cwrap(s.hb,null,["number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a}=e,{x:n,alpha:r}=t,s=a.dataIdMap.get(n.dataId).id,i=a.dataIdMap.get(r.dataId).id,d=a.makeOutput(n.shape,"float32"),u=a.dataIdMap.get(d.dataId).id;return at(s,i,u),d}};let rt;const st={kernelName:s.ib,backendName:"wasm",setupFunc:function(e){rt=e.wasm.cwrap(s.ib,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{axis:i,keepDims:d}=r,{x:u}=a,o=t.dataIdMap.get(u.dataId).id;let c=o,p=u;const{transposed:l,axes:m,originalAxes:b,inputWasTransposed:h}=w(u,i,t);let f=m;if(h){const e=t.dataIdMap.get(l.dataId).id;e!==o&&(p=l,c=e,f=s.Sb.getInnerMostAxes(f.length,p.shape.length))}s.Sb.assertAxesAreInnerMostDims("prod",f,p.shape.length);const[k,g]=s.Sb.computeOutAndReduceShapes(p.shape,f),y=s.yc.sizeFromShape(g),I=t.makeOutput(k,p.dtype);if(0!==s.yc.sizeFromShape(p.shape)){const e=t.dataIdMap.get(I.dataId).id;rt(c,y,n[I.dtype],e)}if(h&&t.disposeData(l.dataId),d){const e=s.Sb.expandShapeToKeepDim(I.shape,b);I.shape=e}return I}};const it={kernelName:s.jb,backendName:"wasm",kernelFunc:e=>{const{backend:t,attrs:a}=e,{start:n,stop:r,step:i,dtype:d}=a,u=function(e,t,a,n){if(e===t||e<t&&a<0||t<e&&a>1)return s.yc.makeZerosTypedArray(0,n);const r=Math.abs(Math.ceil((t-e)/a)),i=s.yc.makeZerosTypedArray(r,n);t<e&&1===a&&(a=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+a;return i}(n,r,i,d),o=t.makeOutput([u.length],d);return t.typedArrayFromHeap(o).set(u),o}},dt=c(s.RealDiv,!0),ut=u(s.lb),ot=u(s.mb);let ct;const pt={kernelName:s.ob,backendName:"wasm",setupFunc:function(e){ct=e.wasm.cwrap(s.ob,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{images:r}=a,{alignCorners:i,halfPixelCenters:d,size:u}=n,[o,c]=u,[p,l,m,b]=r.shape,h=[p,o,c,b];let f,k=t.dataIdMap.get(r.dataId);"float32"!==k.dtype&&(f=D({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),k=t.dataIdMap.get(f.dataId));const g=k.id,w=t.makeOutput(h,"float32");if(0===s.yc.sizeFromShape(r.shape))return w;const y=t.dataIdMap.get(w.dataId).id;return ct(g,p,l,m,b,o,c,i?1:0,d?1:0,y),null!=f&&t.disposeData(f.dataId),w}};let lt;const mt={kernelName:s.pb,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{dims:i}=n,d=s.yc.parseAxisParam(i,r.shape);if(0===r.shape.length)return b({inputs:{x:r},backend:a});const u=a.makeOutput(r.shape,r.dtype),o=a.dataIdMap.get(r.dataId).id,c=a.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(d).buffer),l=new Uint8Array(new Int32Array(r.shape).buffer);lt(o,p,d.length,l,r.shape.length,c);const m=v({inputs:{x:u},attrs:{shape:r.shape},backend:a});return a.disposeData(u.dataId),m},setupFunc:function(e){lt=e.wasm.cwrap(s.pb,null,["number","array","number","array","number","number"])}};let bt;const ht={kernelName:s.qb,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{image:r}=t,{radians:i,fillValue:d,center:u}=n,o=a.makeOutput(r.shape,r.dtype),c=a.dataIdMap.get(r.dataId).id,p=a.dataIdMap.get(o.dataId).id,[l,m,b,h]=r.shape,[f,k]=s.Sb.getImageCenter(u,m,b),g="number"==typeof d?[d,d,d,0===d?0:255]:[...d,255],w=new Uint8Array(new Int32Array(g).buffer);return bt(c,l,m,b,h,i,f,k,w,g.length,p),o},setupFunc:function(e){bt=e.wasm.cwrap(s.qb,null,["number","number","number","number","number","number","number","number","array","number","number"])}},ft=u(s.rb),kt=u(s.sb);let gt;const wt={kernelName:s.tb,backendName:"wasm",setupFunc:function(e){gt=e.wasm.cwrap(s.tb,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{indices:i,updates:d}=a,{shape:u}=r,o=t.makeOutput(u,d.dtype);if(0===s.yc.sizeFromShape(u))return o;const{sliceRank:c,numUpdates:p,sliceSize:l,strides:m,outputSize:b}=s.mc.calculateShapes(d,i,u),h=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(d.dataId).id,k=new Uint8Array(new Int32Array(m).buffer),g=t.dataIdMap.get(o.dataId).id;return gt(h,f,n[d.dtype],c,p,l,k,b,g),o}};let yt;const It={kernelName:s.Select,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a}=e,{condition:n,t:r,e:i}=t,d=a.dataIdMap.get(n.dataId).id,u=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(i.dataId).id,c=a.makeOutput(r.shape,r.dtype),p=a.dataIdMap.get(c.dataId).id,l=n.shape.length,m=r.shape.length,b=0===l||l>1||1===m?1:s.yc.sizeFromShape(r.shape.slice(1));return yt(d,u,o,b,p),c},setupFunc:function(e){yt=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}};let At;const St={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){At=e.wasm.cwrap(s.vb,null,["number","number"])},kernelFunc:function(e){const{backend:t,inputs:{x:a}}=e,n=t.dataIdMap.get(a.dataId).id,r=t.makeOutput(a.shape,a.dtype),i=t.dataIdMap.get(r.dataId).id;return 0===s.yc.sizeFromShape(r.shape)||At(n,i),r}},Mt=u(s.wb);function xt(e,t,a,n,r){const i=s.qc.isSliceContinous(n,t,a),d=s.yc.sizeFromShape(a),u=s.yc.computeStrides(n);if(i){const a=s.qc.computeFlatOffset(t,u);return"string"===r?e.slice(a,a+d):e.subarray(a,a+d)}const o="string"===r?s.Sb.fromUint8ToStringArray(e):e,c=Object(s.Ub)(n,r,o),p=Object(s.Ub)(a,r);for(let e=0;e<p.size;++e){const a=p.indexToLoc(e),n=a.map(((e,a)=>e+t[a]));p.set(c.get(...n),...a)}return"string"===r?s.Sb.fromStringArrayToUint8(p.values):p.values}s.xb;function Ft(e){const{inputs:{x:t},attrs:{begin:a,size:n},backend:r}=e,[i,d]=s.qc.parseSliceParams(t,a,n),u=s.qc.isSliceContinous(t.shape,i,d),o=r.readSync(t.dataId),c=r.makeOutput(d,t.dtype),p=s.yc.computeStrides(t.shape),l=r.dataIdMap.get(c.dataId);if(u){const e=s.qc.computeFlatOffset(i,p);if("string"===t.dtype)l.stringBytes=o.slice(e,e+s.yc.sizeFromShape(d));else{r.typedArrayFromHeap(c).set(o.subarray(e,e+s.yc.sizeFromShape(d)))}return c}if("string"===t.dtype){const e=xt(o,i,d,t.shape,t.dtype);return l.stringBytes=e,c}const m=r.typedArrayFromHeap(c),b=t.shape.length;if(2===b)!function(e,t,a,n,r){let s=0;const i=n[0],d=n[1],u=i+r[0];for(let n=i;n<u;n++){const i=n*t+d;a.set(e.subarray(i,i+r[1]),s),s+=r[1]}}(o,p[0],m,i,d);else if(3===b)!function(e,t,a,n,r,s){let i=0;const d=r[0],u=r[1],o=r[2],c=d+s[0],p=u+s[1];for(let r=d;r<c;r++)for(let d=u;d<p;d++){const u=r*t+d*a+o;n.set(e.subarray(u,u+s[2]),i),i+=s[2]}}(o,p[0],p[1],m,i,d);else if(4===b)!function(e,t,a,n,r,s,i){let d=0;const u=s[0],o=s[1],c=s[2],p=u+i[0],l=o+i[1],m=c+i[2],b=s[3];for(let s=u;s<p;s++)for(let u=o;u<l;u++)for(let o=c;o<m;o++){const c=s*t+u*a+o*n+b;r.set(e.subarray(c,c+i[3]),d),d+=i[3]}}(o,p[0],p[1],p[2],m,i,d);else{const e=xt(o,i,d,t.shape,t.dtype);m.set(e)}return c}let Nt;let vt;let Ot;let Ct;let zt;let Dt;let Tt;const Ut=[o,p,m,I,S,x,N,z,T,U,H,P,$,L,B,q,K,Y,Q,J,ee,ae,ne,se,ie,de,d,oe,pe,me,he,ke,ge,we,h,Ie,Ae,Se,Me,xe,Ne,ve,Ce,De,Ue,We,Pe,Re,$e,Be,Ve,Ge,Ke,Ye,Ze,Qe,et,tt,nt,st,it,dt,ut,ot,O,pt,mt,ht,kt,ft,wt,It,St,Mt,{kernelName:s.xb,backendName:"wasm",kernelFunc:Ft},{kernelName:s.yb,backendName:"wasm",setupFunc:function(e){Nt=e.wasm.cwrap(s.yb,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:{logits:a},attrs:{dim:n}}=e,r=t.dataIdMap.get(a.dataId).id,i=t.makeOutput(a.shape,a.dtype),d=t.dataIdMap.get(i.dataId).id,u=a.shape[n],o=s.yc.sizeFromShape(a.shape)/u;return 0===s.yc.sizeFromShape(i.shape)||Nt(r,d,u,o),i}},{kernelName:s.zb,backendName:"wasm",kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:r}=t,{numOrSizeSplits:i,axis:d}=a,u=s.yc.parseAxisParam(d,r.shape)[0],o=s.Sb.prepareSplitSize(r,i,u),c=new Array(r.shape.length).fill(0),p=r.shape.slice();return o.map((e=>{const t=[...p];t[u]=e;const a=Ft({inputs:{x:r},attrs:{begin:c,size:t},backend:n});return c[u]+=e,a}))}},u(s.Ab),u(s.Bb),c(s.Cb,!0),{kernelName:s.Db,backendName:"wasm",setupFunc:function(e){vt=e.wasm.cwrap(s.Db,null,["number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{alpha:r}=n,{x:s}=a,i=t.dataIdMap.get(s.dataId).id,d=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(d.dataId).id;return vt(i,r,u),d}},{kernelName:s.Eb,backendName:"wasm",setupFunc:function(e){Ot=e.wasm.cwrap(s.Eb,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{x:r}=a;let{begin:i,end:d,strides:u}=n;null==u&&(u=new Array(i.length));const{beginMask:o,endMask:c,ellipsisMask:p,newAxisMask:l,shrinkAxisMask:m}=n,b=s.Sb.slice_util.maskToAxes(p);if(b.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==p&&0!==l)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==p&&0!==m)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const h=r.shape.length-i.length,f=s.Sb.slice_util.maskToAxes(l),k=r.shape.slice();f.forEach((e=>{i[e]=0,d[e]=1,k.splice(e,0,1)}));const g=v({inputs:{x:r},attrs:{shape:k},backend:t}),{begin:w,end:y,strides:I}=s.Sb.slice_util.getNormalizedAxes(g.shape,b,h,i,d,u,o,c,p);i=w,d=y,u=I;const A=s.Sb.slice_util.maskToAxes(m);A.forEach((e=>{d[e]=i[e]+1,u[e]=1}));const S=s.Sb.slice_util.computeOutShape(i,d,u),M=S.filter(((e,t)=>-1===A.indexOf(t)));if(u.every((e=>1===e))){const e=Ft({inputs:{x:g},attrs:{begin:i,size:S},backend:t});t.disposeData(g.dataId);const a=v({inputs:{x:e},attrs:{shape:M},backend:t});return t.disposeData(e.dataId),a}const x=t.makeOutput(M,"float32");if(!M.some((e=>0===e))){const e=t.dataIdMap.get(g.dataId).id,a=new Uint8Array(new Int32Array(s.yc.computeStrides(g.shape)).buffer),n=new Uint8Array(new Int32Array(i).buffer),r=new Uint8Array(new Int32Array(d).buffer),o=new Uint8Array(new Int32Array(u).buffer),c=new Uint8Array(new Int32Array(M).buffer),p=new Uint8Array(new Int32Array(s.yc.computeStrides(M)).buffer),l=t.dataIdMap.get(x.dataId).id;Ot(e,a,g.shape.length,n,r,o,c,p,M.length,l)}t.disposeData(g.dataId);const F=v({inputs:{x:x},attrs:{shape:M},backend:t});return t.disposeData(x.dataId),F}},c(s.Fb,!0),{kernelName:s.Gb,backendName:"wasm",setupFunc:function(e){Ct=e.wasm.cwrap(s.Gb,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,originalAxes:m,inputWasTransposed:b}=w(d,r,t);let h=l;if(b){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e,h=s.Sb.getInnerMostAxes(h.length,c.shape.length))}s.Sb.assertAxesAreInnerMostDims("sum",h,c.shape.length);const[f,k]=s.Sb.computeOutAndReduceShapes(c.shape,h),g=s.yc.sizeFromShape(k),y=t.makeOutput(f,c.dtype);if(0!==s.yc.sizeFromShape(c.shape)){const e=t.dataIdMap.get(y.dataId).id;Ct(o,g,e)}if(b&&t.disposeData(p.dataId),i){const e=s.Sb.expandShapeToKeepDim(y.shape,m);y.shape=e}return y}},u(s.Hb),u(s.Ib),{kernelName:s.Kb,backendName:"wasm",setupFunc:function(e){zt=e.wasm.cwrap(s.Kb,null,["number","array","number","array","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:r}=e,{x:s}=t,i=a.dataIdMap.get(s.dataId).id,{reps:d}=r,u=new Array(s.shape.length);for(let e=0;e<u.length;e++)u[e]=s.shape[e]*d[e];const o=new Uint8Array(new Int32Array(s.shape).buffer),c=new Uint8Array(new Int32Array(u).buffer),p=a.makeOutput(u,s.dtype),l=a.dataIdMap.get(p.dataId).id;return zt(i,o,s.shape.length,c,u.length,n[p.dtype],l),p}},{kernelName:s.Lb,backendName:"wasm",setupFunc:function(e){Dt=e.wasm.cwrap(s.Lb,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:a})=>{const{x:r}=e,{k:s,sorted:i}=a,d=t.dataIdMap.get(r.dataId).id,u=new Uint8Array(new Int32Array(r.shape).buffer),o=r.shape.slice();o[o.length-1]=s;const c=t.makeOutput(o,r.dtype),p=t.dataIdMap.get(c.dataId).id,l=t.makeOutput(o,"int32"),m=t.dataIdMap.get(l.dataId).id;return Dt(d,u,r.shape.length,n[r.dtype],s,i,p,m),[c,l]}},{kernelName:s.Transform,backendName:"wasm",setupFunc:function(e){Tt=e.wasm.cwrap(s.Transform,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{image:r,transforms:i}=a,{interpolation:d,fillMode:u,fillValue:o,outputShape:c}=n,[p,l,m,b]=r.shape,[h,f]=null!=c?c:[l,m],k=[p,h,f,b],g=new Uint8Array(new Int32Array(s.yc.computeStrides(r.shape)).buffer),w=t.makeOutput(k,r.dtype),y=t.dataIdMap.get(w.dataId).id,I=t.dataIdMap.get(r.dataId).id,A=t.dataIdMap.get(i.dataId).id,S="nearest"===d?1:2;let M;switch(u){case"constant":M=1;break;case"reflect":M=2;break;case"wrap":M=3;break;case"nearest":M=4;break;default:M=1}return Tt(I,A,i.shape[0]>1,p,h,f,b,m,l,g,r.shape.length-1,S,M,o,y),w}},g,{kernelName:s.Ob,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{value:r}=t;let{axis:s}=n;s<0&&(s+=r.shape.length);const i=r.shape[s],d=r.shape.length,u=new Array(d-1);let o=0;for(let e=0;e<d;e++)e!==s&&(u[o++]=r.shape[e]);const c=new Array(i),p=new Array(d).fill(0),l=r.shape.slice();l[s]=1;for(let e=0;e<c.length;e++)p[s]=e,c[e]=Ft({inputs:{x:r},attrs:{begin:p,size:l},backend:a});return c.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:u})))}},{kernelName:s.Pb,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype);return a.typedArrayFromHeap(n).fill(0),n}}];for(const e of Ut)Object(s.jc)(e);const Wt=Object(s.bc)();Wt.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])))),Wt.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(Wt.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var Ht=a(233),Et=a.n(Ht),Pt=a(422),Rt=a(423),$t=a.n(Rt);class jt extends s.J{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.init(),this.dataIdMap=new s.r(this,Object(s.ac)())}write(e,t,a){const n={id:this.dataIdNextNumber++};return this.move(n,e,t,a,1),n}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=s.yc.now();e();return{kernelMs:s.yc.now()-t}}move(e,t,a,n,r){const i=this.dataIdNextNumber++;if("string"===n){const s=t;return void this.dataIdMap.set(e,{id:i,stringBytes:s,shape:a,dtype:n,memoryOffset:null,refCount:r})}const d=s.yc.sizeFromShape(a),u=d*s.yc.bytesPerElement(n),o=this.wasm._malloc(u);this.dataIdMap.set(e,{id:i,memoryOffset:o,shape:a,dtype:n,refCount:r}),this.wasm.tfjs.registerTensor(i,d,o),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),o)}async read(e){return this.readSync(e)}readSync(e){const{memoryOffset:t,dtype:a,shape:n,stringBytes:r}=this.dataIdMap.get(e);if("string"===a)return r;return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(t,t+s.yc.sizeFromShape(n)*s.yc.bytesPerElement(a)).buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const a=this.dataIdMap.get(e);if(a.refCount--,!t&&a.refCount>0)return!1;this.wasm._free(a.memoryOffset),this.wasm.tfjs.disposeData(a.id),this.dataIdMap.delete(e)}return!0}refCount(e){if(this.dataIdMap.has(e)){return this.dataIdMap.get(e).refCount}return 0}incRef(e){const t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,a){let n;if(null==a)n=this.write(null,e,t);else{const r=this.dataIdNextNumber++;n={id:r},this.dataIdMap.set(n,{id:r,memoryOffset:a,shape:e,dtype:t,refCount:1});const i=s.yc.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,i,a)}return{dataId:n,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:a}){const n=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(a),i=s.yc.sizeFromShape(e);switch(t){case"float32":return new Float32Array(n,r,i);case"int32":return new Int32Array(n,r,i);case"bool":return new Uint8Array(n,r,i);default:throw new Error(`Unknown dtype ${t}`)}}}function Lt(e,t,a){if(null!=Vt)return Vt;let n="tfjs-backend-wasm.wasm";return e&&t?n="tfjs-backend-wasm-threaded-simd.wasm":e&&(n="tfjs-backend-wasm-simd.wasm"),null!=Gt&&null!=Gt[n]?Gt[n]:a+n}async function Bt(){const[e,t]=await Promise.all([Object(s.bc)().getAsync("WASM_HAS_SIMD_SUPPORT"),Object(s.bc)().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((a,n)=>{const r={};var i;r.locateFile=(a,n)=>{if(a.endsWith(".worker.js")){const e=Pt.a,t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return a.endsWith(".wasm")?Lt(e,t,null!=qt?qt:n):n+a},Xt&&(r.instantiateWasm=(i=Lt(e,t,null!=qt?qt:""),(e,t)=>(s.yc.fetch(i,{credentials:"same-origin"}).then((a=>{a.ok||e.env.a(`failed to load wasm binary file at '${i}'`),a.arrayBuffer().then((a=>{WebAssembly.instantiate(a,e).then((e=>{t(e.instance,e.module)}))}))})),{})));let d,u=!1;r.onAbort=()=>{if(u)return;if(Kt)return;Kt=!0;n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})},t&&e&&null==Vt?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Et.a.toString()],{type:"text/javascript"}),d=Et()(r)):d=$t()(r),d.then((e=>{u=!0,Kt=!1;e.tfjs={init:e.cwrap("init",null,[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},a({wasm:e})}))}))}const _t=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let Vt=null,qt=null,Gt={},Kt=!1,Xt=!1;function Yt(e,t=!1){if(Kt)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)qt=e;else{Gt=e;const t=_t.filter((e=>null==Gt[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Xt=t}Object(s.ic)("wasm",(async()=>{const{wasm:e}=await Bt();return new jt(e)}),2)},532:function(e,t){},535:function(e,t){},536:function(e,t){},543:function(e,t,a){"use strict";var n=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,r=function(e){var t={};return function(a){return void 0===t[a]&&(t[a]=e(a)),t[a]}}((function(e){return n.test(e)||111===e.charCodeAt(0)&&110===e.charCodeAt(1)&&e.charCodeAt(2)<91}));t.a=r},560:function(e,t,a){"use strict";t.a=function(e){function t(e,n,u,o,l){for(var m,b,h,f,y,A=0,S=0,M=0,x=0,F=0,D=0,U=h=m=0,H=0,E=0,P=0,R=0,$=u.length,j=$-1,L="",B="",_="",V="";H<$;){if(b=u.charCodeAt(H),H===j&&0!==S+x+M+A&&(0!==S&&(b=47===S?10:47),x=M=A=0,$++,j++),0===S+x+M+A){if(H===j&&(0<E&&(L=L.replace(p,"")),0<L.trim().length)){switch(b){case 32:case 9:case 59:case 13:case 10:break;default:L+=u.charAt(H)}b=59}switch(b){case 123:for(m=(L=L.trim()).charCodeAt(0),h=1,R=++H;H<$;){switch(b=u.charCodeAt(H)){case 123:h++;break;case 125:h--;break;case 47:switch(b=u.charCodeAt(H+1)){case 42:case 47:e:{for(U=H+1;U<j;++U)switch(u.charCodeAt(U)){case 47:if(42===b&&42===u.charCodeAt(U-1)&&H+2!==U){H=U+1;break e}break;case 10:if(47===b){H=U+1;break e}}H=U}}break;case 91:b++;case 40:b++;case 34:case 39:for(;H++<j&&u.charCodeAt(H)!==b;);}if(0===h)break;H++}switch(h=u.substring(R,H),0===m&&(m=(L=L.replace(c,"").trim()).charCodeAt(0)),m){case 64:switch(0<E&&(L=L.replace(p,"")),b=L.charCodeAt(1)){case 100:case 109:case 115:case 45:E=n;break;default:E=z}if(R=(h=t(n,E,h,b,l+1)).length,0<T&&(y=d(3,h,E=a(z,L,P),n,v,N,R,b,l,o),L=E.join(""),void 0!==y&&0===(R=(h=y.trim()).length)&&(b=0,h="")),0<R)switch(b){case 115:L=L.replace(I,i);case 100:case 109:case 45:h=L+"{"+h+"}";break;case 107:h=(L=L.replace(k,"$1 $2"))+"{"+h+"}",h=1===C||2===C&&s("@"+h,3)?"@-webkit-"+h+"@"+h:"@"+h;break;default:h=L+h,112===o&&(B+=h,h="")}else h="";break;default:h=t(n,a(n,L,P),h,o,l+1)}_+=h,h=P=E=U=m=0,L="",b=u.charCodeAt(++H);break;case 125:case 59:if(1<(R=(L=(0<E?L.replace(p,""):L).trim()).length))switch(0===U&&(m=L.charCodeAt(0),45===m||96<m&&123>m)&&(R=(L=L.replace(" ",":")).length),0<T&&void 0!==(y=d(1,L,n,e,v,N,B.length,o,l,o))&&0===(R=(L=y.trim()).length)&&(L="\0\0"),m=L.charCodeAt(0),b=L.charCodeAt(1),m){case 0:break;case 64:if(105===b||99===b){V+=L+u.charAt(H);break}default:58!==L.charCodeAt(R-1)&&(B+=r(L,m,b,L.charCodeAt(2)))}P=E=U=m=0,L="",b=u.charCodeAt(++H)}}switch(b){case 13:case 10:47===S?S=0:0===1+m&&107!==o&&0<L.length&&(E=1,L+="\0"),0<T*W&&d(0,L,n,e,v,N,B.length,o,l,o),N=1,v++;break;case 59:case 125:if(0===S+x+M+A){N++;break}default:switch(N++,f=u.charAt(H),b){case 9:case 32:if(0===x+A+S)switch(F){case 44:case 58:case 9:case 32:f="";break;default:32!==b&&(f=" ")}break;case 0:f="\\0";break;case 12:f="\\f";break;case 11:f="\\v";break;case 38:0===x+S+A&&(E=P=1,f="\f"+f);break;case 108:if(0===x+S+A+O&&0<U)switch(H-U){case 2:112===F&&58===u.charCodeAt(H-3)&&(O=F);case 8:111===D&&(O=D)}break;case 58:0===x+S+A&&(U=H);break;case 44:0===S+M+x+A&&(E=1,f+="\r");break;case 34:case 39:0===S&&(x=x===b?0:0===x?b:x);break;case 91:0===x+S+M&&A++;break;case 93:0===x+S+M&&A--;break;case 41:0===x+S+A&&M--;break;case 40:if(0===x+S+A){if(0===m)switch(2*F+3*D){case 533:break;default:m=1}M++}break;case 64:0===S+M+x+A+U+h&&(h=1);break;case 42:case 47:if(!(0<x+A+M))switch(S){case 0:switch(2*b+3*u.charCodeAt(H+1)){case 235:S=47;break;case 220:R=H,S=42}break;case 42:47===b&&42===F&&R+2!==H&&(33===u.charCodeAt(R+2)&&(B+=u.substring(R,H+1)),f="",S=0)}}0===S&&(L+=f)}D=F,F=b,H++}if(0<(R=B.length)){if(E=n,0<T&&(void 0!==(y=d(2,B,E,e,v,N,R,o,l,o))&&0===(B=y).length))return V+B+_;if(B=E.join(",")+"{"+B+"}",0!=C*O){switch(2!==C||s(B,2)||(O=0),O){case 111:B=B.replace(w,":-moz-$1")+B;break;case 112:B=B.replace(g,"::-webkit-input-$1")+B.replace(g,"::-moz-$1")+B.replace(g,":-ms-input-$1")+B}O=0}}return V+B+_}function a(e,t,a){var r=t.trim().split(h);t=r;var s=r.length,i=e.length;switch(i){case 0:case 1:var d=0;for(e=0===i?"":e[0]+" ";d<s;++d)t[d]=n(e,t[d],a).trim();break;default:var u=d=0;for(t=[];d<s;++d)for(var o=0;o<i;++o)t[u++]=n(e[o]+" ",r[d],a).trim()}return t}function n(e,t,a){var n=t.charCodeAt(0);switch(33>n&&(n=(t=t.trim()).charCodeAt(0)),n){case 38:return t.replace(f,"$1"+e.trim());case 58:return e.trim()+t.replace(f,"$1"+e.trim());default:if(0<1*a&&0<t.indexOf("\f"))return t.replace(f,(58===e.charCodeAt(0)?"":"$1")+e.trim())}return e+t}function r(e,t,a,n){var i=e+";",d=2*t+3*a+4*n;if(944===d){e=i.indexOf(":",9)+1;var u=i.substring(e,i.length-1).trim();return u=i.substring(0,e).trim()+u+";",1===C||2===C&&s(u,1)?"-webkit-"+u+u:u}if(0===C||2===C&&!s(i,1))return i;switch(d){case 1015:return 97===i.charCodeAt(10)?"-webkit-"+i+i:i;case 951:return 116===i.charCodeAt(3)?"-webkit-"+i+i:i;case 963:return 110===i.charCodeAt(5)?"-webkit-"+i+i:i;case 1009:if(100!==i.charCodeAt(4))break;case 969:case 942:return"-webkit-"+i+i;case 978:return"-webkit-"+i+"-moz-"+i+i;case 1019:case 983:return"-webkit-"+i+"-moz-"+i+"-ms-"+i+i;case 883:if(45===i.charCodeAt(8))return"-webkit-"+i+i;if(0<i.indexOf("image-set(",11))return i.replace(F,"$1-webkit-$2")+i;break;case 932:if(45===i.charCodeAt(4))switch(i.charCodeAt(5)){case 103:return"-webkit-box-"+i.replace("-grow","")+"-webkit-"+i+"-ms-"+i.replace("grow","positive")+i;case 115:return"-webkit-"+i+"-ms-"+i.replace("shrink","negative")+i;case 98:return"-webkit-"+i+"-ms-"+i.replace("basis","preferred-size")+i}return"-webkit-"+i+"-ms-"+i+i;case 964:return"-webkit-"+i+"-ms-flex-"+i+i;case 1023:if(99!==i.charCodeAt(8))break;return"-webkit-box-pack"+(u=i.substring(i.indexOf(":",15)).replace("flex-","").replace("space-between","justify"))+"-webkit-"+i+"-ms-flex-pack"+u+i;case 1005:return m.test(i)?i.replace(l,":-webkit-")+i.replace(l,":-moz-")+i:i;case 1e3:switch(t=(u=i.substring(13).trim()).indexOf("-")+1,u.charCodeAt(0)+u.charCodeAt(t)){case 226:u=i.replace(y,"tb");break;case 232:u=i.replace(y,"tb-rl");break;case 220:u=i.replace(y,"lr");break;default:return i}return"-webkit-"+i+"-ms-"+u+i;case 1017:if(-1===i.indexOf("sticky",9))break;case 975:switch(t=(i=e).length-10,d=(u=(33===i.charCodeAt(t)?i.substring(0,t):i).substring(e.indexOf(":",7)+1).trim()).charCodeAt(0)+(0|u.charCodeAt(7))){case 203:if(111>u.charCodeAt(8))break;case 115:i=i.replace(u,"-webkit-"+u)+";"+i;break;case 207:case 102:i=i.replace(u,"-webkit-"+(102<d?"inline-":"")+"box")+";"+i.replace(u,"-webkit-"+u)+";"+i.replace(u,"-ms-"+u+"box")+";"+i}return i+";";case 938:if(45===i.charCodeAt(5))switch(i.charCodeAt(6)){case 105:return u=i.replace("-items",""),"-webkit-"+i+"-webkit-box-"+u+"-ms-flex-"+u+i;case 115:return"-webkit-"+i+"-ms-flex-item-"+i.replace(S,"")+i;default:return"-webkit-"+i+"-ms-flex-line-pack"+i.replace("align-content","").replace(S,"")+i}break;case 973:case 989:if(45!==i.charCodeAt(3)||122===i.charCodeAt(4))break;case 931:case 953:if(!0===x.test(e))return 115===(u=e.substring(e.indexOf(":")+1)).charCodeAt(0)?r(e.replace("stretch","fill-available"),t,a,n).replace(":fill-available",":stretch"):i.replace(u,"-webkit-"+u)+i.replace(u,"-moz-"+u.replace("fill-",""))+i;break;case 962:if(i="-webkit-"+i+(102===i.charCodeAt(5)?"-ms-"+i:"")+i,211===a+n&&105===i.charCodeAt(13)&&0<i.indexOf("transform",10))return i.substring(0,i.indexOf(";",27)+1).replace(b,"$1-webkit-$2")+i}return i}function s(e,t){var a=e.indexOf(1===t?":":"{"),n=e.substring(0,3!==t?a:10);return a=e.substring(a+1,e.length-1),U(2!==t?n:n.replace(M,"$1"),a,t)}function i(e,t){var a=r(t,t.charCodeAt(0),t.charCodeAt(1),t.charCodeAt(2));return a!==t+";"?a.replace(A," or ($1)").substring(4):"("+t+")"}function d(e,t,a,n,r,s,i,d,u,c){for(var p,l=0,m=t;l<T;++l)switch(p=D[l].call(o,e,m,a,n,r,s,i,d,u,c)){case void 0:case!1:case!0:case null:break;default:m=p}if(m!==t)return m}function u(e){return void 0!==(e=e.prefix)&&(U=null,e?"function"!=typeof e?C=1:(C=2,U=e):C=0),u}function o(e,a){var n=e;if(33>n.charCodeAt(0)&&(n=n.trim()),n=[n],0<T){var r=d(-1,a,n,n,v,N,0,0,0,0);void 0!==r&&"string"==typeof r&&(a=r)}var s=t(z,n,a,0,0);return 0<T&&(void 0!==(r=d(-2,s,n,n,v,N,s.length,0,0,0))&&(s=r)),"",O=0,N=v=1,s}var c=/^\0+/g,p=/[\0\r\f]/g,l=/: */g,m=/zoo|gra/,b=/([,: ])(transform)/g,h=/,\r+?/g,f=/([\t\r\n ])*\f?&/g,k=/@(k\w+)\s*(\S*)\s*/,g=/::(place)/g,w=/:(read-only)/g,y=/[svh]\w+-[tblr]{2}/,I=/\(\s*(.*)\s*\)/g,A=/([\s\S]*?);/g,S=/-self|flex-/g,M=/[^]*?(:[rp][el]a[\w-]+)[^]*/,x=/stretch|:\s*\w+\-(?:conte|avail)/,F=/([^-])(image-set\()/,N=1,v=1,O=0,C=1,z=[],D=[],T=0,U=null,W=0;return o.use=function e(t){switch(t){case void 0:case null:T=D.length=0;break;default:if("function"==typeof t)D[T++]=t;else if("object"==typeof t)for(var a=0,n=t.length;a<n;++a)e(t[a]);else W=0|!!t}return e},o.set=u,void 0!==e&&u(e),o}},561:function(e,t,a){"use strict";t.a={animationIterationCount:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1}},660:function(e,t,a){e.exports=a(586)}}]);
//# sourceMappingURL=bundle~bundle~748942c6.5037132a.js.map