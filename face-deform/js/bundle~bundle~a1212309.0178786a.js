/*! For license information please see bundle~bundle~a1212309.0178786a.js.LICENSE.txt */
(("undefined"!=typeof self?self:this).webpackJsonp=("undefined"!=typeof self?self:this).webpackJsonp||[]).push([[10],{10:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(4);const i=Object(c.a)({cast_:function(t,e){const n=Object(s.a)(t,"x","cast");if(!o.isValidDtype(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const c={x:n},i={dtype:e};return r.a.runKernelFunc((t=>t.cast(n,e)),c,null,a.v,i)}})},100:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),o=n(62),c=n(4),i=n(7);const u=Object(c.a)({broadcastTo_:function(t,e){let n=Object(s.a)(t,"broadcastTo","x");const c=n.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=Object(i.a)(n,t)}const u=n.shape,l=Array.from(e);for(let t=e.length-1;t>=0;t--)if(u[t]===e[t])l[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${c}] cannot be broadcast to [${e}].`);if(0===l.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return Object(o.a)(n);const h={x:n},p={shape:e,inputShape:u};return r.a.runKernelFunc((t=>t.tile(n,l)),h,null,a.u,p)}})},11:function(t,e,n){"use strict";function r(t,e){const n=t.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,o=t[s]||1;(e[e.length-1-a]||1)>1&&1===o&&r.unshift(s)}return r}function a(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function s(t,e){const n=[],r=Math.max(t.length,e.length);for(let a=0;a<r;a++){let r=t[t.length-a-1];null==r&&(r=1);let s=e[e.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}n.unshift(r)}}return n}n.d(e,"b",(function(){return r})),n.d(e,"c",(function(){return a})),n.d(e,"a",(function(){return s}))},118:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({elu_:function(t){const e=Object(s.a)(t,"x","elu"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.elu(e);return n([r]),r}),n,null,a.S)}})},121:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),o=n(18),c=n(4),i=n(23);const u=Object(c.a)({cumsum_:function(t,e=0,n=!1,c=!1){const u=Object(s.a)(t,"x","cumsum"),l={x:u},h={axis:e,exclusive:n,reverse:c};return r.a.runKernelFunc(((t,r)=>{const a=Object(o.f)([e],u.rank);let s=u;null!=a&&(s=Object(i.a)(u,a));const l=Object(o.g)(1,u.rank)[0];let h=t.cumsum(s,l,n,c);if(r([u]),null!=a){const t=Object(o.h)(a);h=Object(i.a)(h,t)}return h}),l,null,a.J,h)}})},123:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({cos_:function(t){const e=Object(s.a)(t,"x","cos"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.cos(e);return n([e]),r}),n,null,a.G)}})},127:function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(10),i=n(16),u=n(4),l=n(7);const h=Object(u.a)({avgPool_:function(t,e,n,u,h){const p=Object(s.a)(t,"x","avgPool","float32");o.assert(i.h(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let d=p,f=!1;3===p.rank&&(f=!0,d=Object(l.a)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),o.assert(4===d.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${d.rank}.`)),null!=h&&o.assert(o.isInt(u),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${h} but got pad ${u}.`));const b={x:d},O={filterSize:e,strides:n,pad:u,dimRoundingMode:h};let j=r.a.runKernelFunc(((t,r)=>{const a=i.e(d.shape,e,n,1,u,h);return r([d]),1===a.filterWidth&&1===a.filterHeight&&o.arraysEqual(a.inShape,a.outShape)?d.clone():t.avgPool(d,a)}),b,null,a.o,O);return j=Object(c.a)(j,p.dtype),f?Object(l.a)(j,[j.shape[1],j.shape[2],j.shape[3]]):j}})},130:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(0),o=n(16),c=n(4),i=n(7);const u=Object(c.a)({conv2DBackpropInput_:function(t,e,n,c,u,l="NHWC",h){s.assert(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let p=t,d=e,f=!1;3===e.rank&&(f=!0,d=Object(i.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]),p=[1,t[0],t[1],t[2]]),s.assert(4===p.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${p.length}.`)),s.assert(4===d.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${d.rank}`)),s.assert(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const b="NHWC"===l?p[3]:p[1],O="NHWC"===l?d.shape[3]:d.shape[1];s.assert(b===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${b}) must match input depth for filter ${n.shape[2]}.`)),s.assert(O===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${O}) must match output depth for filter ${n.shape[3]}.`)),null!=h&&s.assert(s.isInt(u),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${h} but got pad ${u}.`));const j={dy:d,filter:n},m={strides:c,pad:u,dataFormat:l,dimRoundingMode:h,inputShape:p},g=r.a.runKernelFunc(((t,e)=>{const r=o.g(l),a=o.a(p,n.shape,c,1,u,h,!1,r),s=t.conv2dDerInput(d,n,a);return e([d,n]),s}),j,null,a.C,m);return f?Object(i.a)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},131:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(0),o=n(16),c=n(4),i=n(7);const u=Object(c.a)({conv2DBackpropFilter_:function(t,e,n,c,u,l="NHWC",h){let p=t;3===t.rank&&(p=Object(i.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d=e;3===d.rank&&(d=Object(i.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]])),s.assert(4===p.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${p.shape}.`)),s.assert(4===d.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${d.shape}.`)),s.assert(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const f="NHWC"===l?p.shape[3]:p.shape[1],b="NHWC"===l?d.shape[3]:d.shape[1];s.assert(f===n[2],(()=>`Error in conv2dDerFilter: depth of input ${f}) must match input depth in filter (${n[2]}.`)),s.assert(b===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${b}) must match output depth for filter (${n[3]}).`)),null!=h&&s.assert(s.isInt(u),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${h} but got pad ${u}.`));const O={x:p,dy:d},j={strides:c,pad:u,dataFormat:l,dimRoundingMode:h};return r.a.runKernelFunc((t=>{const e=o.g(l),r=o.a(p.shape,n,c,1,u,h,!1,e);return t.conv2dDerFilter(p,d,r)}),O,null,a.B,j)}})},145:function(t,e,n){"use strict";n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return s}));var r=n(0);function a(t,e){const n=t[0].length;t.forEach(((t,e)=>{r.assert(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`))})),r.assert(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const a=t[0];t.forEach(((t,s)=>{for(let o=0;o<n;o++)r.assert(o===e||t[o]===a[o],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`))}))}function s(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}},16:function(t,e,n){"use strict";n.d(e,"d",(function(){return a})),n.d(e,"e",(function(){return s})),n.d(e,"f",(function(){return o})),n.d(e,"a",(function(){return c})),n.d(e,"b",(function(){return i})),n.d(e,"c",(function(){return u})),n.d(e,"i",(function(){return f})),n.d(e,"h",(function(){return b})),n.d(e,"g",(function(){return O}));var r=n(0);function a(t,e,n,r,a="NHWC",s){return c(t,[...e,t[3]],n,s,r,null,null,O(a))}function s(t,e,n,r,a,s,o="channelsLast"){const[i,u]=l(e);let h;if("channelsLast"===o)h=[i,u,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);h=[i,u,t[1],t[1]]}return c(t,h,n,r,a,s,!1,o)}function o(t,e,n,r,a,s,o="NDHWC"){const[c,u,l]=h(e);let p,d;if("NDHWC"===o)d="channelsLast",p=[c,u,l,t[4],t[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",p=[c,u,l,t[1],t[1]]}return i(t,p,n,r,a,!1,d,s)}function c(t,e,n,a,s,o,c=!1,i="channelsLast"){let[h,f,b,O]=[-1,-1,-1,-1];if("channelsLast"===i)[h,f,b,O]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[h,O,f,b]=t}const[j,m,,g]=e,[v,k]=l(n),[$,x]=l(a),E=p(j,$),w=p(m,x),{padInfo:S,outHeight:y,outWidth:F}=function(t,e,n,a,s,o,c,i,l){let h,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,a,s){null==a&&(a=u(t,e,n));const o=t[0],c=t[1],i=d((o-e+2*a)/n+1,s);r.assert(r.isInt(i),(()=>`The output # of rows (${i}) must be an integer. Change the stride and/or zero pad parameters`));const l=d((c-e+2*a)/n+1,s);return r.assert(r.isInt(l),(()=>`The output # of columns (${l}) must be an integer. Change the stride and/or zero pad parameters`)),[i,l]}([e,n],o,a,t,i);p=s[0],f=s[1]}else if("same"===t){p=Math.ceil(e/a),f=Math.ceil(n/s);const t=Math.max(0,(p-1)*a+o-e),r=Math.max(0,(f-1)*s+c-n),i=Math.floor(t/2),u=t-i,l=Math.floor(r/2);h={top:i,bottom:u,left:l,right:r-l,type:"SAME"}}else if("valid"===t)h={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-o+1)/a),f=Math.ceil((n-c+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const r="channelsLast"===l?t[1][0]:t[2][0],u="channelsLast"===l?t[1][1]:t[2][1],b="channelsLast"===l?t[2][0]:t[3][0],O="channelsLast"===l?t[2][1]:t[3][1];h={top:r,bottom:u,left:b,right:O,type:0===r&&0===u&&0===b&&0===O?"VALID":"EXPLICIT"},p=d((e-o+r+u)/a+1,i),f=d((n-c+b+O)/s+1,i)}}return{padInfo:h,outHeight:p,outWidth:f}}(s,f,b,v,k,E,w,o,i),D=c?g*O:g;let M;return"channelsFirst"===i?M=[h,D,y,F]:"channelsLast"===i&&(M=[h,y,F,D]),{batchSize:h,dataFormat:i,inHeight:f,inWidth:b,inChannels:O,outHeight:y,outWidth:F,outChannels:D,padInfo:S,strideHeight:v,strideWidth:k,filterHeight:j,filterWidth:m,effectiveFilterHeight:E,effectiveFilterWidth:w,dilationHeight:$,dilationWidth:x,inShape:t,outShape:M,filterShape:e}}function i(t,e,n,a,s,o=!1,c="channelsLast",i){let[l,f,b,O,j]=[-1,-1,-1,-1,-1];if("channelsLast"===c)[l,f,b,O,j]=t;else{if("channelsFirst"!==c)throw new Error(`Unknown dataFormat ${c}`);[l,j,f,b,O]=t}const[m,g,v,,k]=e,[$,x,E]=h(n),[w,S,y]=h(a),F=p(m,w),D=p(g,S),M=p(v,y),{padInfo:_,outDepth:I,outHeight:C,outWidth:H}=function(t,e,n,a,s,o,c,i,l,h,p){let f,b,O,j;if("number"==typeof t){f={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const o=function(t,e,n,a,s,o){null==s&&(s=u(t,e,a));const c=t[0],i=t[1],l=t[2],h=d((c-e+2*s)/a+1,o);r.assert(r.isInt(h),(()=>`The output # of depths (${h}) must be an integer. Change the stride and/or zero pad parameters`));const p=d((i-e+2*s)/a+1,o);r.assert(r.isInt(p),(()=>`The output # of rows (${p}) must be an integer. Change the stride and/or zero pad parameters`));const f=d((l-e+2*s)/a+1,o);return r.assert(r.isInt(f),(()=>`The output # of columns (${f}) must be an integer. Change the stride and/or zero pad parameters`)),[h,p,f,n]}([e,n,a,1],i,1,s,t,p);b=o[0],O=o[1],j=o[2]}else if("same"===t){b=Math.ceil(e/s),O=Math.ceil(n/o),j=Math.ceil(a/c);const t=(b-1)*s+i-e,r=(O-1)*o+l-n,u=(j-1)*c+h-a,p=Math.floor(t/2),d=t-p,m=Math.floor(r/2),g=r-m,v=Math.floor(u/2);f={top:m,bottom:g,left:v,right:u-v,front:p,back:d,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);f={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},b=Math.ceil((e-i+1)/s),O=Math.ceil((n-l+1)/o),j=Math.ceil((a-h+1)/c)}return{padInfo:f,outDepth:b,outHeight:O,outWidth:j}}(s,f,b,O,$,x,E,F,D,M,i),N=o?k*j:k;let K;return"channelsFirst"===c?K=[l,N,I,C,H]:"channelsLast"===c&&(K=[l,I,C,H,N]),{batchSize:l,dataFormat:c,inDepth:f,inHeight:b,inWidth:O,inChannels:j,outDepth:I,outHeight:C,outWidth:H,outChannels:N,padInfo:_,strideDepth:$,strideHeight:x,strideWidth:E,filterDepth:m,filterHeight:g,filterWidth:v,effectiveFilterDepth:F,effectiveFilterHeight:D,effectiveFilterWidth:M,dilationDepth:w,dilationHeight:S,dilationWidth:y,inShape:t,outShape:K,filterShape:e}}function u(t,e,n,r=1){const a=p(e,r);return Math.floor((t[0]*(n-1)-n+a)/2)}function l(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function h(t){return"number"==typeof t?[t,t,t]:t}function p(t,e){return e<=1?t:t+(t-1)*(e-1)}function d(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function f(t){const[e,n,r]=l(t);return 1===e&&1===n&&1===r}function b(t,e){return f(t)||f(e)}function O(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}},167:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(81),a=n(44),s=n(4),o=n(7),c=n(79);const i=Object(s.a)({eye_:function(t,e,n,s="float32"){null==e&&(e=t);const i=Object(r.a)([t,e],s),u=t<=e?t:e;for(let t=0;t<u;++t)i.set(1,t,t);const l=Object(o.a)(i.toTensor(),[t,e]);if(null==n)return l;if(1===n.length)return Object(c.a)(Object(a.a)(l,0),[n[0],1,1]);if(2===n.length)return Object(c.a)(Object(a.a)(Object(a.a)(l,0),0),[n[0],n[1],1,1]);if(3===n.length)return Object(c.a)(Object(a.a)(Object(a.a)(Object(a.a)(l,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}})},17:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(19),o=n(3),c=n(110),i=n(4);const u=Object(i.a)({div_:function(t,e){let n=Object(o.a)(t,"a","div"),i=Object(o.a)(e,"b","div");if([n,i]=Object(s.b)(n,i),"int32"===n.dtype&&"int32"===i.dtype)return Object(c.a)(n,i);const u={a:n,b:i};return r.a.runKernelFunc(((t,e)=>{const r=t.realDivide(n,i);return e([n,i]),r}),u,null,a.R,{})}})},176:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({cosh_:function(t){const e=Object(s.a)(t,"x","cosh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.cosh(e);return n([e]),r}),n,null,a.H)}})},177:function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(18),i=n(4),u=n(7),l=n(23);const h=Object(i.a)({all_:function(t,e=null,n=!1){let i=Object(s.a)(t,"x","all","bool");const h={x:i},p={axis:e,keepDims:n};return r.a.runKernelFunc((t=>{const r=Object(o.parseAxisParam)(e,i.shape);let a=r;const s=Object(c.f)(a,i.rank);null!=s&&(i=Object(l.a)(i,s),a=Object(c.g)(a.length,i.rank));const h=t.all(i,a);if(n){const t=Object(c.e)(h.shape,r);return Object(u.a)(h,t)}return h}),h,null,a.f,p)}})},178:function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(18),i=n(4),u=n(7),l=n(23);const h=Object(i.a)({any_:function(t,e=null,n=!1){let i=Object(s.a)(t,"x","any","bool");const h={x:i},p={axis:e,keepDims:n};return r.a.runKernelFunc((t=>{const r=Object(o.parseAxisParam)(e,i.shape);let a=r;const s=Object(c.f)(a,i.rank);null!=s&&(i=Object(l.a)(i,s),a=Object(c.g)(a.length,i.rank));const h=t.any(i,a);if(n){const t=Object(c.e)(h.shape,r);return Object(u.a)(h,t)}return h}),h,null,a.g,p)}})},179:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(18),i=n(4),u=n(23);const l=Object(i.a)({argMax_:function(t,e=0){let n=Object(s.a)(t,"x","argMax");const i={x:n},l={axis:e};return r.a.runKernelFunc(((t,r)=>{r([n]);let a=o.parseAxisParam(e,n.shape);const s=c.f(a,n.rank);return null!=s&&(n=Object(u.a)(n,s),a=c.g(a.length,n.rank)),t.argMax(n,a[0])}),i,null,a.h,l)}})},18:function(t,e,n){"use strict";n.d(e,"b",(function(){return a})),n.d(e,"c",(function(){return s})),n.d(e,"d",(function(){return o})),n.d(e,"e",(function(){return c})),n.d(e,"a",(function(){return i})),n.d(e,"f",(function(){return u})),n.d(e,"h",(function(){return l})),n.d(e,"g",(function(){return h}));var r=n(0);function a(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function s(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let c=0;c<r;c++)-1===n.indexOf(c)?a.push(t[s++]):a.push(e[o++]);return a}function o(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}function c(t,e){return s(t,e.map((t=>1)),e)}function i(t,e,n){r.assert(a(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function u(t,e){if(a(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function l(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function h(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}},180:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(18),i=n(4),u=n(23);const l=Object(i.a)({argMin_:function(t,e=0){let n=Object(s.a)(t,"x","argMin");const i={x:n},l={axis:e};return r.a.runKernelFunc(((t,r)=>{r([n]),null==e&&(e=0);let a=o.parseAxisParam(e,n.shape);const s=c.f(a,n.rank);return null!=s&&(n=Object(u.a)(n,s),a=c.g(a.length,n.rank)),t.argMin(n,a[0])}),i,null,a.i,l)}})},181:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(19),o=n(3),c=n(4);const i=Object(c.a)({atan2_:function(t,e){let n=Object(o.a)(t,"a","atan2"),c=Object(o.a)(e,"b","atan2");[n,c]=Object(s.b)(n,c);const i={a:n,b:c};return r.a.runKernelFunc(((t,e)=>{const r=t.atan2(n,c);return e([n,c]),r}),i,null,a.m)}})},182:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(3),a=n(0),s=n(61),o=n(16),c=n(4),i=n(7);const u=Object(c.a)({conv1d_:function(t,e,n,c,u="NWC",l=1,h){const p=Object(r.a)(t,"x","conv1d"),d=Object(r.a)(e,"filter","conv1d");let f=p,b=!1;2===p.rank&&(b=!0,f=Object(i.a)(p,[1,p.shape[0],p.shape[1]])),a.assert(3===f.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`)),a.assert(3===d.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${d.rank}.`)),null!=h&&a.assert(a.isInt(c),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${h} but got pad ${c}.`)),a.assert(f.shape[2]===d.shape[1],(()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${d.shape[1]}.`)),a.assert(o.h(n,l),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${l}'`)),a.assert("NWC"===u,(()=>`Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`));const O=Object(i.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),j=Object(i.a)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),m=[1,n],g=[1,l],v=Object(s.a)(j,O,m,c,"NHWC",g,h);return b?Object(i.a)(v,[v.shape[2],v.shape[3]]):Object(i.a)(v,[v.shape[0],v.shape[2],v.shape[3]])}})},183:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(3),a=n(130),s=n(4);const o=Object(s.a)({conv2dTranspose_:function(t,e,n,s,o,c){const i=Object(r.a)(t,"x","conv2dTranspose"),u=Object(r.a)(e,"filter","conv2dTranspose");return Object(a.a)(n,i,u,s,o,"NHWC",c)}})},184:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(4);const i=Object(c.a)({depthToSpace_:function(t,e,n="NHWC"){const c=Object(s.a)(t,"x","depthToSpace"),i="NHWC"===n?c.shape[1]:c.shape[2],u="NHWC"===n?c.shape[2]:c.shape[3],l="NHWC"===n?c.shape[3]:c.shape[1];o.assert(i*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e}  for depthToSpace with input shape\n    ${c.shape}`)),o.assert(u*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${e} for depthToSpace with input shape\n        ${c.shape}`)),o.assert(l%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${l} for depthToSpace with input shape ${c.shape}`));const h={x:c},p={blockSize:e,dataFormat:n};return r.a.runKernelFunc((t=>t.depthToSpace(c,e,n)),h,null,a.K,p)}})},185:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(4),i=n(7);const u=Object(c.a)({dilation2d_:function(t,e,n,c,u=[1,1],l="NHWC"){const h=Object(s.a)(t,"x","dilation2d"),p=Object(s.a)(e,"filter","dilation2d");o.assert(3===h.rank||4===h.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${h.rank}.`)),o.assert(3===p.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${p.rank}.`)),o.assert("NHWC"===l,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${l}`));let d=h,f=!1;3===h.rank&&(d=Object(i.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),f=!0);const b={x:d,filter:p},O={strides:n,pad:c,dilations:u},j=r.a.runKernel(a.O,b,O);return f?Object(i.a)(j,[j.shape[1],j.shape[2],j.shape[3]]):j}})},186:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(19),a=n(3),s=n(17),o=n(76),c=n(4),i=n(34),u=n(21);const l=Object(c.a)({divNoNan_:function(t,e){let n=Object(a.a)(t,"a","div"),c=Object(a.a)(e,"b","div");[n,c]=Object(r.b)(n,c);const l=Object(s.a)(n,c),h=Object(u.a)(l),p=Object(o.a)(c,h);return Object(i.a)(p,h,l)}})},187:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(3),a=n(0),s=n(24),o=n(4),c=n(7);const i=Object(o.a)({dot_:function(t,e){const n=Object(r.a)(t,"t1","dot"),o=Object(r.a)(e,"t2","dot");a.assert(!(1!==n.rank&&2!==n.rank||1!==o.rank&&2!==o.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${o.rank}.`));const i=1===n.rank?n.size:n.shape[1],u=1===o.rank?o.size:o.shape[0];if(a.assert(i===u,(()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${u}.`)),1===n.rank&&1===o.rank){const t=Object(c.a)(n,[1,-1]),e=Object(c.a)(o,[-1,1]),r=Object(s.a)(t,e);return Object(c.a)(r,[])}if(1===n.rank&&2===o.rank){const t=Object(c.a)(n,[1,-1]),e=Object(c.a)(o,[o.shape[0],o.shape[1]]),r=Object(s.a)(t,e);return Object(c.a)(r,[r.size])}if(2===n.rank&&1===o.rank){const t=Object(c.a)(o,[-1,1]),e=Object(s.a)(n,t);return Object(c.a)(e,[e.size])}{const t=Object(c.a)(o,[o.shape[0],o.shape[1]]);return Object(s.a)(n,t)}}})},198:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(7);var i=n(4);function u(t){return null==t?null:0===t.rank?Object(c.a)(t,[t.size]):1===t.rank?t:2===t.rank?Object(c.a)(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Object(c.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t}const l=Object(i.a)({batchNorm_:function(t,e,n,i,l,h){null==h&&(h=.001);const p=Object(s.a)(t,"x","batchNorm"),d=Object(s.a)(e,"mean","batchNorm"),f=Object(s.a)(n,"variance","batchNorm");let b,O;null!=l&&(b=Object(s.a)(l,"scale","batchNorm")),null!=i&&(O=Object(s.a)(i,"offset","batchNorm")),o.assert(d.rank===f.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),o.assert(null==O||d.rank===O.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),o.assert(null==b||d.rank===b.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const j=function(t){let e;return e=0===t.rank||1===t.rank?Object(c.a)(t,[1,1,1,t.size]):2===t.rank?Object(c.a)(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Object(c.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(p),m={x:j,scale:b,offset:O,mean:d,variance:f},g={varianceEpsilon:h},v=r.a.runKernelFunc(((t,e)=>(e([j,d,f,b]),t.batchNorm(j,u(d),u(f),u(O),u(b),h))),m,null,a.eb,g);return Object(c.a)(v,p.shape)}})},203:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(4),o=n(7);const c=Object(s.a)({depthwiseConv2dNativeBackpropInput_:function(t,e,n,s){let c=e,i=!1;3===e.rank&&(i=!0,c=Object(o.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:c},l=r.a.runKernelFunc((t=>t.depthwiseConv2DDerInput(c,n,s)),u,null,a.N);return i?Object(o.a)(l,[l.shape[1],l.shape[2],l.shape[3]]):l}})},204:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(4),o=n(7);const c=Object(s.a)({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,s){let c=t;3===t.rank&&(c=Object(o.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let i=e;3===i.rank&&(i=Object(o.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:c,dy:i};return r.a.runKernelFunc((t=>t.depthwiseConv2DDerFilter(c,i,s)),u,null,a.M)}})},22:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(19),o=n(3),c=n(4);const i=Object(c.a)({add_:function(t,e){let n=Object(o.a)(t,"a","add"),c=Object(o.a)(e,"b","add");[n,c]=Object(s.b)(n,c);const i={a:n,b:c};return r.a.runKernelFunc(((t,e)=>{const r=t.add(n,c);return e([n,c]),r}),i,null,a.d)}})},270:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var r=n(30),a=n(4);const s=Object(a.a)({concat2d_:function(t,e){return Object(r.a)(t,e)}})},271:function(t,e,n){"use strict";n.r(e),n.d(e,"toPixels",(function(){return p})),n.d(e,"fromPixels",(function(){return d}));var r=n(5),a=n(2),s=n(65),o=n(6),c=n(3),i=n(10),u=n(4),l=n(169);let h;async function p(t,e){let n=Object(c.a)(t,"img","toPixels");if(!(t instanceof o.a)){const t=n;n=Object(i.a)(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const u=await n.data(),l="float32"===n.dtype?255:1,h=new Uint8ClampedArray(a*r*4);for(let t=0;t<r*a;++t){const e=[0,0,0,255];for(let r=0;r<s;r++){const a=u[t*s+r];if("float32"===n.dtype){if(a<0||a>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${a}.`)}else if("int32"===n.dtype&&(a<0||a>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${a}.`);1===s?(e[0]=a*l,e[1]=a*l,e[2]=a*l):e[r]=a*l}const r=4*t;h[r+0]=Math.round(e[0]),h[r+1]=Math.round(e[1]),h[r+2]=Math.round(e[2]),h[r+3]=Math.round(e[3])}if(null!=e){e.width=a,e.height=r;const t=e.getContext("2d"),n=new ImageData(h,a,r);t.putImageData(n,0,0)}return n!==t&&n.dispose(),h}const d=Object(u.a)({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,o=!1,c=!1,i=!1,u=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)o=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)c=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)i=!0;else{if(null==t.getContext)throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);u=!0}if(c){const e=2;if(c&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Object(s.b)(a.db,r.a.backendName)){const n={pixels:t},s={numChannels:e};return r.a.runKernel(a.db,n,s)}const[p,d]=c?[t.videoWidth,t.videoHeight]:[t.width,t.height];let f,b;if(u?f=t.getContext("2d").getImageData(0,0,p,d).data:o||n?f=t.data:(i||c)&&(null==h&&(h=document.createElement("canvas").getContext("2d")),h.canvas.width=p,h.canvas.height=d,h.drawImage(t,0,0,p,d),f=h.getImageData(0,0,p,d).data),4===e)b=new Int32Array(f);else{const t=p*d;b=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)b[n*e+t]=f[4*n+t]}const O=[d,p,e];return Object(l.a)(b,O,"int32")}})},273:function(t,e,n){"use strict";function r(t,e,n,r=!0){let a=[];if(r)a=a.concat(e.slice(0)),a.push(t[0]/n),a=a.concat(t.slice(1));else{a=a.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)a=a.concat([t[r+1]/e[r],e[r]]);a=a.concat(t.slice(n+1))}return a}function a(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],a=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function s(t,e,n,r=!0){const a=[];r?a.push(t[0]/n):a.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?a.push(e[n-1]*t[n]):a.push(t[n]/e[n-1]):a.push(t[n]);return a}function o(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function c(t,e,n){const r=t.slice(0,1);for(let a=0;a<n;++a)r.push(t[a+1]-e[a][0]-e[a][1]);return r}n.d(e,"b",(function(){return r})),n.d(e,"a",(function(){return a})),n.d(e,"c",(function(){return s})),n.d(e,"d",(function(){return o})),n.d(e,"e",(function(){return c}))},274:function(t,e,n){"use strict";n.d(e,"f",(function(){return r})),n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return s})),n.d(e,"c",(function(){return o})),n.d(e,"d",(function(){return c})),n.d(e,"e",(function(){return i}));const r=.3275911,a=.254829592,s=-.284496736,o=1.421413741,c=-1.453152027,i=1.061405429},275:function(t,e,n){"use strict";n.d(e,"b",(function(){return a})),n.d(e,"a",(function(){return s}));var r=n(20);function a(...t){Object(r.b)().getBool("IS_TEST")||console.warn(...t)}function s(...t){Object(r.b)().getBool("IS_TEST")||console.log(...t)}},276:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({acos_:function(t){const e=Object(s.a)(t,"x","acos"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.acos(e);return n([e]),r}),n,null,a.b)}})},277:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({acosh_:function(t){const e=Object(s.a)(t,"x","acosh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.acosh(e);return n([e]),r}),n,null,a.c)}})},278:function(t,e,n){"use strict";n.d(e,"a",(function(){return O})),n.d(e,"b",(function(){return j})),n.d(e,"c",(function(){return m})),n.d(e,"d",(function(){return g})),n.d(e,"e",(function(){return v})),n.d(e,"f",(function(){return k})),n.d(e,"g",(function(){return $})),n.d(e,"h",(function(){return x})),n.d(e,"i",(function(){return E}));var r=n(29),a=n(3),s=n(0),o=n(22),c=n(17),i=n(77),u=n(90),l=n(126),h=n(9),p=n(4),d=n(60),f=n(91),b=n(15);const O=Object(p.a)({addStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","addStrict"),c=Object(a.a)(e,"b","addStrict");return s.assertShapesMatch(n.shape,c.shape,"Error in addStrict: "),Object(o.a)(n,c)}}),j=Object(p.a)({divStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","div"),o=Object(a.a)(e,"b","div");return s.assertShapesMatch(n.shape,o.shape,"Error in divideStrict: "),Object(c.a)(n,o)}}),m=Object(p.a)({maximumStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","maximumStrict"),o=Object(a.a)(e,"b","maximumStrict");return s.assertShapesMatch(n.shape,o.shape,"Error in maximumStrict: "),Object(i.a)(n,o)}}),g=Object(p.a)({minimumStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","minimumStrict"),o=Object(a.a)(e,"b","minimumStrict");return s.assertShapesMatch(n.shape,o.shape,"Error in minimumStrict: "),Object(u.a)(n,o)}}),v=Object(p.a)({modStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","modStrict"),o=Object(a.a)(e,"b","modStrict");return s.assertShapesMatch(n.shape,o.shape,"Error in modStrict: "),Object(l.a)(n,o)}}),k=Object(p.a)({mulStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","mul"),o=Object(a.a)(e,"b","mul");return s.assertShapesMatch(n.shape,o.shape,"Error in multiplyStrict: "),Object(h.a)(n,o)}}),$=Object(p.a)({powStrict_:function(t,e){return Object(r.a)("strict variants of ops have been deprecated and will be removed in future"),s.assertShapesMatch(t.shape,e.shape,"Error in powStrict: "),Object(d.a)(t,e)}}),x=Object(p.a)({squaredDifferenceStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","squaredDifferenceStrict"),o=Object(a.a)(e,"b","squaredDifferenceStrict");return s.assertShapesMatch(n.shape,o.shape,"Error in squaredDifferenceStrict: "),Object(f.a)(n,o)}}),E=Object(p.a)({subStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","subStrict"),o=Object(a.a)(e,"b","subStrict");return s.assertShapesMatch(n.shape,o.shape,"Error in subStrict: "),Object(b.a)(n,o)}})},279:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({asin_:function(t){const e=Object(s.a)(t,"x","asin"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.asin(e);return n([e]),r}),n,null,a.j)}})},280:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({asinh_:function(t){const e=Object(s.a)(t,"x","asinh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.asinh(e);return n([e]),r}),n,null,a.k)}})},281:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({atan_:function(t){const e=Object(s.a)(t,"x","atan"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.atan(e);return n([e]),r}),n,null,a.l)}})},282:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({atanh_:function(t){const e=Object(s.a)(t,"x","atanh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.atanh(e);return n([e]),r}),n,null,a.n)}})},283:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({ceil_:function(t){const e=Object(s.a)(t,"x","ceil"),n={x:e};return r.a.runKernelFunc((t=>t.ceil(e)),n,null,a.w)}})},284:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(4);const i=Object(c.a)({clipByValue_:function(t,e,n){const c=Object(s.a)(t,"x","clipByValue");o.assert(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`));const i={x:c},u={clipValueMin:e,clipValueMax:n};return r.a.runKernelFunc(((t,r)=>{const a=t.clip(c,e,n);return r([c]),a}),i,null,a.x,u)}})},285:function(t,e,n){"use strict";n.d(e,"a",(function(){return d})),n.d(e,"b",(function(){return f})),n.d(e,"c",(function(){return b})),n.d(e,"d",(function(){return O})),n.d(e,"e",(function(){return j})),n.d(e,"f",(function(){return m}));var r=n(29),a=n(3),s=n(0),o=n(76),c=n(43),i=n(54),u=n(93),l=n(53),h=n(89),p=n(4);const d=Object(p.a)({equalStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","equalStrict"),c=Object(a.a)(e,"b","equalStrict");return Object(s.assertShapesMatch)(n.shape,c.shape,"Error in equalStrict: "),Object(o.a)(n,c)}}),f=Object(p.a)({greaterEqualStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","greaterEqualStrict"),o=Object(a.a)(e,"b","greaterEqualStrict");return Object(s.assertShapesMatch)(n.shape,o.shape,"Error in greaterEqualStrict: "),Object(i.a)(n,o)}}),b=Object(p.a)({greaterStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","greaterStrict"),o=Object(a.a)(e,"b","greaterStrict");return Object(s.assertShapesMatch)(n.shape,o.shape,"Error in greaterStrict: "),Object(c.a)(n,o)}}),O=Object(p.a)({lessEqualStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","lessEqualStrict"),o=Object(a.a)(e,"b","lessEqualStrict");return Object(s.assertShapesMatch)(n.shape,o.shape,"Error in lessEqualStrict: "),Object(l.a)(n,o)}}),j=Object(p.a)({lessStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","lessStrict"),o=Object(a.a)(e,"b","lessStrict");return Object(s.assertShapesMatch)(n.shape,o.shape,"Error in lessStrict: "),Object(u.a)(n,o)}}),m=Object(p.a)({notEqualStrict_:function(t,e){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const n=Object(a.a)(t,"a","notEqualStrict"),o=Object(a.a)(e,"b","notEqualStrict");return Object(s.assertShapesMatch)(n.shape,o.shape,"Error in notEqualStrict: "),Object(h.a)(n,o)}})},286:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(10),i=n(4);const u=Object(i.a)({erf_:function(t){let e=Object(s.a)(t,"x","erf");o.assert("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=Object(c.a)(e,"float32"));const n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.erf(e);return n([e]),r}),n,null,a.V)}})},287:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({expm1_:function(t){const e=Object(s.a)(t,"x","expm1"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.expm1(e);return n([e]),r}),n,null,a.X)}})},30:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(145),i=n(4),u=n(96);const l=Object(i.a)({concat_:function(t,e=0){Object(o.assert)(t.length>=1,(()=>"Pass at least one tensor to concat"));let n=Object(s.b)(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}));const i=Object(o.parseAxisParam)(e,n[0].shape)[0],l=Object(c.b)(n.map((t=>t.shape)),i);if(0===Object(o.sizeFromShape)(l))return Object(u.a)([],l);if(n=n.filter((t=>t.size>0)),1===n.length)return n[0];const h=n.map((t=>t.shape));Object(c.a)(h,i);const p=n,d={axis:e};return r.a.runKernelFunc(((t,e)=>{const r=t.concat(n,i);return e(n),r}),p,null,a.z,d)}})},338:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(16),i=n(4),u=n(7);const l=Object(i.a)({avgPool3dBackprop_:function(t,e,n,i,l=[1,1,1],h,p){const d=Object(s.a)(t,"dy","avgPool3dBackprop"),f=Object(s.a)(e,"input","avgPool3dBackprop");let b=d,O=f,j=!1;4===f.rank&&(j=!0,b=Object(u.a)(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]]),O=Object(u.a)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),o.assert(5===b.rank,(()=>`Error in avgPool3dBackprop: dy must be rank 5 but got rank ${b.rank}.`)),o.assert(5===O.rank,(()=>`Error in avgPool3dBackprop: input must be rank 5 but got rank ${O.rank}.`)),o.assert(c.h(i,l),(()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`)),null!=p&&o.assert(o.isInt(h),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${p} but got pad ${h}.`));const m={dy:b,input:O},g={filterSize:n,strides:i,dilations:l,pad:h,dimRoundingMode:p},v=r.a.runKernelFunc((t=>{const e=c.f(O.shape,n,i,l,h,p);return t.avgPool3dBackprop(b,O,e)}),m,null,a.q,g);return j?Object(u.a)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}})},340:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(16),i=n(4),u=n(7);const l=Object(i.a)({avgPoolBackprop_:function(t,e,n,i,l){const h=Object(s.a)(t,"dy","avgPoolBackprop"),p=Object(s.a)(e,"input","avgPoolBackprop");o.assert(p.rank===h.rank,(()=>`Rank of input (${p.rank}) does not match rank of dy (${h.rank})`));let d=p,f=h,b=!1;3===p.rank&&(b=!0,d=Object(u.a)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),f=Object(u.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),o.assert(4===f.rank,(()=>`Error in avgPoolBackprop: dy must be rank 4 but got rank ${f.rank}.`)),o.assert(4===d.rank,(()=>`Error in avgPoolBackprop: input must be rank 4 but got rank ${d.rank}.`));const O={dy:f,input:d},j={filterSize:n,strides:i,pad:l},m=r.a.runKernelFunc((t=>{const e=c.e(d.shape,n,i,1,l);return t.avgPoolBackprop(f,d,e)}),O,null,a.r,j);return b?Object(u.a)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},351:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(0),o=n(16),c=n(4),i=n(7);const u=Object(c.a)({conv3DBackpropInput_:function(t,e,n,c,u){s.assert(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let l=t,h=e,p=!1;4===e.rank&&(p=!0,h=Object(i.a)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),l=[1,t[0],t[1],t[2],t[3]]);const d=l[4],f=h.shape[4];s.assert(5===l.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${l.length}.`)),s.assert(5===h.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${h.rank}`)),s.assert(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),s.assert(d===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[3]}.`)),s.assert(f===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${f}) must match output depth for filter ${n.shape[4]}.`));const b={dy:h},O={pad:u},j=r.a.runKernelFunc((t=>{const e=o.b(l,n.shape,c,1,u);return t.conv3dDerInput(h,n,e)}),b,null,a.F,O);return p?Object(i.a)(j,[j.shape[1],j.shape[2],j.shape[3],j.shape[4]]):j}})},352:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(0),o=n(16),c=n(4),i=n(7);const u=Object(c.a)({conv3DBackpropFilter_:function(t,e,n,c,u){let l=t;4===t.rank&&(l=Object(i.a)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let h=e;4===h.rank&&(h=Object(i.a)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),s.assert(5===l.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${l.shape}.`)),s.assert(5===h.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${h.shape}.`)),s.assert(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),s.assert(l.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${l.shape[4]}) must match input depth in filter (${n[3]}.`)),s.assert(h.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${h.shape[4]}) must match output depth for filter (${n[4]}).`));const p={x:l,y:h},d={strides:c,pad:u};return r.a.runKernelFunc((t=>{const e=o.b(l.shape,n,c,1,u);return t.conv3dDerFilter(l,h,e)}),p,null,a.E,d)}})},39:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({exp_:function(t){const e=Object(s.a)(t,"x","exp"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.exp(e);return n([r]),r}),n,null,a.W)}})},42:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({abs_:function(t){const e=Object(s.a)(t,"x","abs"),n={x:e};return r.a.runKernelFunc(((t,n)=>(n([e]),"complex64"===e.dtype?t.complexAbs(e):t.abs(e))),n,null,a.a)}})},44:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(3),a=n(0),s=n(4),o=n(7);const c=Object(s.a)({expandDims_:function(t,e=0){const n=Object(r.a)(t,"x","expandDims",null);a.assert(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const s=n.shape.slice();return e<0&&(a.assert(-(n.rank+1)<=e,(()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`)),e=n.rank+e+1),s.splice(e,0,1),Object(o.a)(n,s)}})},47:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(4);const i=Object(c.a)({complex_:function(t,e){const n=Object(s.a)(t,"real","complex"),c=Object(s.a)(e,"imag","complex");o.assertShapesMatch(n.shape,c.shape,`real and imag shapes, ${n.shape} and ${c.shape}, must match in call to tf.complex().`);const i={real:n,imag:c};return r.a.runKernelFunc((t=>t.complex(n,c)),i,null,a.y)}})},61:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(16),i=n(4),u=n(7);const l=Object(i.a)({conv2d_:function(t,e,n,i,l="NHWC",h=[1,1],p){const d=Object(s.a)(t,"x","conv2d"),f=Object(s.a)(e,"filter","conv2d");let b=d,O=!1;3===d.rank&&(O=!0,b=Object(u.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),o.assert(4===b.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${b.rank}.`)),o.assert(4===f.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${f.rank}.`)),null!=p&&o.assert(o.isInt(i),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${p} but got pad ${i}.`));const j="NHWC"===l?b.shape[3]:b.shape[1];o.assert(j===f.shape[2],(()=>`Error in conv2d: depth of input (${j}) must match input depth for filter ${f.shape[2]}.`)),o.assert(c.h(n,h),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`));const m={x:b,filter:f},g={strides:n,pad:i,dataFormat:l,dilations:h,dimRoundingMode:p},v=r.a.runKernelFunc(((t,e)=>{const r=c.g(l),a=c.a(b.shape,f.shape,n,h,i,p,!1,r),s=t.conv2d(b,f,a);return e([b,f]),s}),m,null,a.A,g);return O?Object(u.a)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},62:function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(5),a=n(2),s=n(3),o=n(4);const c=Object(o.a)({clone_:function(t){const e=Object(s.a)(t,"x","clone",null),n={x:e};return r.a.runKernelFunc((()=>r.a.makeTensorFromDataId(e.dataId,e.shape,e.dtype)),n,null,a.mb)}})},75:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(16),i=n(4),u=n(7);const l=Object(i.a)({depthwiseConv2d_:function(t,e,n,i,l="NHWC",h=[1,1],p){const d=Object(s.a)(t,"x","depthwiseConv2d"),f=Object(s.a)(e,"filter","depthwiseConv2d");let b=d,O=!1;3===d.rank&&(O=!0,b=Object(u.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),o.assert(4===b.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${b.rank}.`)),o.assert(4===f.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`)),o.assert(b.shape[3]===f.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${b.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`)),null!=p&&o.assert(o.isInt(i),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${p} but got pad ${i}.`));const j={x:b,filter:f},m={strides:n,pad:i,dataFormat:l,dilations:h,dimRoundingMode:p},g=r.a.runKernelFunc(((t,e)=>{null==h&&(h=[1,1]),o.assert(c.h(n,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`));const r=c.a(b.shape,f.shape,n,h,i,p,!0),a=t.depthwiseConv2D(b,f,r);return e([b,f]),a}),j,null,a.L,m);return O?Object(u.a)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},76:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var r=n(5),a=n(2),s=n(19),o=n(3),c=n(11),i=n(4);const u=Object(i.a)({equal_:function(t,e){let n=Object(o.a)(t,"a","equal"),i=Object(o.a)(e,"b","equal");[n,i]=Object(s.b)(n,i),Object(c.a)(n.shape,i.shape);const u={a:n,b:i};return r.a.runKernelFunc((t=>t.equal(n,i)),u,null,a.U)}})},81:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var r=n(6),a=n(0);function s(t,e="float32",n){return e=e||"float32",a.assertNonNegativeIntegerDimensions(t),new r.b(t,e,n)}},95:function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var r=n(5),a=n(2),s=n(3),o=n(0),c=n(4);const i=Object(c.a)({batchToSpaceND_:function(t,e,n){const c=Object(s.a)(t,"x","batchToSpaceND"),i=e.reduce(((t,e)=>t*e));o.assert(c.rank>=1+e.length,(()=>`input rank is ${c.rank} but should be > than blockShape.length ${e.length}`)),o.assert(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),o.assert(c.shape[0]%i==0,(()=>`input tensor batch is ${c.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`));const u={x:c},l={blockShape:e,crops:n};return r.a.runKernelFunc((t=>t.batchToSpaceND(c,e,n)),u,null,a.t,l)}})}}]);
//# sourceMappingURL=bundle~bundle~a1212309.0178786a.js.map