/*! For license information please see bundle~bundle~58c2b9c4.29928d74.js.LICENSE.txt */
(("undefined"!=typeof self?self:this).webpackJsonp=("undefined"!=typeof self?self:this).webpackJsonp||[]).push([[5],{105:function(e,t,n){"use strict";n.r(t),n.d(t,"validateUpdateShape",(function(){return a})),n.d(t,"validateInput",(function(){return s})),n.d(t,"calculateShapes",(function(){return o}));var r=n(5);function a(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let e=0;e<a;++e)if(n.shape[e]!==t.shape[e])throw new Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-a;++t)if(n.shape[t+a]!==e[t+r])throw new Error(s+` updates.shape[${t+a}] (${n.shape[t+a]}) != shape[${t+a}] (${e[t+a]})`)}function s(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}a(n,t,e)}function o(e,t,n){const a=t.shape.length,s=a>1?t.shape[a-1]:1,o=n.length;let c=1;for(let e=s;e<o;++e)c*=n[e];const u=s<1?1:s;return{sliceRank:s,numUpdates:Object(r.O)(t.shape)/u,sliceSize:c,strides:[...Object(r.j)(n.slice(0,s)),1],outputSize:Object(r.O)(n)}}},107:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({zerosLike_:function(e){const t={x:Object(s.a)(e,"x","zerosLike")};return r.a.runKernel(a.Pc,t)}})},109:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({reverse_:function(e,t){const n={x:Object(s.a)(e,"x","reverse")},o={dims:t};return r.a.runKernel(a.cc,n,o)}})},111:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({sqrt_:function(e){const t={x:Object(s.a)(e,"x","sqrt")};return r.a.runKernel(a.xc,t)}})},112:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n(2),a=n(6),s=n(1),o=n(5),c=n(3);const u=Object(c.a)({transpose_:function(e,t){const n=Object(s.a)(e,"x","transpose");if(null==t&&(t=n.shape.map(((e,t)=>t)).reverse()),o.b(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`)),t.forEach((e=>{o.b(e>=0&&e<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`))})),n.rank<=1)return n.clone();const c={x:n},u={perm:t};return r.a.runKernel(a.Mc,c,u)}})},12:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n(2),a=n(6),s=n(11),o=n(1),c=n(3);const u=Object(c.a)({sub_:function(e,t){let n=Object(o.a)(e,"a","sub"),c=Object(o.a)(t,"b","sub");[n,c]=Object(s.b)(n,c);const u={a:n,b:c};return r.a.runKernel(a.Fc,u)}})},126:function(e,t,n){"use strict";n.r(t),n.d(t,"assertParamsValid",(function(){return a})),n.d(t,"maskToAxes",(function(){return s})),n.d(t,"computeOutShape",(function(){return o})),n.d(t,"stridesWithElidedDims",(function(){return c})),n.d(t,"getNormalizedAxes",(function(){return l})),n.d(t,"startIndicesWithElidedDims",(function(){return f})),n.d(t,"stopIndicesWithElidedDims",(function(){return h})),n.d(t,"stridesForAxis",(function(){return b})),n.d(t,"startForAxis",(function(){return p})),n.d(t,"stopForAxis",(function(){return d})),n.d(t,"isSliceContinous",(function(){return O})),n.d(t,"computeFlatOffset",(function(){return j})),n.d(t,"parseSliceParams",(function(){return g})),n.d(t,"sliceInfo",(function(){return m}));var r=n(5);function a(e,t,n){const a=e.shape.length;r.b(a===t.length,(()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`)),r.b(a===n.length,(()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`));for(let s=0;s<a;++s)r.b(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${a}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function s(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function o(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function c(e,t,n,r){const a=[...e];for(let e=a.length;e<r.length;e++)a.push(1);for(let e=0;e<n;e++)0===e?a[t]=1:(a.splice(t,0,1),a.pop());return a}function u(e,t,n){return n<=e?n:n-(t-1)}function i(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function l(e,t,n,r,a,s,o,u,i){const l=e.length;let O=new Array(l),j=new Array(l),g=new Array(l);if(t.length&&n>0){const i=t[0],l=n+1;O=f(o,i,l,r,e),j=h(u,i,l,a,e),g=c(s,i,l,e)}else for(let t=0;t<l;t++)O[t]=p(o,r,s,e,t,i),j[t]=d(u,a,s,e,t,i),g[t]=b(s,t,i);return{begin:O,end:j,strides:g}}function f(e,t,n,r,a){const s=[...a],o=i(n,t);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const o=u(t,n,a);let c=r[o];e&1<<o&&(c=0),s[a]=c}return s}function h(e,t,n,a,s){const o=[...s],c=i(n,t);for(let r=0;r<o.length;r++)if(c.indexOf(r)>-1)o[r]=Number.MAX_SAFE_INTEGER;else{const s=u(t,n,r);let c=a[s];e&1<<s&&(c=Number.MAX_SAFE_INTEGER),o[r]=c}for(let e=0;e<o.length;e++){const t=s[e];o[e]<0&&(o[e]+=t),o[e]=r.i(0,o[e],s[e])}return o}function b(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function p(e,t,n,a,s,o){let c=t[s];const u=n[s]||1;(e&1<<s||o&1<<s||null==c)&&(c=u>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const i=a[s];return c<0&&(c+=i),c=r.i(0,c,i-1),c}function d(e,t,n,a,s,o){let c=t[s];const u=n[s]||1;(e&1<<s||o&1<<s||null==c)&&(c=u>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const i=a[s];return c<0&&(c+=i),c=u>0?r.i(0,c,i):r.i(-1,c,i-1),c}function O(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function j(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function g(e,t,n){let a;const s=e.shape.length;let o;return a="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),a.forEach((e=>{r.b(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(r.b(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-a[n]))),[a,o]}function m(e,t,n,r,a,c,u,i,f){let h=t.slice(),b=n.slice(),p=r;null==r&&(p=new Array(h.length));const d=s(u);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==u&&0!==i)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==u&&0!==f)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const O=e.length-h.length,j=s(i),g=e.slice();j.forEach((e=>{h[e]=0,b[e]=1,g.splice(e,0,1)}));const{begin:m,end:w,strides:E}=l(g,d,O,h,b,p,a,c,u);h=m,b=w,p=E;const v=s(f);v.forEach((e=>{b[e]=h[e]+1,p[e]=1}));const y=o(h,b,p),$=y.filter(((e,t)=>-1===v.indexOf(t)));return{nonStrided:p.every((e=>1===e)),$begin:h,$end:b,$strides:p,size:y,newShape:g,outShape:$}}},129:function(e,t,n){"use strict";function r(e,t=!1){console.log(e.toString(t))}n.d(t,"a",(function(){return r}))},131:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({sigmoid_:function(e){const t={x:Object(s.a)(e,"x","sigmoid")};return r.a.runKernel(a.jc,t)}})},132:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(1),a=n(5),s=n(3),o=n(8);const c=Object(s.a)({squeeze_:function(e,t){const n=Object(r.a)(e,"x","squeeze");return Object(o.a)(n,Object(a.Q)(n.shape,t).newShape)}})},133:function(e,t,n){"use strict";n.d(t,"a",(function(){return p}));var r=n(42),a=n(34),s=n(87),o=n(10),c=n(3),u=n(74),i=n(8),l=n(109),f=n(15),h=n(22),b=n(73);const p=Object(c.a)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let c;if(t<=2){const r=Object(i.a)(e,[n,t]);c=Object(b.a)(r)}else{const p=[n,2*(t-1)],d=Object(i.a)(Object(u.a)(e),[n,t]),O=Object(i.a)(Object(s.a)(e),[n,t]),j=Object(l.a)(Object(h.a)(d,[0,1],[n,t-2]),1),g=Object(o.a)(Object(l.a)(Object(h.a)(O,[0,1],[n,t-2]),1),Object(f.a)(-1)),m=Object(a.a)([d,j],1),w=Object(a.a)([O,g],1),E=Object(i.a)(Object(r.a)(m,w),[p[0],p[1]]);c=Object(b.a)(E)}if(c=Object(u.a)(c),3===e.rank&&0!==e.shape[0]){const t=c,n=e.shape[0];c=Object(i.a)(c,[n,c.shape[0]/n,c.shape[1]]),t.dispose()}return c}})},135:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({round_:function(e){const t={x:Object(s.a)(e,"x","round")};return r.a.runKernel(a.ec,t)}})},138:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n(2),a=n(6),s=n(11),o=n(1),c=n(3);const u=Object(c.a)({pow_:function(e,t){let n=Object(o.a)(e,"base","pow"),c=Object(o.a)(t,"exp","pow");[n,c]=Object(s.b)(n,c);const u={a:n,b:c};return r.a.runKernel(a.Qb,u)}})},14:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n(2),a=n(6),s=n(1),o=n(18),c=n(3);const u=Object(c.a)({sum_:function(e,t=null,n=!1){let c=Object(s.a)(e,"x","sum");"bool"===c.dtype&&(c=Object(o.a)(c,"int32"));const u={x:c},i={axis:t,keepDims:n};return r.a.runKernel(a.Gc,u,i)}})},142:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(5),s=n(42),o=n(65);function c(e,t="float32"){if("complex64"===t){const t=c(e,"float32"),n=Object(o.a)(e,"float32");return Object(s.a)(t,n)}const n=Object(a.D)(Object(a.O)(e),t);return r.a.makeTensor(n,e,t)}},143:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n(2),a=n(6),s=n(11),o=n(1),c=n(17),u=n(3);const i=Object(u.a)({notEqual_:function(e,t){let n=Object(o.a)(e,"a","notEqual","string_or_numeric"),u=Object(o.a)(t,"b","notEqual","string_or_numeric");[n,u]=Object(s.b)(n,u),Object(c.a)(n.shape,u.shape);const i={a:n,b:u};return r.a.runKernel(a.Lb,i)}})},145:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n(2),a=n(6),s=n(11),o=n(1),c=n(17),u=n(3);const i=Object(u.a)({squaredDifference_:function(e,t){let n=Object(o.a)(e,"a","squaredDifference"),u=Object(o.a)(t,"b","squaredDifference");[n,u]=Object(s.b)(n,u),Object(c.a)(n.shape,u.shape);const i={a:n,b:u};return r.a.runKernel(a.zc,i,{})}})},148:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({step_:function(e,t=0){const n={x:Object(s.a)(e,"x","step")},o={alpha:t};return r.a.runKernel(a.Ac,n,o)}})},15:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n(5),a=n(53);function s(e,t){if((Object(r.A)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Object(r.A)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(a.a)(e,[],[],t)}},150:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({relu6_:function(e){const t={x:Object(s.a)(e,"x","relu6")};return r.a.runKernel(a.Yb,t)}})},151:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({prelu_:function(e,t){const n={x:Object(s.a)(e,"x","prelu"),alpha:Object(s.a)(t,"alpha","prelu")};return r.a.runKernel(a.Rb,n)}})},154:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(1),a=n(5),s=n(53);function o(e,t,n){if(Object(a.d)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const o=Object(r.c)(e,n);if(3!==o.length&&1!==o.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===o.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(s.a)(e,t,o,n)}},155:function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"b",(function(){return s}));var r=n(5);const a=30;function s(e){return e<=a?e:Object(r.G)(e,Math.floor(Math.sqrt(e)))}},22:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({slice_:function(e,t,n){const o=Object(s.a)(e,"x","slice","string_or_numeric");if(0===o.rank)throw new Error("Slicing scalar is not possible");const c={x:o},u={begin:t,size:n};return r.a.runKernel(a.nc,c,u)}})},225:function(e,t,n){"use strict";function r(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}n.d(t,"a",(function(){return r}))},227:function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return a}));const r=1.7580993408473768,a=1.0507009873554805},230:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));var r=n(5);function a(e,t,n=0){let a=[];if("number"==typeof t)Object(r.b)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Object(r.b)(s<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const r=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-r}Object(r.b)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}},231:function(e,t,n){"use strict";n.r(t),n.d(t,"segOpComputeOptimalWindowSize",(function(){return s})),n.d(t,"computeOutShape",(function(){return o})),n.d(t,"collectGatherOpShapeInfo",(function(){return c}));var r=n(5),a=n(155);function s(e,t){let n,s=!1;for(e<=a.a?(n=e,s=!0):n=Object(r.G)(e,Math.floor(Math.sqrt(e)));!s;)n>t||n===e?s=!0:n=Object(r.G)(e,n+1);return n}function o(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function c(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const o=e.shape[n],c=[];let u=1,i=1,l=1;for(let t=0;t<r;++t)c.push(e.shape[t]),u*=e.shape[t];for(let t=r;t<n;t++)c.push(e.shape[t]),i*=e.shape[t];for(let e=r;e<a;e++)c.push(t.shape[e]);for(let t=n+1;t<s;t++)c.push(e.shape[t]),l*=e.shape[t];return{batchSize:u,sliceSize:l,outerSize:i,dimSize:o,outputShape:c}}},232:function(e,t,n){"use strict";n.d(t,"a",(function(){return r.a})),n.d(t,"b",(function(){return a.a})),n.d(t,"c",(function(){return s.a})),n.d(t,"d",(function(){return o.a})),n.d(t,"e",(function(){return c.a})),n.d(t,"f",(function(){return u.a})),n.d(t,"g",(function(){return i.a})),n.d(t,"h",(function(){return l.a})),n.d(t,"k",(function(){return f.a})),n.d(t,"l",(function(){return h.a})),n.d(t,"m",(function(){return b.a})),n.d(t,"n",(function(){return p.a})),n.d(t,"o",(function(){return d.a})),n.d(t,"q",(function(){return O.a})),n.d(t,"r",(function(){return j.a})),n.d(t,"t",(function(){return g.a})),n.d(t,"u",(function(){return m.a})),n.d(t,"v",(function(){return w.a})),n.d(t,"w",(function(){return E.a})),n.d(t,"x",(function(){return v.a})),n.d(t,"j",(function(){return pe})),n.d(t,"i",(function(){return S})),n.d(t,"p",(function(){return de})),n.d(t,"s",(function(){return Oe}));var r=n(19),a=n(55),s=n(18),o=n(44),c=n(34),u=n(222),i=n(26),l=n(60),f=n(10),h=n(8),b=n(15),p=n(131),d=n(22),O=n(132),j=n(57),g=n(12),m=n(69),w=n(32),E=n(70),v=n(84),y=n(86),$=n(85),x=n(73),k=n(133),S=n(233),_=n(3);function A(e,t,n){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(o)}return Object(w.a)(a,"float32")}Object(_.a)({hammingWindow_:function(e){return A(e,.54,.46)}});const T=Object(_.a)({hannWindow_:function(e){return A(e,.5,.5)}});var M=n(88);const D=Object(_.a)({frame_:function(e,t,n,r=!1,a=0){let s=0;const o=[];for(;s+t<=e.size;)o.push(Object(d.a)(e,s,t)),s+=n;if(r)for(;s<e.size;){const r=s+t-e.size,u=Object(c.a)([Object(d.a)(e,s,t-r),Object(M.a)([r],a)]);o.push(u),s+=n}return 0===o.length?Object(E.a)([],[0,t]):Object(h.a)(Object(c.a)(o),[o.length,t])}});Object(_.a)({stft_:function(e,t,n,r,a=T){var s;null==r&&(s=t,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const o=D(e,t,n),c=Object(f.a)(o,a(t));return Object(y.a)(c,r)}});var I=n(240),N=n(236),K=n(239),z=n(241),R=n(242),q=n(243),F=n(244),P=n(245),G=n(246),W=n(238),U=n(237),C=n(247),L=n(248),B=n(249),H=n(250),V=n(251),X=n(252),J=n(31),Q=n(253),Y=n(254),Z=n(255),ee=n(256),te=n(257),ne=n(258),re=n(259),ae=n(2),se=n(6),oe=n(1);const ce=Object(_.a)({sparseFillEmptyRows_:function(e,t,n,r){const a=Object(oe.a)(e,"indices","sparseFillEmptyRows"),s=Object(oe.a)(t,"values","sparseFillEmptyRows"),o=Object(oe.a)(n,"denseShape","sparseFillEmptyRows"),c=Object(oe.a)(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==c.rank)throw new Error(`Default value should be a scalar but received shape ${c.shape}`);const u={indices:a,values:s,denseShape:o,defaultValue:c},i=ae.a.runKernel(se.rc,u);return{outputIndices:i[0],outputValues:i[1],emptyRowIndicator:i[2],reverseIndexMap:i[3]}}});const ue=Object(_.a)({sparseReshape_:function(e,t,n){const r=Object(oe.a)(e,"inputIndices","sparseReshape"),a=Object(oe.a)(t,"inputShape","sparseReshape"),s=Object(oe.a)(n,"newShape","sparseReshape");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:r,inputShape:a,newShape:s},c=ae.a.runKernel(se.sc,o);return{outputIndices:c[0],outputShape:c[1]}}});const ie=Object(_.a)({sparseSegmentMean_:function(e,t,n){const r=Object(oe.a)(e,"data","sparseSegmentMean"),a=Object(oe.a)(t,"indices","sparseSegmentMean"),s=Object(oe.a)(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return ae.a.runKernel(se.tc,o)}});const le=Object(_.a)({sparseSegmentSum_:function(e,t,n){const r=Object(oe.a)(e,"data","sparseSegmentSum"),a=Object(oe.a)(t,"indices","sparseSegmentSum"),s=Object(oe.a)(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return ae.a.runKernel(se.uc,o)}});const fe=Object(_.a)({stringNGrams_:function(e,t,n,r,a,s,o,c){const u=Object(oe.a)(e,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const i=Object(oe.a)(t,"dataSplits","stringNGrams");if("int32"!==i.dtype)throw new Error("Data splits must be of datatype int32");const l={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:c},f={data:u,dataSplits:i},h=ae.a.runKernel(se.Cc,f,l);return{nGrams:h[0],nGramsSplits:h[1]}}});const he=Object(_.a)({stringSplit_:function(e,t,n=!0){const r=Object(oe.a)(e,"input","stringSplit","string"),a=Object(oe.a)(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:n},o={input:r,delimiter:a},c=ae.a.runKernel(se.Dc,o,s);return{indices:c[0],values:c[1],shape:c[2]}}});const be=Object(_.a)({stringToHashBucketFast_:function(e,t){const n=Object(oe.a)(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return ae.a.runKernel(se.Ec,a,r)}}),pe=($.a,x.a,y.a,k.a,{flipLeftRight:N.a,resizeNearestNeighbor:U.a,resizeBilinear:W.a,rotateWithOffset:K.a,cropAndResize:I.a,nonMaxSuppression:z.a,nonMaxSuppressionAsync:R.a,nonMaxSuppressionWithScore:q.a,nonMaxSuppressionWithScoreAsync:F.a,nonMaxSuppressionPadded:P.a,nonMaxSuppressionPaddedAsync:G.a,threshold:C.a,transform:L.a}),de=(B.a,H.a,V.a,X.a,J.a,Q.a,Y.a,Z.a,ee.a,te.a,ne.a,re.a,{sparseFillEmptyRows:ce,sparseReshape:ue,sparseSegmentMean:ie,sparseSegmentSum:le}),Oe={stringNGrams:fe,stringSplit:he,stringToHashBucketFast:be}},235:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(9),a=n(7),s=n(5);class o{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new u)}profileKernel(e,t,n){let s;const o=()=>{s=n()};let u;const i=a.now();if(this.backendTimer.timerAvailable())u=this.backendTimer.time(o);else{o();for(const e of s)e.dataSync();u=Promise.resolve({kernelMs:a.now()-i})}if(Object(r.b)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<s.length;t++){const n=s[t];n.data().then((t=>{c(t,n.dtype,e)}))}return{kernelName:e,outputs:s,inputs:t,timeMs:u.then((e=>e.kernelMs)),extraInfo:u.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function c(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class u{logKernelProfile(e,t,n,r,a,o){const c="number"==typeof r?s.L(`${r}ms`,9):r.error,u=s.L(e,25),i=t.rank,l=t.size,f=s.L(t.shape.toString(),14);let h="";for(const e in a){const n=a[e];if(null!=n){const r=n.shape||t.shape,a=r.length;h+=`${e}: ${a}D ${a>0?r:""} `}}console.log(`%c${u}\t%c${c}\t%c${i}D ${f}\t%c${l}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}},3:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n(2),a=n(5);function s(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const o=(...e)=>{r.a.startScope(n);try{const t=s(...e);return Object(a.x)(t)&&console.error("Cannot return a Promise inside of tidy."),r.a.endScope(t),t}catch(e){throw r.a.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},32:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(1),a=n(5),s=n(53);function o(e,t){Object(a.d)(e);const n=Object(r.c)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(s.a)(e,null,n,t)}},433:function(e,t,n){"use strict";n(103);var r=n(9),a=n(156),s=n(157),o=n(64);class c{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(Object(r.b)().get("IS_BROWSER")){Object(r.b)().setPlatform("browser",new c);try{o.a.registerManager(s.a.URL_SCHEME,new s.b)}catch(e){}try{o.a.registerManager(a.a.URL_SCHEME,new a.b)}catch(e){}}},437:function(e,t,n){"use strict";(function(e){var t=n(9);const r=()=>n(438);let a;class s{constructor(){this.util=n(439),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return null!=Object(t.b)().global.fetch?Object(t.b)().global.fetch(e,n):(null==a&&(a=r()),a(e,n))}now(){const t=e.hrtime();return 1e3*t[0]+t[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}Object(t.b)().get("IS_NODE")&&Object(t.b)().setPlatform("node",new s)}).call(this,n(62))},45:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));var r=n(5);function a(e,t,n,a,s,o){null==a&&(a=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const c=e.shape[0];return n=Math.min(n,c),r.b(0<=a&&a<=1,(()=>`iouThreshold must be in [0, 1], but was '${a}'`)),r.b(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),r.b(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),r.b(1===t.rank,(()=>"scores must be a 1D tensor")),r.b(t.shape[0]===c,(()=>`scores has incompatible shape with boxes. Expected ${c}, but was ${t.shape[0]}`)),r.b(0<=o&&o<=1,(()=>`softNmsSigma must be in [0, 1], but was '${o}'`)),{maxOutputSize:n,iouThreshold:a,scoreThreshold:s,softNmsSigma:o}}},52:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n(2),a=n(6),s=n(1),o=n(92),c=n(17),u=n(3);const i=Object(u.a)({where_:function(e,t,n){const u=Object(s.a)(t,"a","where"),i=Object(s.a)(n,"b","where"),l=Object(s.a)(e,"condition","where","bool"),f=Object(c.a)(Object(c.a)(l.shape,u.shape),i.shape),h={condition:Object(o.a)(l,f),t:Object(o.a)(u,f),e:Object(o.a)(i,f)};return r.a.runKernel(a.hc,h)}})},53:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(2),a=n(5),s=n(7);function o(e,t,n,o){if(null==o&&(o=Object(a.r)(e)),"complex64"===o)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(a.A)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Object(a.c)(t);const e=Object(a.O)(t),r=Object(a.O)(n);Object(a.b)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==Object(a.O)(t.slice(e));Object(a.b)(n[e]===t[e]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Object(a.A)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==o?Object(s.toTypedArray)(e,o):Object(a.m)(e,[],!0),r.a.makeTensor(e,t,o)}},57:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n(2),a=n(6),s=n(1),o=n(5),c=n(3);const u=Object(c.a)({stack_:function(e,t=0){const n=Object(s.b)(e,"tensors","stack","string_or_numeric");o.b(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&o.b(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const c=n,u={axis:t};return r.a.runKernel(a.Ob,c,u)}})},58:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({split_:function(e,t,n=0){const o={x:Object(s.a)(e,"x","split")},c={numOrSizeSplits:t,axis:n};return r.a.runKernel(a.wc,o,c)}})},65:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(2),a=n(5),s=n(42);function o(e,t="float32"){if("complex64"===t){const t=o(e,"float32"),n=o(e,"float32");return Object(s.a)(t,n)}const n=Object(a.F)(Object(a.O)(e),t);return r.a.makeTensor(n,e,t)}},67:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({relu_:function(e){const t={x:Object(s.a)(e,"x","relu")};return r.a.runKernel(a.Xb,t)}})},69:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n(1),a=n(53);function s(e,t,n){const s=Object(r.c)(e,n);return Object(a.a)(e,t,s,n)}},70:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(1),a=n(5),s=n(53);function o(e,t,n){if(Object(a.d)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const o=Object(r.c)(e,n);if(2!==o.length&&1!==o.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===o.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(s.a)(e,t,o,n)}},71:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n(2),a=n(6);function s(e,t,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");const o={start:e,stop:t,step:n,dtype:s};return r.a.runKernel(a.Tb,{},o)}},73:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(5),o=n(3);const c=Object(o.a)({ifft_:function(e){Object(s.b)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.a.runKernel(a.hb,t)}})},74:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({real_:function(e){const t={input:Object(s.a)(e,"input","real")};return r.a.runKernel(a.Ub,t)}})},8:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(1),o=n(3);const c=Object(o.a)({reshape_:function(e,t){const n={x:Object(s.a)(e,"x","reshape","string_or_numeric")},o={shape:t};return r.a.runKernel(a.Zb,n,o)}})},84:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n(2),a=n(6),s=n(1),o=n(5),c=n(3);const u=Object(c.a)({unstack_:function(e,t=0){const n=Object(s.a)(e,"x","unstack","string_or_numeric");o.b(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const c={value:n},u={axis:t};return r.a.runKernel(a.Oc,c,u)}})},85:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(2),a=n(6),s=n(5),o=n(3);const c=Object(o.a)({fft_:function(e){Object(s.b)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.a.runKernel(a.U,t)}})},86:function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(5),a=n(42),s=n(34),o=n(87),c=n(3),u=n(74),i=n(8),l=n(22),f=n(58),h=n(65),b=n(107),p=n(85);const d=Object(c.a)({rfft_:function(e,t){Object(r.b)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const c=e.size/n;let d;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,d=Object(l.a)(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,d=Object(s.a)([e,Object(h.a)(r)],e.shape.length-1),n=t}else d=e;const O=Object(b.a)(d),j=Object(i.a)(Object(a.a)(d,O),[c,n]),g=Object(p.a)(j),m=Math.floor(n/2)+1,w=Object(u.a)(g),E=Object(o.a)(g),v=Object(f.a)(w,[m,n-m],w.shape.length-1),y=Object(f.a)(E,[m,n-m],E.shape.length-1),$=d.shape.slice();return $[d.shape.length-1]=m,Object(i.a)(Object(a.a)(v[0],y[0]),$)}})},90:function(e,t,n){"use strict";n.d(t,"a",(function(){return j}));var r=n(1),a=n(5),s=n(33),o=n(66),c=n(59),u=n(110),i=n(3),l=n(138),f=n(8),h=n(15),b=n(111),p=n(91),d=n(14);function O(e,t,n=null){if(0===e.rank)return Object(s.a)(e);if(1!==e.rank&&null===n)return O(Object(f.a)(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Object(d.a)(Object(s.a)(e),n);if(t===1/0)return Object(c.a)(Object(s.a)(e),n);if(t===-1/0)return Object(u.a)(Object(s.a)(e),n);if("euclidean"===t||2===t)return Object(b.a)(Object(d.a)(Object(l.a)(Object(s.a)(e),Object(h.a)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Object(c.a)(Object(d.a)(Object(s.a)(e),n[0]),n[1]-1);if(t===1/0)return Object(c.a)(Object(d.a)(Object(s.a)(e),n[1]),n[0]);if(t===-1/0)return Object(u.a)(Object(d.a)(Object(s.a)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Object(b.a)(Object(d.a)(Object(p.a)(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const j=Object(i.a)({norm_:function(e,t="euclidean",n=null,s=!1){const c=O(e=Object(r.a)(e,"x","norm"),t,n);let u=c.shape;if(s){const t=Object(a.I)(n,e.shape);u=o.e(c.shape,t)}return Object(f.a)(c,u)}})},91:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(2),a=n(1),s=n(3);const o=Object(s.a)({square_:function(e){const t=Object(a.a)(e,"x","square");return r.a.runKernel("Square",{x:t},{})}})},93:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n(2),a=n(6),s=n(1),o=n(5),c=n(3);const u=Object(c.a)({tile_:function(e,t){const n=Object(s.a)(e,"x","tile","string_or_numeric");o.b(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const c={x:n},u={reps:t};return r.a.runKernel(a.Jc,c,u)}})}}]);
//# sourceMappingURL=bundle~bundle~58c2b9c4.29928d74.js.map