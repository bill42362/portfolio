/*! For license information please see bundle~bundle~748942c6.a2dba907.js.LICENSE.txt */
(("undefined"!=typeof self?self:this).webpackJsonp=("undefined"!=typeof self?self:this).webpackJsonp||[]).push([[8],{144:function(e,t){},434:function(e,t,a){"use strict";t.a=a.p+"wasm/tfjs-backend-wasm.3c37882f.wasm"},435:function(e,t,a){"use strict";t.a=a.p+"wasm/tfjs-backend-wasm-simd.d14ef6eb.wasm"},436:function(e,t,a){"use strict";t.a=a.p+"wasm/tfjs-backend-wasm-threaded-simd.c9529b77.wasm"},437:function(e,t,a){"use strict";a.d(t,"a",(function(){return jt}));var n,r,s=a(1);let i;!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(n||(n={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu"}(r||(r={}));const d={kernelName:s.Kb,backendName:"wasm",setupFunc:function(e){i=e.wasm.cwrap(s.Kb,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{a:s,b:d,bias:u,preluActivationWeights:o}=t;if("float32"!==s.dtype||"float32"!==d.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:c,transposeB:p,activation:l,leakyreluAlpha:m}=n,b=a.dataIdMap.get(s.dataId).id,h=a.dataIdMap.get(d.dataId).id;let f=0;if(null!=u){const e=a.dataIdMap.get(u.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}const k=null==o?0:a.dataIdMap.get(o.dataId).id,g=r[l];if(null==g)throw new Error(`${l} activation not yet supported for FusedConv2D in the wasm backend.`);const w=c?s.shape[2]:s.shape[1],I=p?d.shape[1]:d.shape[2],y=s.shape[0],M=a.makeOutput([y,w,I],s.dtype),A=a.dataIdMap.get(M.dataId).id,x=new Uint8Array(new Int32Array(s.shape).buffer),v=new Uint8Array(new Int32Array(d.shape).buffer);return i(b,x,s.shape.length,h,v,d.shape.length,c,p,g,f,k,m||0,A),M}};function u(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(a){t=a.wasm.cwrap(e,null,["number","number"])},kernelFunc:function(e){const{backend:a,inputs:{x:n}}=e,r=a.dataIdMap.get(n.dataId).id,i=a.makeOutput(n.shape,n.dtype),d=a.dataIdMap.get(i.dataId).id;return 0===s.vc.sizeFromShape(i.shape)||t(r,d),i}}}const o=u(s.a);function c(e,t,a){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(i){const{backend:d,inputs:u}=i,{a:o,b:c}=u,p=d.dataIdMap.get(o.dataId).id,l=d.dataIdMap.get(c.dataId).id,m=null!=a?a:o.dtype,b=s.Mb.assertAndGetBroadcastShape(o.shape,c.shape),h=d.makeOutput(b,m);if(0===s.vc.sizeFromShape(b))return h;const f=new Uint8Array(new Int32Array(o.shape).buffer),k=new Uint8Array(new Int32Array(c.shape).buffer),g=d.dataIdMap.get(h.dataId).id,w=()=>r(p,f,o.shape.length,l,k,c.shape.length,n[o.dtype],g);if(t&&"float32"===o.dtype)return w(),h;const I=s.Mb.getBroadcastDims(o.shape,b),y=s.Mb.getBroadcastDims(c.shape,b),M=I.every(((e,t)=>e===t)),A=y.every(((e,t)=>e===t));if(M&&A)return w(),h;throw new Error(`Broadcasting along outer dims is not yet supported for ${o.dtype} ${e}.`)}}}const p=c(s.b,!0);let l;const m={kernelName:s.c,backendName:"wasm",setupFunc:function(e){l=e.wasm.cwrap(s.c,null,["array","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a}=e,r=a.makeOutput(t[0].shape,t[0].dtype);if(0===s.vc.sizeFromShape(r.shape))return r;const i=t.map((e=>a.dataIdMap.get(e.dataId).id)),d=new Uint8Array(new Int32Array(i).buffer),u=a.dataIdMap.get(r.dataId).id;return l(d,i.length,n[r.dtype],u),r}};function b(e){const{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype),r=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(n).set(r),n}const h={kernelName:s.F,backendName:"wasm",kernelFunc:b};let f;function k(e){const{inputs:t,backend:a,attrs:r}=e,[s,i]=function(e,t){const a=[],n=[];for(let r=0;r<e.length;++r)1!==e[r]&&a.push(e[r]),1!==e[t[r]]&&n.push(t[r]);for(let e=0;e<n.length;++e){let t=-1;for(let a=0;a<n.length;++a)n[a]>=e&&(-1===t||n[t]>n[a])&&(t=a);n[t]=e}return[a,n]}(t.x.shape,r.perm);let d=!0;for(let e=0;e<i.length;e++)i[e]!==e&&(d=!1);const u=function(e,t){const a=new Array(e.length);for(let n=0;n<a.length;n++)a[n]=e[t[n]];return a}(t.x.shape,r.perm),o={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(d){const e=b({inputs:t,backend:a});return e.shape=u,e}const c=a.makeOutput(u,o.dtype),p=a.dataIdMap.get(o.dataId).id,l=a.dataIdMap.get(c.dataId).id,m=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(o.shape).buffer);return f(p,h,o.shape.length,n[o.dtype],l,m,i.length),c}const g={kernelName:s.Hb,backendName:"wasm",kernelFunc:k,setupFunc:function(e){f=e.wasm.cwrap(s.Hb,null,["number","array","number","number","number","array","number"])}};function w(e,t,a){const n=e.shape,r=e.shape.length,i=s.vc.parseAxisParam(t,n);let d=i;const u=s.Mb.getAxesPermutation(d,r);let o=null,c=!1;if(null!=u){const t=new Array(r);for(let e=0;e<t.length;e++)t[e]=n[u[e]];d=s.Mb.getInnerMostAxes(d.length,r),o=k({inputs:{x:e},attrs:{perm:u},backend:a});const i=a.dataIdMap.get(e.dataId).id;a.dataIdMap.get(o.dataId).id!==i&&(c=!0)}return{transposed:o,originalAxes:i,axes:d,inputWasTransposed:c}}let I;const y={kernelName:s.d,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{axis:i}=r,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,inputWasTransposed:m}=w(d,i,t);if(m){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e)}const b=c.shape.slice(0,-1),h=t.makeOutput(b,"int32"),f=t.dataIdMap.get(h.dataId).id,k=s.vc.sizeFromShape(h.shape),g=c.shape[l[0]];return I(o,n[c.dtype],k,g,f),m&&t.disposeData(p.dataId),h},setupFunc:function(e){I=e.wasm.cwrap(s.d,null,["number","number","number","number","number"])}};let M;const A={kernelName:s.e,backendName:"wasm",setupFunc:function(e){M=e.wasm.cwrap(s.e,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,r=t.x,i=n.dataIdMap.get(r.dataId).id,{filterSize:d,strides:u,pad:o,dimRoundingMode:c}=a,p=s.Mb.computePool2DInfo(r.shape,d,u,1,o,c),l=p.filterHeight,m=p.filterWidth,b=p.padInfo.top,h=p.padInfo.right,f=p.padInfo.bottom,k=p.padInfo.left,g=p.strideHeight,w=p.strideWidth,I=p.inChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(1!==p.dilationWidth||1!==p.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);const y=n.makeOutput(p.outShape,"float32"),A=n.dataIdMap.get(y.dataId).id;return M(i,r.shape[0],r.shape[1],r.shape[2],l,m,b,h,f,k,g,w,I,A),y}};function x(e){const{inputs:t,attrs:a}=e,{x:n}=t,{shape:r}=a,i=s.vc.sizeFromShape(n.shape),d=s.vc.inferFromImplicitShape(r,i);return s.vc.assert(i===s.vc.sizeFromShape(d),(()=>`new shape: ${d}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`)),{dataId:n.dataId,shape:d,dtype:n.dtype}}const v={kernelName:s.jb,backendName:"wasm",kernelFunc:x};let F;const S={kernelName:s.f,backendName:"wasm",setupFunc:function(e){F=e.wasm.cwrap(s.f,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{a:r,b:i}=t,{transposeA:d,transposeB:u}=n;if("float32"!==r.dtype||"float32"!==i.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const o=r.shape.length,c=i.shape.length,p=d?r.shape[o-2]:r.shape[o-1],l=u?i.shape[c-1]:i.shape[c-2],m=d?r.shape[o-1]:r.shape[o-2],b=u?i.shape[c-2]:i.shape[c-1],h=r.shape.slice(0,-2),f=i.shape.slice(0,-2),k=s.vc.sizeFromShape(h),g=s.vc.sizeFromShape(f),w=k===g||1===k||1===g;s.vc.assert(o>=2&&c>=2&&w,(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${f}).`));const I=(k>g?r.shape.slice(0,-2):i.shape.slice(0,-2)).concat([m,b]);s.vc.assert(p===l,(()=>`Error in matMul: inner shapes (${p}) and (${l}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${d} and transposeB=${u} must match.`));const y=u?[g,b,l]:[g,l,b],M=x({inputs:{x:r},backend:a,attrs:{shape:d?[k,p,m]:[k,m,p]}}),A=x({inputs:{x:i},backend:a,attrs:{shape:y}}),v=a.dataIdMap.get(M.dataId).id,S=a.dataIdMap.get(A.dataId).id,N=d?M.shape[2]:M.shape[1],O=u?A.shape[1]:A.shape[2],C=Math.max(k,g),z=a.makeOutput([C,N,O],M.dtype),D=a.dataIdMap.get(z.dataId).id,W=new Uint8Array(new Int32Array(M.shape).buffer),H=new Uint8Array(new Int32Array(A.shape).buffer);return F(v,W,M.shape.length,S,H,A.shape.length,d,u,D),z.shape=I,z}};function N(e){const{inputs:{x:t},attrs:{dtype:a},backend:n}=e,r=n.makeOutput(t.shape,a),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}const O={kernelName:s.g,backendName:"wasm",kernelFunc:N};let C;const z={kernelName:s.h,backendName:"wasm",setupFunc:function(e){C=e.wasm.cwrap(s.h,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=n,d=a.dataIdMap.get(r.dataId).id,u=a.makeOutput(r.shape,r.dtype),o=a.dataIdMap.get(u.dataId).id;return C(d,s,i,o),u}};function D(e){const{inputs:t,backend:a}=e,n=s.vc.parseAxisParam(e.attrs.axis,t[0].shape)[0];let r=s.Mb.computeOutShape(t.map((e=>e.shape)),n);const i=t.filter((e=>s.vc.sizeFromShape(e.shape)>0));if(1===i.length)return b({inputs:{x:i[0]},backend:a});const d=a.makeOutput(r,t[0].dtype);if(0===s.vc.sizeFromShape(r))return d;const u=i.map((e=>e.shape));if(s.Mb.assertParamsConsistent(u,n),"string"===i[0].dtype){const e=i.map((e=>{const t=s.vc.sizeFromShape(e.shape.slice(n));return x({inputs:{x:e},backend:a,attrs:{shape:[-1,t]}})})),u=e.map((e=>({vals:a.readSync(e.dataId),shape:e.shape})));r=s.Mb.computeOutShape(e.map((e=>e.shape)),1);const o=1===e[0].shape[0],c=function(e,t,a,n){const r=s.vc.getArrayFromDType(a,s.vc.sizeFromShape(t));if(n&&"string"!==a){let t=0;e.forEach((e=>{const a=s.vc.sizeFromShape(e.shape);r.set(e.vals,t),t+=a}))}else{let n=0;e.forEach((e=>{const i="string"===a?s.Mb.fromUint8ToStringArray(e.vals):e.vals;let d=0;for(let a=0;a<e.shape[0];++a){const s=a*t[1]+n;for(let t=0;t<e.shape[1];++t)r[s+t]=i[d++]}n+=e.shape[1]}))}return r}(u,r,t[0].dtype,o),p=s.Mb.computeOutShape(i.map((e=>e.shape)),n);d.shape=p;return a.dataIdMap.get(d.dataId).stringBytes=s.Mb.fromStringArrayToUint8(c),d}const o=s.vc.sizeFromShape(i[0].shape.slice(0,n));let c=0;const p=i.map((e=>{const t=s.vc.sizeFromShape(e.shape.slice(n));return c+=t,t})),l=i.map((e=>a.typedArrayFromHeap(e))),m=a.typedArrayFromHeap(d);for(let e=0;e<o;e++){let t=e*c;for(let a=0;a<l.length;a++){const n=p[a],r=e*n,s=l[a].subarray(r,r+n);m.set(s,t),t+=n}}return d}const W={kernelName:s.i,backendName:"wasm",kernelFunc:D};let H;const U={kernelName:s.j,backendName:"wasm",setupFunc:function(e){H=e.wasm.cwrap(s.j,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:r,filter:i}=t,d=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(i.dataId).id,{strides:o,dilations:c,pad:p,dimRoundingMode:l,dataFormat:m}=a,b=s.Mb.convertConv2DDataFormat(m),h=s.Mb.computeConv2DInfo(r.shape,i.shape,o,c,p,l,!1,b),f=h.filterHeight,k=h.filterWidth,g=h.padInfo.top,w=h.padInfo.right,I=h.padInfo.bottom,y=h.padInfo.left,M=h.dilationHeight,A=h.dilationWidth,x=h.strideHeight,v=h.strideWidth,F=h.inChannels,S=h.outChannels,N="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);const O=n.makeOutput(h.outShape,"float32"),C=n.dataIdMap.get(O.dataId).id;return H(d,r.shape[0],r.shape[1],r.shape[2],u,f,k,g,w,I,y,N,M,A,x,v,F,S,C),O}};let T;const E={kernelName:s.k,backendName:"wasm",setupFunc:function(e){T=e.wasm.cwrap(s.k,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{dy:r,filter:i}=a,{strides:d,pad:u,dataFormat:o,dimRoundingMode:c,inputShape:p}=n,l=s.Mb.convertConv2DDataFormat(o),m=s.Mb.computeConv2DInfo(p,i.shape,d,1,u,c,!1,l),{batchSize:b,filterHeight:h,filterWidth:f,inChannels:k,inHeight:g,inWidth:w,outChannels:I,outHeight:y,outWidth:M,strideHeight:A,strideWidth:x}=m,v=h-1-m.padInfo.top,F=f-1-m.padInfo.left,S="channelsLast"===m.dataFormat,N=s.vc.computeStrides(m.inShape),O=s.vc.computeStrides(r.shape),[C,z,D]=s.vc.computeStrides(i.shape),W=N[0],H=S?N[1]:N[2],U=S?N[2]:1,E=S?1:N[1],P=O[0],$=S?O[1]:O[2],R=S?O[2]:1,j=S?1:O[1],L=t.makeOutput(m.inShape,"float32"),B=t.dataIdMap.get(L.dataId).id,_=t.dataIdMap.get(r.dataId).id,V=t.dataIdMap.get(i.dataId).id;return T(_,V,b,h,f,g,w,k,y,M,I,A,x,v,F,C,z,D,W,H,U,E,P,$,R,j,B),L}},P=u(s.l);var $;let R;!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}($||($={}));const j={kernelName:s.m,backendName:"wasm",setupFunc:function(e){R=e.wasm.cwrap(s.m,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{method:r,extrapolationValue:s,cropSize:i}=n,{image:d,boxes:u,boxInd:o}=a,c=u.shape[0],[p,l]=i,m=[c,p,l,d.shape[3]];let b,h=t.dataIdMap.get(d.dataId);"float32"!==d.dtype&&(b=N({backend:t,inputs:{x:d},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(b.dataId));const f=h.id,k=t.dataIdMap.get(u.dataId).id,g=t.dataIdMap.get(o.dataId).id,w=t.makeOutput(m,"float32"),I=t.dataIdMap.get(w.dataId).id,y=new Uint8Array(new Int32Array(d.shape).buffer);return R(f,k,g,c,y,p,l,$[r],s,I),null!=b&&t.disposeData(b.dataId),w}};let L;const B={kernelName:s.n,backendName:"wasm",setupFunc:function(e){L=e.wasm.cwrap(s.n,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:r}=e,{x:i}=t,{axis:d,exclusive:u,reverse:o}=r,c=i.shape.length;s.vc.assert("float32"===i.dtype||"int32"===i.dtype,(()=>`cumsum does not support ${i.dtype} tensors in the WASM backend`));const p=s.Mb.getAxesPermutation([d],c);let l=i;null!==p&&(l=k({inputs:{x:i},attrs:{perm:p},backend:a}));const m=s.Mb.getInnerMostAxes(1,c)[0];s.Mb.assertAxesAreInnerMostDims("cumsum",[m],c);const b=a.makeOutput(l.shape,l.dtype),h=l.shape[m],f=a.dataIdMap.get(l.dataId).id,g=a.dataIdMap.get(b.dataId).id;L(f,u?1:0,o?1:0,h,g,n[i.dtype]);let w=b;if(null!==p){w=k({inputs:{x:b},attrs:{perm:s.Mb.getUndoAxesPermutation(p)},backend:a}),a.disposeData(l.dataId),a.disposeData(b.dataId)}return w}};let _;const V={kernelName:s.p,backendName:"wasm",setupFunc:function(e){_=e.wasm.cwrap(s.p,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{x:r}=a,{blockSize:i,dataFormat:d}=n;s.vc.assert(i>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`));const u=r.shape[0],o="NHWC"===d?r.shape[1]:r.shape[2],c="NHWC"===d?r.shape[2]:r.shape[3],p="NHWC"===d?r.shape[3]:r.shape[1],l=o*i,m=c*i,b=p/(i*i),h="NHWC"===d?[u,l,m,b]:[u,b,l,m],f=t.makeOutput(h,"float32"),k=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(s.vc.computeStrides(r.shape)).buffer),w=new Uint8Array(new Int32Array(h).buffer),I=new Uint8Array(new Int32Array(s.vc.computeStrides(h)).buffer),y=t.dataIdMap.get(f.dataId).id;return _(k,i,"NHWC"===d?1:0,g,r.shape.length-1,w,I,h.length,y),f}};let G;const q={kernelName:s.q,backendName:"wasm",setupFunc:function(e){G=e.wasm.cwrap(s.q,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:r,filter:i}=t,d=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(i.dataId).id,{strides:o,dilations:c,pad:p,dimRoundingMode:l}=a,m=null==c?[1,1]:c,b=s.Mb.computeConv2DInfo(r.shape,i.shape,o,m,p,l,!0),h=b.filterHeight,f=b.filterWidth,k=b.padInfo.top,g=b.padInfo.right,w=b.padInfo.bottom,I=b.padInfo.left,y=b.dilationHeight,M=b.dilationWidth,A=b.strideHeight,x=b.strideWidth,v=b.inChannels,F=b.outChannels,S="SAME"===b.padInfo.type?1:0;if("channelsLast"!==b.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${b.dataFormat}'. Please use 'channelsLast'.`);const N=n.makeOutput(b.outShape,"float32"),O=n.dataIdMap.get(N.dataId).id;return G(d,r.shape[0],r.shape[1],r.shape[2],u,h,f,k,g,w,I,S,y,M,A,x,v,F,O),N}},K=c(s.r,!1,"bool"),X=u(s.s);function Y(e){const{inputs:t,attrs:a,backend:n}=e,{input:r}=t,{dim:i}=a,d=r.shape.length,u=r.shape.slice();let o=i;return i<0&&(s.vc.assert(-(d+1)<=i,(()=>`Axis must be in the interval [${-(d+1)}, ${d}]`)),o=d+i+1),u.splice(o,0,1),x({inputs:{x:r},backend:n,attrs:{shape:u}})}const J={kernelName:s.t,backendName:"wasm",kernelFunc:Y};const Z={kernelName:s.u,backendName:"wasm",kernelFunc:function(e){const{attrs:{shape:t,value:a,dtype:n},backend:r}=e,s=r.makeOutput(t,n);return r.typedArrayFromHeap(s).fill(a),s}};let Q;const ee={kernelName:s.v,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a}=e,{image:n}=t,r=a.makeOutput(n.shape,n.dtype),s=a.dataIdMap.get(n.dataId).id,i=a.dataIdMap.get(r.dataId).id,[d,u,o,c]=n.shape;return Q(s,d,u,o,c,i),r},setupFunc:function(e){Q=e.wasm.cwrap(s.v,null,["number","number","number","number","number","number"])}},te=u(s.w),ae=c(s.x,!1);let ne;const re={kernelName:s.y,backendName:"wasm",setupFunc:function(e){ne=e.wasm.cwrap(s.y,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{varianceEpsilon:r}=n,{x:i,mean:d,variance:u,offset:o,scale:c}=a,p=t.dataIdMap.get(i.dataId).id,l=t.dataIdMap.get(d.dataId).id,m=t.dataIdMap.get(u.dataId).id,b=null!=o?t.dataIdMap.get(o.dataId).id:0,h=null!=c?t.dataIdMap.get(c.dataId).id:0,f=t.makeOutput(i.shape,i.dtype);if(0===s.vc.sizeFromShape(i.shape))return f;const k=t.dataIdMap.get(f.dataId).id;return ne(p,l,m,b,h,r,k),f}};let se;const ie={kernelName:s.z,backendName:"wasm",setupFunc:function(e){se=e.wasm.cwrap(s.z,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:i,filter:d,bias:u,preluActivationWeights:o}=t,{strides:c,pad:p,dilations:l,dataFormat:m,dimRoundingMode:b,activation:h,leakyreluAlpha:f}=a,k=s.Mb.computeConv2DInfo(i.shape,d.shape,c,l,p,b),g=r[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);const w=n.dataIdMap.get(i.dataId).id,I=n.dataIdMap.get(d.dataId).id,y=k.outChannels;let M=0;if(null!=u){const e=n.dataIdMap.get(u.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==y)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${y})`);M=e.id}const A=k.filterHeight,x=k.filterWidth,v=k.padInfo.top,F=k.padInfo.right,S=k.padInfo.bottom,N=k.padInfo.left,O=k.dilationHeight,C=k.dilationWidth,z=k.strideHeight,D=k.strideWidth,W=k.inChannels,H="SAME"===k.padInfo.type?1:0,U=k.batchSize,T=k.inHeight,E=k.inWidth;if("NHWC"!==m)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);const P=n.makeOutput(k.outShape,"float32"),$=n.dataIdMap.get(P.dataId).id,R=null==o?0:n.dataIdMap.get(o.dataId).id;return se(w,U,T,E,I,A,x,M,v,F,S,N,H,O,C,z,D,W,y,g,R,f||0,$),P}};let de;const ue={kernelName:s.A,backendName:"wasm",setupFunc:function(e){de=e.wasm.cwrap(s.A,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:i,filter:d,bias:u,preluActivationWeights:o}=t,{strides:c,pad:p,dilations:l,dataFormat:m,dimRoundingMode:b,activation:h,leakyreluAlpha:f}=a,k=s.Mb.computeConv2DInfo(i.shape,d.shape,c,l,p,b,!0),g=r[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const w=n.dataIdMap.get(i.dataId).id,I=n.dataIdMap.get(d.dataId).id,y=k.outChannels;let M=0;if(null!=u){const e=n.dataIdMap.get(u.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==y)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${y})`);M=e.id}const A=k.filterHeight,x=k.filterWidth,v=k.padInfo.top,F=k.padInfo.right,S=k.padInfo.bottom,N=k.padInfo.left,O=k.dilationHeight,C=k.dilationWidth,z=k.strideHeight,D=k.strideWidth,W=k.inChannels,H="SAME"===k.padInfo.type?1:0,U=k.batchSize,T=k.inHeight,E=k.inWidth;if("NHWC"!==m)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);const P=n.makeOutput(k.outShape,"float32"),$=n.dataIdMap.get(P.dataId).id,R=null==o?0:n.dataIdMap.get(o.dataId).id;return de(w,U,T,E,I,A,x,M,v,F,S,N,H,O,C,z,D,W,y,g,R,f||0,$),P}};let oe;const ce={kernelName:s.B,backendName:"wasm",setupFunc:function(e){oe=e.wasm.cwrap(s.B,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:a}=e,{params:r,indices:i}=a,[d,u,o,c]=s.Yb.prepareAndValidate(r,i),p=t.makeOutput(d,r.dtype);if(0===u)return p;const l=i.shape,m=l[l.length-1],b=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(i.dataId).id,f=new Uint8Array(new Int32Array(c).buffer),k=t.dataIdMap.get(p.dataId).id;return oe(b,n[r.dtype],h,u,m,o,f,k),p}};let pe;const le={kernelName:s.C,backendName:"wasm",setupFunc:function(e){pe=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{x:i,indices:d}=a,{axis:u,batchDims:o}=r,c=s.vc.parseAxisParam(u,i.shape)[0],p=s.Mb.segment_util.collectGatherOpShapeInfo(i,d,c,o),l=x({inputs:{x:i},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),m=s.vc.sizeFromShape(d.shape),b=x({inputs:{x:d},attrs:{shape:[p.batchSize,m/p.batchSize]},backend:t}),h=[p.batchSize,p.outerSize,m/p.batchSize,p.sliceSize],f=t.makeOutput(h,i.dtype);if(0===s.vc.sizeFromShape(i.shape))return f;const k=l.shape.length-1,g=t.dataIdMap.get(l.dataId).id,w=t.dataIdMap.get(b.dataId).id,I=t.dataIdMap.get(f.dataId).id,y=new Uint8Array(new Int32Array(s.vc.computeStrides(l.shape)).buffer),M=new Uint8Array(new Int32Array(s.vc.computeStrides(h)).buffer);return pe(g,n[i.dtype],y,k,w,p.batchSize,M,I),f.shape=p.outputShape,f}},me=c(s.D,!1,"bool"),be=c(s.E,!1,"bool");let he;const fe={kernelName:s.H,backendName:"wasm",setupFunc:function(e){he=e.wasm.cwrap(s.H,null,["number","number","number"])},kernelFunc:function(e){const{inputs:{x:t},attrs:{alpha:a},backend:n}=e,r=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(t.shape,t.dtype);if(0!==s.vc.sizeFromShape(t.shape)){const e=n.dataIdMap.get(i.dataId).id;he(r,a,e)}return i}},ke=c(s.I,!1,"bool"),ge=c(s.J,!1,"bool"),we=u(s.K),Ie=c(s.L,!1,"bool");let ye;const Me={kernelName:s.M,backendName:"wasm",setupFunc:function(e){ye=e.wasm.cwrap(s.M,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{reductionIndices:r,keepDims:i}=n,{x:d}=a;let u=t.dataIdMap.get(d.dataId).id,o=d;const{transposed:c,axes:p,originalAxes:l,inputWasTransposed:m}=w(d,r,t);if(m){o=c,u=t.dataIdMap.get(c.dataId).id}const b=o.shape.length;s.Mb.assertAxesAreInnerMostDims("max",p,b);const[h,f]=s.Mb.computeOutAndReduceShapes(o.shape,p),k=s.vc.sizeFromShape(f),g=t.makeOutput(h,d.dtype);if(0!==s.vc.sizeFromShape(o.shape)){const e=t.dataIdMap.get(g.dataId).id;ye(u,k,e)}if(m&&t.disposeData(c.dataId),i){const e=s.Mb.expandShapeToKeepDim(g.shape,l);g.shape=e}return g}},Ae=c(s.O,!1);let xe;const ve={kernelName:s.N,backendName:"wasm",setupFunc:function(e){xe=e.wasm.cwrap(s.N,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,r=t.x,i=n.dataIdMap.get(r.dataId).id,{filterSize:d,strides:u,pad:o,dimRoundingMode:c}=a,p=s.Mb.computePool2DInfo(r.shape,d,u,1,o,c),l=p.filterHeight,m=p.filterWidth,b=p.padInfo.top,h=p.padInfo.right,f=p.padInfo.bottom,k=p.padInfo.left,g=p.dilationHeight,w=p.dilationWidth,I=p.strideHeight,y=p.strideWidth,M=p.inChannels,A=p.outChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);const x=n.makeOutput(p.outShape,"float32"),v=n.dataIdMap.get(x.dataId).id;return xe(i,r.shape[0],r.shape[1],r.shape[2],l,m,b,h,f,k,g,w,I,y,M,A,v),x}};let Fe;const Se={kernelName:s.P,backendName:"wasm",setupFunc:function(e){Fe=e.wasm.cwrap(s.P,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,originalAxes:m,inputWasTransposed:b}=w(d,r,t);let h=l;if(b){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e,h=s.Mb.getInnerMostAxes(h.length,c.shape.length))}s.Mb.assertAxesAreInnerMostDims("mean",h,c.shape.length);const[f,k]=s.Mb.computeOutAndReduceShapes(c.shape,h),g=s.vc.sizeFromShape(k);let I=c;"float32"!==c.dtype&&(I=N({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),o=t.dataIdMap.get(I.dataId).id);const y=t.makeOutput(f,"float32");if(0!==s.vc.sizeFromShape(c.shape)){const e=t.dataIdMap.get(y.dataId).id;Fe(o,g,e)}if(b&&t.disposeData(p.dataId),i){const e=s.Mb.expandShapeToKeepDim(y.shape,m);y.shape=e}return"float32"!==c.dtype&&t.disposeData(I.dataId),y}};let Ne;const Oe={kernelName:s.Q,backendName:"wasm",setupFunc:function(e){Ne=e.wasm.cwrap(s.Q,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,originalAxes:m,inputWasTransposed:b}=w(d,r,t);if(b){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e)}const h=c.shape.length;s.Mb.assertAxesAreInnerMostDims("min",l,h);const[f,k]=s.Mb.computeOutAndReduceShapes(c.shape,l),g=s.vc.sizeFromShape(k),I=t.makeOutput(f,c.dtype);if(0!==s.vc.sizeFromShape(c.shape)){const e=t.dataIdMap.get(I.dataId).id;Ne(o,g,e)}if(b&&t.disposeData(p.dataId),i){const e=s.Mb.expandShapeToKeepDim(I.shape,m);I.shape=e}return I}},Ce=c(s.R,!1),ze=c(s.S,!0),De=u(s.T);function We(e,t){const a=new Int32Array(e.wasm.HEAPU8.buffer,t,4),n=a[0],r=a[1],s=a[2],i=a[3];return e.wasm._free(t),{pSelectedIndices:n,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}let He;const Ue={kernelName:s.U,backendName:"wasm",setupFunc:function(e){He=e.wasm.cwrap(s.U,"number",["number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=n,{boxes:d,scores:u}=a,o=t.dataIdMap.get(d.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=He(o,c,s,r,i),{pSelectedIndices:l,selectedSize:m,pSelectedScores:b,pValidOutputs:h}=We(t,p);return t.wasm._free(b),t.wasm._free(h),t.makeOutput([m],"int32",l)}};let Te;const Ee={kernelName:s.V,backendName:"wasm",setupFunc:function(e){Te=e.wasm.cwrap(s.V,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:d}=n,{boxes:u,scores:o}=a,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(o.dataId).id,l=Te(c,p,s,r,i,d),{pSelectedIndices:m,selectedSize:b,pSelectedScores:h,pValidOutputs:f}=We(t,l);return t.wasm._free(h),[t.makeOutput([b],"int32",m),t.makeOutput([],"int32",f)]}};let Pe;const $e={kernelName:s.W,backendName:"wasm",setupFunc:function(e){Pe=e.wasm.cwrap(s.W,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:d}=n,{boxes:u,scores:o}=a,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(o.dataId).id,l=Pe(c,p,s,r,i,d),{pSelectedIndices:m,selectedSize:b,pSelectedScores:h,pValidOutputs:f}=We(t,l);return t.wasm._free(f),[t.makeOutput([b],"int32",m),t.makeOutput([b],"float32",h)]}},Re=c(s.X,!1,"bool");let je;const Le={kernelName:s.Y,backendName:"wasm",setupFunc:function(e){je=e.wasm.cwrap(s.Y,null,["number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{indices:r}=t,{depth:s,onValue:i,offValue:d}=n,u=a.makeOutput([...r.shape,s],"int32"),o=a.dataIdMap.get(u.dataId).id,c=a.dataIdMap.get(r.dataId).id;return je(c,s,i,d,o),u}};const Be={kernelName:s.Z,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype);return a.typedArrayFromHeap(n).fill(1),n}};const _e={kernelName:s.ab,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{axis:r}=n;if(1===t.length)return Y({inputs:{input:t[0]},backend:a,attrs:{dim:r}});const i=t[0].shape,d=t[0].dtype;return t.forEach((e=>{s.vc.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),s.vc.assert(d===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))})),D({inputs:t.map((e=>Y({inputs:{input:e},backend:a,attrs:{dim:r}}))),backend:a,attrs:{axis:r}})}};let Ve;const Ge={kernelName:s.bb,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:a,attrs:{paddings:r,constantValue:s}}=e,i=r.map(((e,a)=>e[0]+t.shape[a]+e[1])),d=a.dataIdMap.get(t.dataId).id,u=a.makeOutput(i,t.dtype),o=a.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),l=r.map((e=>e[1])),m=new Uint8Array(new Int32Array(p).buffer),b=new Uint8Array(new Int32Array(l).buffer);return Ve(d,c,t.shape.length,n[t.dtype],m,b,s,o),u},setupFunc:function(e){Ve=e.wasm.cwrap(s.bb,null,["number","array","number","number","array","array","number","number"])}},qe=c(s.cb,!1);let Ke;const Xe={kernelName:s.db,backendName:"wasm",setupFunc:function(e){Ke=e.wasm.cwrap(s.db,null,["number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a}=e,{x:n,alpha:r}=t,s=a.dataIdMap.get(n.dataId).id,i=a.dataIdMap.get(r.dataId).id,d=a.makeOutput(n.shape,"float32"),u=a.dataIdMap.get(d.dataId).id;return Ke(s,i,u),d}};let Ye;const Je={kernelName:s.eb,backendName:"wasm",setupFunc:function(e){Ye=e.wasm.cwrap(s.eb,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{axis:i,keepDims:d}=r,{x:u}=a,o=t.dataIdMap.get(u.dataId).id;let c=o,p=u;const{transposed:l,axes:m,originalAxes:b,inputWasTransposed:h}=w(u,i,t);let f=m;if(h){const e=t.dataIdMap.get(l.dataId).id;e!==o&&(p=l,c=e,f=s.Mb.getInnerMostAxes(f.length,p.shape.length))}s.Mb.assertAxesAreInnerMostDims("prod",f,p.shape.length);const[k,g]=s.Mb.computeOutAndReduceShapes(p.shape,f),I=s.vc.sizeFromShape(g),y=t.makeOutput(k,p.dtype);if(0!==s.vc.sizeFromShape(p.shape)){const e=t.dataIdMap.get(y.dataId).id;Ye(c,I,n[y.dtype],e)}if(h&&t.disposeData(l.dataId),d){const e=s.Mb.expandShapeToKeepDim(y.shape,b);y.shape=e}return y}};const Ze={kernelName:s.fb,backendName:"wasm",kernelFunc:e=>{const{backend:t,attrs:a}=e,{start:n,stop:r,step:i,dtype:d}=a,u=function(e,t,a,n){if(e===t||e<t&&a<0||t<e&&a>1)return s.vc.makeZerosTypedArray(0,n);const r=Math.abs(Math.ceil((t-e)/a)),i=s.vc.makeZerosTypedArray(r,n);t<e&&1===a&&(a=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+a;return i}(n,r,i,d),o=t.makeOutput([u.length],d);return t.typedArrayFromHeap(o).set(u),o}},Qe=c(s.gb,!0),et=u(s.hb),tt=u(s.ib);let at;const nt={kernelName:s.kb,backendName:"wasm",setupFunc:function(e){at=e.wasm.cwrap(s.kb,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{images:r}=a,{alignCorners:i,halfPixelCenters:d,size:u}=n,[o,c]=u,[p,l,m,b]=r.shape,h=[p,o,c,b];let f,k=t.dataIdMap.get(r.dataId);"float32"!==k.dtype&&(f=N({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),k=t.dataIdMap.get(f.dataId));const g=k.id,w=t.makeOutput(h,"float32");if(0===s.vc.sizeFromShape(r.shape))return w;const I=t.dataIdMap.get(w.dataId).id;return at(g,p,l,m,b,o,c,i?1:0,d?1:0,I),null!=f&&t.disposeData(f.dataId),w}};let rt;const st={kernelName:s.lb,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{dims:i}=n,d=s.vc.parseAxisParam(i,r.shape);if(0===r.shape.length)return b({inputs:{x:r},backend:a});const u=a.makeOutput(r.shape,r.dtype),o=a.dataIdMap.get(r.dataId).id,c=a.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(d).buffer),l=new Uint8Array(new Int32Array(r.shape).buffer);return rt(o,p,d.length,l,r.shape.length,c),x({inputs:{x:u},attrs:{shape:r.shape},backend:a})},setupFunc:function(e){rt=e.wasm.cwrap(s.lb,null,["number","array","number","array","number","number"])}};let it;const dt={kernelName:s.mb,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{image:r}=t,{radians:i,fillValue:d,center:u}=n,o=a.makeOutput(r.shape,r.dtype),c=a.dataIdMap.get(r.dataId).id,p=a.dataIdMap.get(o.dataId).id,[l,m,b,h]=r.shape,[f,k]=s.Mb.getImageCenter(u,m,b),g="number"==typeof d?[d,d,d,0===d?0:255]:[...d,255],w=new Uint8Array(new Int32Array(g).buffer);return it(c,l,m,b,h,i,f,k,w,g.length,p),o},setupFunc:function(e){it=e.wasm.cwrap(s.mb,null,["number","number","number","number","number","number","number","number","array","number","number"])}},ut=u(s.nb),ot=u(s.ob);let ct;const pt={kernelName:s.pb,backendName:"wasm",setupFunc:function(e){ct=e.wasm.cwrap(s.pb,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:r}=e,{indices:i,updates:d}=a,{shape:u}=r,o=t.makeOutput(u,d.dtype);if(0===s.vc.sizeFromShape(u))return o;const{sliceRank:c,numUpdates:p,sliceSize:l,strides:m,outputSize:b}=s.ic.calculateShapes(d,i,u),h=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(d.dataId).id,k=new Uint8Array(new Int32Array(m).buffer),g=t.dataIdMap.get(o.dataId).id;return ct(h,f,n[d.dtype],c,p,l,k,b,g),o}};let lt;const mt={kernelName:s.qb,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a}=e,{condition:n,t:r,e:i}=t,d=a.dataIdMap.get(n.dataId).id,u=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(i.dataId).id,c=a.makeOutput(r.shape,r.dtype),p=a.dataIdMap.get(c.dataId).id,l=n.shape.length,m=r.shape.length,b=0===l||l>1||1===m?1:s.vc.sizeFromShape(r.shape.slice(1));return lt(d,u,o,b,p),c},setupFunc:function(e){lt=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}};let bt;const ht={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){bt=e.wasm.cwrap(s.rb,null,["number","number"])},kernelFunc:function(e){const{backend:t,inputs:{x:a}}=e,n=t.dataIdMap.get(a.dataId).id,r=t.makeOutput(a.shape,a.dtype),i=t.dataIdMap.get(r.dataId).id;return 0===s.vc.sizeFromShape(r.shape)||bt(n,i),r}},ft=u(s.sb);function kt(e,t,a,n,r){const i=s.mc.isSliceContinous(n,t,a),d=s.vc.sizeFromShape(a),u=s.vc.computeStrides(n);if(i){const a=s.mc.computeFlatOffset(t,u);return"string"===r?e.slice(a,a+d):e.subarray(a,a+d)}const o="string"===r?s.Mb.fromUint8ToStringArray(e):e,c=Object(s.Ob)(n,r,o),p=Object(s.Ob)(a,r);for(let e=0;e<p.size;++e){const a=p.indexToLoc(e),n=a.map(((e,a)=>e+t[a]));p.set(c.get(...n),...a)}return"string"===r?s.Mb.fromStringArrayToUint8(p.values):p.values}s.tb;function gt(e){const{inputs:{x:t},attrs:{begin:a,size:n},backend:r}=e,[i,d]=s.mc.parseSliceParams(t,a,n),u=s.mc.isSliceContinous(t.shape,i,d),o=r.readSync(t.dataId),c=r.makeOutput(d,t.dtype),p=s.vc.computeStrides(t.shape),l=r.dataIdMap.get(c.dataId);if(u){const e=s.mc.computeFlatOffset(i,p);if("string"===t.dtype)l.stringBytes=o.slice(e,e+s.vc.sizeFromShape(d));else{r.typedArrayFromHeap(c).set(o.subarray(e,e+s.vc.sizeFromShape(d)))}return c}if("string"===t.dtype){const e=kt(o,i,d,t.shape,t.dtype);return l.stringBytes=e,c}const m=r.typedArrayFromHeap(c),b=t.shape.length;if(2===b)!function(e,t,a,n,r){let s=0;const i=n[0],d=n[1],u=i+r[0];for(let n=i;n<u;n++){const i=n*t+d;a.set(e.subarray(i,i+r[1]),s),s+=r[1]}}(o,p[0],m,i,d);else if(3===b)!function(e,t,a,n,r,s){let i=0;const d=r[0],u=r[1],o=r[2],c=d+s[0],p=u+s[1];for(let r=d;r<c;r++)for(let d=u;d<p;d++){const u=r*t+d*a+o;n.set(e.subarray(u,u+s[2]),i),i+=s[2]}}(o,p[0],p[1],m,i,d);else if(4===b)!function(e,t,a,n,r,s,i){let d=0;const u=s[0],o=s[1],c=s[2],p=u+i[0],l=o+i[1],m=c+i[2],b=s[3];for(let s=u;s<p;s++)for(let u=o;u<l;u++)for(let o=c;o<m;o++){const c=s*t+u*a+o*n+b;r.set(e.subarray(c,c+i[3]),d),d+=i[3]}}(o,p[0],p[1],p[2],m,i,d);else{const e=kt(o,i,d,t.shape,t.dtype);m.set(e)}return c}let wt;let It;let yt;let Mt;let At;let xt;const vt=[o,p,m,y,A,S,O,z,W,U,E,P,j,B,V,q,K,X,J,Z,ee,te,ae,d,re,ie,ue,ce,le,me,be,h,fe,ke,ge,we,Ie,Me,Ae,ve,Se,Oe,Ce,ze,De,Ue,Ee,$e,Re,Le,Be,_e,Ge,qe,Xe,Je,Ze,Qe,et,tt,v,nt,st,dt,ot,ut,pt,mt,ht,ft,{kernelName:s.tb,backendName:"wasm",kernelFunc:gt},{kernelName:s.ub,backendName:"wasm",setupFunc:function(e){wt=e.wasm.cwrap(s.ub,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:{logits:a},attrs:{dim:n}}=e,r=t.dataIdMap.get(a.dataId).id,i=t.makeOutput(a.shape,a.dtype),d=t.dataIdMap.get(i.dataId).id,u=a.shape[n],o=s.vc.sizeFromShape(a.shape)/u;return 0===s.vc.sizeFromShape(i.shape)||wt(r,d,u,o),i}},{kernelName:s.vb,backendName:"wasm",kernelFunc:function(e){const{inputs:t,attrs:a,backend:n}=e,{x:r}=t,{numOrSizeSplits:i,axis:d}=a,u=s.vc.parseAxisParam(d,r.shape)[0],o=s.Mb.prepareSplitSize(r,i,u),c=new Array(r.shape.length).fill(0),p=r.shape.slice();return o.map((e=>{const t=[...p];t[u]=e;const a=gt({inputs:{x:r},attrs:{begin:c,size:t},backend:n});return c[u]+=e,a}))}},u(s.wb),u(s.xb),c(s.yb,!0),{kernelName:s.zb,backendName:"wasm",setupFunc:function(e){It=e.wasm.cwrap(s.zb,null,["number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{alpha:r}=n,{x:s}=a,i=t.dataIdMap.get(s.dataId).id,d=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(d.dataId).id;return It(i,r,u),d}},{kernelName:s.Ab,backendName:"wasm",setupFunc:function(e){yt=e.wasm.cwrap(s.Ab,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{x:r}=a;let{begin:i,end:d,strides:u}=n;null==u&&(u=new Array(i.length));const{beginMask:o,endMask:c,ellipsisMask:p,newAxisMask:l,shrinkAxisMask:m}=n,b=s.Mb.slice_util.maskToAxes(p);if(b.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==p&&0!==l)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==p&&0!==m)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const h=r.shape.length-i.length,f=s.Mb.slice_util.maskToAxes(l),k=r.shape.slice();f.forEach((e=>{i[e]=0,d[e]=1,k.splice(e,0,1)}));const g=x({inputs:{x:r},attrs:{shape:k},backend:t}),{begin:w,end:I,strides:y}=s.Mb.slice_util.getNormalizedAxes(g.shape,b,h,i,d,u,o,c,p);i=w,d=I,u=y;const M=s.Mb.slice_util.maskToAxes(m);M.forEach((e=>{d[e]=i[e]+1,u[e]=1}));const A=s.Mb.slice_util.computeOutShape(i,d,u),v=A.filter(((e,t)=>-1===M.indexOf(t)));if(u.every((e=>1===e))){return x({inputs:{x:gt({inputs:{x:r},attrs:{begin:i,size:A},backend:t})},attrs:{shape:v},backend:t})}const F=t.makeOutput(v,"float32");if(!v.some((e=>0===e))){const e=t.dataIdMap.get(g.dataId).id,a=new Uint8Array(new Int32Array(s.vc.computeStrides(g.shape)).buffer),n=new Uint8Array(new Int32Array(i).buffer),r=new Uint8Array(new Int32Array(d).buffer),o=new Uint8Array(new Int32Array(u).buffer),c=new Uint8Array(new Int32Array(v).buffer),p=new Uint8Array(new Int32Array(s.vc.computeStrides(v)).buffer),l=t.dataIdMap.get(F.dataId).id;yt(e,a,g.shape.length,n,r,o,c,p,v.length,l)}return x({inputs:{x:F},attrs:{shape:v},backend:t})}},c(s.Bb,!0),{kernelName:s.Cb,backendName:"wasm",setupFunc:function(e){Mt=e.wasm.cwrap(s.Cb,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:i}=n,{x:d}=a,u=t.dataIdMap.get(d.dataId).id;let o=u,c=d;const{transposed:p,axes:l,originalAxes:m,inputWasTransposed:b}=w(d,r,t);let h=l;if(b){const e=t.dataIdMap.get(p.dataId).id;e!==u&&(c=p,o=e,h=s.Mb.getInnerMostAxes(h.length,c.shape.length))}s.Mb.assertAxesAreInnerMostDims("sum",h,c.shape.length);const[f,k]=s.Mb.computeOutAndReduceShapes(c.shape,h),g=s.vc.sizeFromShape(k),I=t.makeOutput(f,c.dtype);if(0!==s.vc.sizeFromShape(c.shape)){const e=t.dataIdMap.get(I.dataId).id;Mt(o,g,e)}if(b&&t.disposeData(p.dataId),i){const e=s.Mb.expandShapeToKeepDim(I.shape,m);I.shape=e}return I}},u(s.Db),{kernelName:s.Fb,backendName:"wasm",setupFunc:function(e){At=e.wasm.cwrap(s.Fb,null,["number","array","number","array","number","number"])},kernelFunc:function(e){const{inputs:t,backend:a,attrs:r}=e,{x:s}=t,i=a.dataIdMap.get(s.dataId).id,{reps:d}=r,u=new Array(s.shape.length);for(let e=0;e<u.length;e++)u[e]=s.shape[e]*d[e];const o=new Uint8Array(new Int32Array(s.shape).buffer),c=new Uint8Array(new Int32Array(u).buffer),p=a.makeOutput(u,s.dtype),l=a.dataIdMap.get(p.dataId).id;return At(i,o,s.shape.length,c,u.length,n[p.dtype],l),p}},{kernelName:s.Gb,backendName:"wasm",setupFunc:function(e){xt=e.wasm.cwrap(s.Gb,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:a})=>{const{x:r}=e,{k:s,sorted:i}=a,d=t.dataIdMap.get(r.dataId).id,u=new Uint8Array(new Int32Array(r.shape).buffer),o=r.shape.slice();o[o.length-1]=s;const c=t.makeOutput(o,r.dtype),p=t.dataIdMap.get(c.dataId).id,l=t.makeOutput(o,"int32"),m=t.dataIdMap.get(l.dataId).id;return xt(d,u,r.shape.length,n[r.dtype],s,i,p,m),[c,l]}},g,{kernelName:s.Ib,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:a,attrs:n}=e,{value:r}=t;let{axis:s}=n;s<0&&(s+=r.shape.length);const i=r.shape[s],d=r.shape.length,u=new Array(d-1);let o=0;for(let e=0;e<d;e++)e!==s&&(u[o++]=r.shape[e]);const c=new Array(i),p=new Array(d).fill(0),l=r.shape.slice();l[s]=1;for(let e=0;e<c.length;e++)p[s]=e,c[e]=gt({inputs:{x:r},attrs:{begin:p,size:l},backend:a});return c.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:u})))}},{kernelName:s.Jb,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype);return a.typedArrayFromHeap(n).fill(0),n}}];for(const e of vt)Object(s.fc)(e);const Ft=Object(s.Wb)();Ft.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])))),Ft.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(Ft.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var St=a(235),Nt=a.n(St),Ot=a(432),Ct=a(433),zt=a.n(Ct);class Dt extends s.G{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.init(),this.dataIdMap=new s.o(this,Object(s.Vb)())}write(e,t,a){const n={};return this.move(n,e,t,a),n}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=s.vc.now();e();return{kernelMs:s.vc.now()-t}}move(e,t,a,n){const r=this.dataIdNextNumber++;if("string"===n){const s=t;return void this.dataIdMap.set(e,{id:r,stringBytes:s,shape:a,dtype:n,memoryOffset:null})}const i=s.vc.sizeFromShape(a),d=i*s.vc.bytesPerElement(n),u=this.wasm._malloc(d);this.dataIdMap.set(e,{id:r,memoryOffset:u,shape:a,dtype:n}),this.wasm.tfjs.registerTensor(r,i,u),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,d),u)}async read(e){return this.readSync(e)}readSync(e){const{memoryOffset:t,dtype:a,shape:n,stringBytes:r}=this.dataIdMap.get(e);if("string"===a)return r;return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(t,t+s.vc.sizeFromShape(n)*s.vc.bytesPerElement(a)).buffer,a)}disposeData(e){const t=this.dataIdMap.get(e);this.wasm._free(t.memoryOffset),this.wasm.tfjs.disposeData(t.id),this.dataIdMap.delete(e)}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,a){let n;if(null==a)n=this.write(null,e,t);else{n={};const r=this.dataIdNextNumber++;this.dataIdMap.set(n,{id:r,memoryOffset:a,shape:e,dtype:t});const i=s.vc.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,i,a)}return{dataId:n,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:a}){const n=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(a),i=s.vc.sizeFromShape(e);switch(t){case"float32":return new Float32Array(n,r,i);case"int32":return new Int32Array(n,r,i);case"bool":return new Uint8Array(n,r,i);default:throw new Error(`Unknown dtype ${t}`)}}}function Wt(e,t,a){if(null!=Tt)return Tt;let n="tfjs-backend-wasm.wasm";return e&&t?n="tfjs-backend-wasm-threaded-simd.wasm":e&&(n="tfjs-backend-wasm-simd.wasm"),null!=Pt&&null!=Pt[n]?Pt[n]:a+n}async function Ht(){const[e,t]=await Promise.all([Object(s.Wb)().getAsync("WASM_HAS_SIMD_SUPPORT"),Object(s.Wb)().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((a,n)=>{const r={};var i;let d;r.locateFile=(a,n)=>{if(a.endsWith(".worker.js")){const e=Ot.a,t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return a.endsWith(".wasm")?Wt(e,t,null!=Et?Et:n):n+a},Rt&&(r.instantiateWasm=(i=Wt(e,t,null!=Et?Et:""),(e,t)=>(s.vc.fetch(i,{credentials:"same-origin"}).then((a=>{a.ok||e.env.a(`failed to load wasm binary file at '${i}'`),a.arrayBuffer().then((a=>{WebAssembly.instantiate(a,e).then((e=>{t(e.instance)}))}))})),{}))),t&&e&&null==Tt?(d=Nt()(r),d.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Nt.a.toString()],{type:"text/javascript"})):d=zt()(r);d.tfjs={init:d.cwrap("init",null,[]),registerTensor:d.cwrap("register_tensor",null,["number","number","number"]),disposeData:d.cwrap("dispose_data",null,["number"]),dispose:d.cwrap("dispose",null,[])};let u=!1;d.onRuntimeInitialized=()=>{u=!0,$t=!1,a({wasm:d})},d.onAbort=()=>{if(u)return;if($t)return;$t=!0;n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})}}))}const Ut=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let Tt=null,Et=null,Pt={},$t=!1,Rt=!1;function jt(e,t=!1){if($t)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)Et=e;else{Pt=e;const t=Ut.filter((e=>null==Pt[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Rt=t}Object(s.ec)("wasm",(async()=>{const{wasm:e}=await Ht();return new Dt(e)}),2)},544:function(e,t){},547:function(e,t){},548:function(e,t){},554:function(e,t,a){"use strict";var n=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,r=function(e){var t={};return function(a){return void 0===t[a]&&(t[a]=e(a)),t[a]}}((function(e){return n.test(e)||111===e.charCodeAt(0)&&110===e.charCodeAt(1)&&e.charCodeAt(2)<91}));t.a=r},571:function(e,t,a){"use strict";t.a=function(e){function t(e,n,u,o,l){for(var m,b,h,f,I,M=0,A=0,x=0,v=0,F=0,D=0,H=h=m=0,T=0,E=0,P=0,$=0,R=u.length,j=R-1,L="",B="",_="",V="";T<R;){if(b=u.charCodeAt(T),T===j&&0!==A+v+x+M&&(0!==A&&(b=47===A?10:47),v=x=M=0,R++,j++),0===A+v+x+M){if(T===j&&(0<E&&(L=L.replace(p,"")),0<L.trim().length)){switch(b){case 32:case 9:case 59:case 13:case 10:break;default:L+=u.charAt(T)}b=59}switch(b){case 123:for(m=(L=L.trim()).charCodeAt(0),h=1,$=++T;T<R;){switch(b=u.charCodeAt(T)){case 123:h++;break;case 125:h--;break;case 47:switch(b=u.charCodeAt(T+1)){case 42:case 47:e:{for(H=T+1;H<j;++H)switch(u.charCodeAt(H)){case 47:if(42===b&&42===u.charCodeAt(H-1)&&T+2!==H){T=H+1;break e}break;case 10:if(47===b){T=H+1;break e}}T=H}}break;case 91:b++;case 40:b++;case 34:case 39:for(;T++<j&&u.charCodeAt(T)!==b;);}if(0===h)break;T++}switch(h=u.substring($,T),0===m&&(m=(L=L.replace(c,"").trim()).charCodeAt(0)),m){case 64:switch(0<E&&(L=L.replace(p,"")),b=L.charCodeAt(1)){case 100:case 109:case 115:case 45:E=n;break;default:E=z}if($=(h=t(n,E,h,b,l+1)).length,0<W&&(I=d(3,h,E=a(z,L,P),n,N,S,$,b,l,o),L=E.join(""),void 0!==I&&0===($=(h=I.trim()).length)&&(b=0,h="")),0<$)switch(b){case 115:L=L.replace(y,i);case 100:case 109:case 45:h=L+"{"+h+"}";break;case 107:h=(L=L.replace(k,"$1 $2"))+"{"+h+"}",h=1===C||2===C&&s("@"+h,3)?"@-webkit-"+h+"@"+h:"@"+h;break;default:h=L+h,112===o&&(B+=h,h="")}else h="";break;default:h=t(n,a(n,L,P),h,o,l+1)}_+=h,h=P=E=H=m=0,L="",b=u.charCodeAt(++T);break;case 125:case 59:if(1<($=(L=(0<E?L.replace(p,""):L).trim()).length))switch(0===H&&(m=L.charCodeAt(0),45===m||96<m&&123>m)&&($=(L=L.replace(" ",":")).length),0<W&&void 0!==(I=d(1,L,n,e,N,S,B.length,o,l,o))&&0===($=(L=I.trim()).length)&&(L="\0\0"),m=L.charCodeAt(0),b=L.charCodeAt(1),m){case 0:break;case 64:if(105===b||99===b){V+=L+u.charAt(T);break}default:58!==L.charCodeAt($-1)&&(B+=r(L,m,b,L.charCodeAt(2)))}P=E=H=m=0,L="",b=u.charCodeAt(++T)}}switch(b){case 13:case 10:47===A?A=0:0===1+m&&107!==o&&0<L.length&&(E=1,L+="\0"),0<W*U&&d(0,L,n,e,N,S,B.length,o,l,o),S=1,N++;break;case 59:case 125:if(0===A+v+x+M){S++;break}default:switch(S++,f=u.charAt(T),b){case 9:case 32:if(0===v+M+A)switch(F){case 44:case 58:case 9:case 32:f="";break;default:32!==b&&(f=" ")}break;case 0:f="\\0";break;case 12:f="\\f";break;case 11:f="\\v";break;case 38:0===v+A+M&&(E=P=1,f="\f"+f);break;case 108:if(0===v+A+M+O&&0<H)switch(T-H){case 2:112===F&&58===u.charCodeAt(T-3)&&(O=F);case 8:111===D&&(O=D)}break;case 58:0===v+A+M&&(H=T);break;case 44:0===A+x+v+M&&(E=1,f+="\r");break;case 34:case 39:0===A&&(v=v===b?0:0===v?b:v);break;case 91:0===v+A+x&&M++;break;case 93:0===v+A+x&&M--;break;case 41:0===v+A+M&&x--;break;case 40:if(0===v+A+M){if(0===m)switch(2*F+3*D){case 533:break;default:m=1}x++}break;case 64:0===A+x+v+M+H+h&&(h=1);break;case 42:case 47:if(!(0<v+M+x))switch(A){case 0:switch(2*b+3*u.charCodeAt(T+1)){case 235:A=47;break;case 220:$=T,A=42}break;case 42:47===b&&42===F&&$+2!==T&&(33===u.charCodeAt($+2)&&(B+=u.substring($,T+1)),f="",A=0)}}0===A&&(L+=f)}D=F,F=b,T++}if(0<($=B.length)){if(E=n,0<W&&(void 0!==(I=d(2,B,E,e,N,S,$,o,l,o))&&0===(B=I).length))return V+B+_;if(B=E.join(",")+"{"+B+"}",0!=C*O){switch(2!==C||s(B,2)||(O=0),O){case 111:B=B.replace(w,":-moz-$1")+B;break;case 112:B=B.replace(g,"::-webkit-input-$1")+B.replace(g,"::-moz-$1")+B.replace(g,":-ms-input-$1")+B}O=0}}return V+B+_}function a(e,t,a){var r=t.trim().split(h);t=r;var s=r.length,i=e.length;switch(i){case 0:case 1:var d=0;for(e=0===i?"":e[0]+" ";d<s;++d)t[d]=n(e,t[d],a).trim();break;default:var u=d=0;for(t=[];d<s;++d)for(var o=0;o<i;++o)t[u++]=n(e[o]+" ",r[d],a).trim()}return t}function n(e,t,a){var n=t.charCodeAt(0);switch(33>n&&(n=(t=t.trim()).charCodeAt(0)),n){case 38:return t.replace(f,"$1"+e.trim());case 58:return e.trim()+t.replace(f,"$1"+e.trim());default:if(0<1*a&&0<t.indexOf("\f"))return t.replace(f,(58===e.charCodeAt(0)?"":"$1")+e.trim())}return e+t}function r(e,t,a,n){var i=e+";",d=2*t+3*a+4*n;if(944===d){e=i.indexOf(":",9)+1;var u=i.substring(e,i.length-1).trim();return u=i.substring(0,e).trim()+u+";",1===C||2===C&&s(u,1)?"-webkit-"+u+u:u}if(0===C||2===C&&!s(i,1))return i;switch(d){case 1015:return 97===i.charCodeAt(10)?"-webkit-"+i+i:i;case 951:return 116===i.charCodeAt(3)?"-webkit-"+i+i:i;case 963:return 110===i.charCodeAt(5)?"-webkit-"+i+i:i;case 1009:if(100!==i.charCodeAt(4))break;case 969:case 942:return"-webkit-"+i+i;case 978:return"-webkit-"+i+"-moz-"+i+i;case 1019:case 983:return"-webkit-"+i+"-moz-"+i+"-ms-"+i+i;case 883:if(45===i.charCodeAt(8))return"-webkit-"+i+i;if(0<i.indexOf("image-set(",11))return i.replace(F,"$1-webkit-$2")+i;break;case 932:if(45===i.charCodeAt(4))switch(i.charCodeAt(5)){case 103:return"-webkit-box-"+i.replace("-grow","")+"-webkit-"+i+"-ms-"+i.replace("grow","positive")+i;case 115:return"-webkit-"+i+"-ms-"+i.replace("shrink","negative")+i;case 98:return"-webkit-"+i+"-ms-"+i.replace("basis","preferred-size")+i}return"-webkit-"+i+"-ms-"+i+i;case 964:return"-webkit-"+i+"-ms-flex-"+i+i;case 1023:if(99!==i.charCodeAt(8))break;return"-webkit-box-pack"+(u=i.substring(i.indexOf(":",15)).replace("flex-","").replace("space-between","justify"))+"-webkit-"+i+"-ms-flex-pack"+u+i;case 1005:return m.test(i)?i.replace(l,":-webkit-")+i.replace(l,":-moz-")+i:i;case 1e3:switch(t=(u=i.substring(13).trim()).indexOf("-")+1,u.charCodeAt(0)+u.charCodeAt(t)){case 226:u=i.replace(I,"tb");break;case 232:u=i.replace(I,"tb-rl");break;case 220:u=i.replace(I,"lr");break;default:return i}return"-webkit-"+i+"-ms-"+u+i;case 1017:if(-1===i.indexOf("sticky",9))break;case 975:switch(t=(i=e).length-10,d=(u=(33===i.charCodeAt(t)?i.substring(0,t):i).substring(e.indexOf(":",7)+1).trim()).charCodeAt(0)+(0|u.charCodeAt(7))){case 203:if(111>u.charCodeAt(8))break;case 115:i=i.replace(u,"-webkit-"+u)+";"+i;break;case 207:case 102:i=i.replace(u,"-webkit-"+(102<d?"inline-":"")+"box")+";"+i.replace(u,"-webkit-"+u)+";"+i.replace(u,"-ms-"+u+"box")+";"+i}return i+";";case 938:if(45===i.charCodeAt(5))switch(i.charCodeAt(6)){case 105:return u=i.replace("-items",""),"-webkit-"+i+"-webkit-box-"+u+"-ms-flex-"+u+i;case 115:return"-webkit-"+i+"-ms-flex-item-"+i.replace(A,"")+i;default:return"-webkit-"+i+"-ms-flex-line-pack"+i.replace("align-content","").replace(A,"")+i}break;case 973:case 989:if(45!==i.charCodeAt(3)||122===i.charCodeAt(4))break;case 931:case 953:if(!0===v.test(e))return 115===(u=e.substring(e.indexOf(":")+1)).charCodeAt(0)?r(e.replace("stretch","fill-available"),t,a,n).replace(":fill-available",":stretch"):i.replace(u,"-webkit-"+u)+i.replace(u,"-moz-"+u.replace("fill-",""))+i;break;case 962:if(i="-webkit-"+i+(102===i.charCodeAt(5)?"-ms-"+i:"")+i,211===a+n&&105===i.charCodeAt(13)&&0<i.indexOf("transform",10))return i.substring(0,i.indexOf(";",27)+1).replace(b,"$1-webkit-$2")+i}return i}function s(e,t){var a=e.indexOf(1===t?":":"{"),n=e.substring(0,3!==t?a:10);return a=e.substring(a+1,e.length-1),H(2!==t?n:n.replace(x,"$1"),a,t)}function i(e,t){var a=r(t,t.charCodeAt(0),t.charCodeAt(1),t.charCodeAt(2));return a!==t+";"?a.replace(M," or ($1)").substring(4):"("+t+")"}function d(e,t,a,n,r,s,i,d,u,c){for(var p,l=0,m=t;l<W;++l)switch(p=D[l].call(o,e,m,a,n,r,s,i,d,u,c)){case void 0:case!1:case!0:case null:break;default:m=p}if(m!==t)return m}function u(e){return void 0!==(e=e.prefix)&&(H=null,e?"function"!=typeof e?C=1:(C=2,H=e):C=0),u}function o(e,a){var n=e;if(33>n.charCodeAt(0)&&(n=n.trim()),n=[n],0<W){var r=d(-1,a,n,n,N,S,0,0,0,0);void 0!==r&&"string"==typeof r&&(a=r)}var s=t(z,n,a,0,0);return 0<W&&(void 0!==(r=d(-2,s,n,n,N,S,s.length,0,0,0))&&(s=r)),"",O=0,S=N=1,s}var c=/^\0+/g,p=/[\0\r\f]/g,l=/: */g,m=/zoo|gra/,b=/([,: ])(transform)/g,h=/,\r+?/g,f=/([\t\r\n ])*\f?&/g,k=/@(k\w+)\s*(\S*)\s*/,g=/::(place)/g,w=/:(read-only)/g,I=/[svh]\w+-[tblr]{2}/,y=/\(\s*(.*)\s*\)/g,M=/([\s\S]*?);/g,A=/-self|flex-/g,x=/[^]*?(:[rp][el]a[\w-]+)[^]*/,v=/stretch|:\s*\w+\-(?:conte|avail)/,F=/([^-])(image-set\()/,S=1,N=1,O=0,C=1,z=[],D=[],W=0,H=null,U=0;return o.use=function e(t){switch(t){case void 0:case null:W=D.length=0;break;default:if("function"==typeof t)D[W++]=t;else if("object"==typeof t)for(var a=0,n=t.length;a<n;++a)e(t[a]);else U=0|!!t}return e},o.set=u,void 0!==e&&u(e),o}},572:function(e,t,a){"use strict";t.a={animationIterationCount:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1}},672:function(e,t,a){e.exports=a(598)}}]);
//# sourceMappingURL=bundle~bundle~748942c6.a2dba907.js.map