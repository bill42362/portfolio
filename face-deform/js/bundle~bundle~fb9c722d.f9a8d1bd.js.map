{"version":3,"sources":["webpack:///./node_modules/@tensorflow/tfjs-core/dist/base_side_effects.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/browser_files.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/progress.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/weights_loader.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/http.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/passthrough.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/backends/complex_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/backends/einsum_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/backends/backend_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/flags.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/backends/backend.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/types.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/device_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/globals.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/indexed_db.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/local_storage.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/hash_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/gradients.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/router_registry.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/engine.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/kernel_registry.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/kernel_names.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/io/model_management.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/global_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/environment.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_util.js","webpack:///./node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js"],"names":["opHandler","buffer","cast","clone","print","defer","f","Promise","resolve","setTimeout","then","fileNamePrefix","getBool","Error","startsWith","URL_SCHEME","slice","length","this","modelTopologyFileName","weightDataFileName","modelArtifacts","weightsURL","window","URL","createObjectURL","Blob","weightData","type","modelTopology","ArrayBuffer","weightsManifest","paths","weights","weightSpecs","modelTopologyAndWeightManifest","format","generatedBy","convertedBy","signature","userDefinedMetadata","modelInitializer","modelTopologyAndWeightManifestURL","JSON","stringify","jsonAnchor","document","createElement","download","href","dispatchEvent","MouseEvent","weightDataAnchor","modelArtifactsInfo","files","jsonFile","weightFiles","reject","jsonReader","FileReader","onload","event","modelJSON","parse","target","result","name","pathToFile","checkManifestAndWeightFiles","err","perFileBuffers","forEach","weightsGroup","path","push","weightFileReader","index","indexOf","onerror","error","readAsArrayBuffer","readAsText","manifest","basenames","fileNames","map","file","group","pathBasename","browserFiles","registerSaveRouter","url","Array","isArray","browserDownloads","monitorPromisesProgress","promises","onProgress","startFraction","endFraction","checkPromises","checkFraction","resolvedPromise","all","promise","value","fraction","async","loadWeightsAsArrayBuffer","fetchURLs","loadOptions","fetchFunc","platform","fetch","requests","fetchURL","requestInit","isBinary","bufferPromises","response","arrayBuffer","loadWeights","filePathPrefix","weightNames","weightsLoaderFactory","fetchUrls","fetchWeightsFunction","groupIndicesToFetchMap","groupWeightsToFetch","weightsFound","allManifestWeightNames","manifestGroupConfig","groupIndex","groupOffset","weightsEntry","rawDtype","quantization","dtype","weightsBytes","shape","enqueueWeightsForFetchingFn","manifestEntry","sizeBytes","weightName","weightIndex","every","found","weightsNotFound","filter","_","i","join","groupIndicesToFetch","reduce","accumulator","shouldFetch","filepath","fetchUrl","endsWith","buffers","weightsTensorMap","bufferIndexOffset","numBuffers","groupBytes","byteLength","groupBuffer","groupByteBuffer","Uint8Array","groupBufferOffset","set","byteBuffer","nameToTensorMap","DEFAULT_METHOD","weightPathPrefix","weightUrlConverter","body","init","Object","assign","method","FormData","append","ok","responses","status","modelConfigRequest","modelConfig","json","e","message","results","artifacts","initializer","weightPath","prefix","suffix","lastSlash","lastIndexOf","lastSearchParam","substring","parseUrl","pathPrefix","entry","urlPromises","isHTTPScheme","match","URL_SCHEME_REGEX","httpRouter","isHTTP","urlItem","http","browserHTTPRequest","registerLoadRouter","PassthroughLoader","PassthroughSaver","saveHandler","fromMemory","trainingConfig","arguments","console","warn","withSaveHandler","mergeRealAndImagArrays","real","imag","Float32Array","splitRealAndImagArrays","complex","complexWithEvenIndex","len","Math","ceil","floor","complexWithOddIndex","getComplexWithIndex","assignToTypedArray","data","exponents","n","inverse","x","PI","cos","sin","exponent","k","ARROW","ARROW_REGEX","decodeEinsumEquation","equation","numTensors","numArrows","replace","inputString","outputString","split","inputTerms","numInputs","allDims","dimName","some","inputTerm","idDims","Set","size","j","numDims","summedDims","getEinsumPermutation","nDims","permutationIndices","fill","expandDims","d","checkEinsumDimSizes","tensors","dimSizes","undefined","getEinsumComputePath","steps","nSteps","computedTermIndices","termIndices","findTermsWithDim","termIndex","isIdentityPermutation","perm","dim","fromUint8ToStringArray","vals","val","fromStringArrayToUint8","strings","s","ENV","registerFlag","debugValue","process","versions","node","navigator","userAgent","test","vendor","DataStorage","backend","dataMover","WeakMap","dataIdsCount","dataId","has","moveData","get","delete","KernelBackend","notYetImplemented","force","values","refCount","floatPrecision","kernelName","DTYPE_VALUE_SIZE_MAP","isBrowser","WorkerGlobalScope","deprecationWarn","msg","engine","tidy","nameOrFn","fn","dispose","container","tensor","keep","setBackend","backendName","getBackend","registerBackend","factory","priority","DATABASE_NAME","MODEL_STORE_NAME","INFO_STORE_NAME","getIndexedDBFactory","theWindow","self","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","shimIndexedDB","setUpDatabase","openRequest","db","createObjectStore","keyPath","BrowserIndexedDB","modelPath","databaseAction","open","onupgradeneeded","onsuccess","modelTx","transaction","getRequest","objectStore","close","oncomplete","infoTx","infoStore","putInfoRequest","put","putModelRequest","deleteInfoRequest","indexedDBRouter","BrowserIndexedDBManager","tx","getAllInfoRequest","getAll","out","item","key","getInfoRequest","deleteModelData","deleteModelRequest","PATH_SEPARATOR","PATH_PREFIX","INFO_SUFFIX","MODEL_TOPOLOGY_SUFFIX","WEIGHT_SPECS_SUFFIX","WEIGHT_DATA_SUFFIX","MODEL_METADATA_SUFFIX","getModelKeys","info","topology","modelMetadata","getModelPathFromKey","items","BrowserLocalStorage","localStorage","LS","keys","setItem","removeItem","modelTopologyBytes","weightSpecsBytes","weightDataBytes","getItem","modelTopologyType","metadataString","metadata","weightDataBase64","localStorageRouter","BrowserLocalStorageManager","Long","hexToLong","hex","fromString","k0","k1","k2","shiftMix","xor","shru","offset","numBytes","bytes","fromBytes","from","fetch64","fetch32","rotate64","shift","or","shl","hashLen16","u","v","mul","a","b","weakHashLen32WithSeedsStr","w","y","z","add","c","weakHashLen32WithSeeds","fingerPrint64","seed","fromNumber","hashLen0to16","hashLen17to32","g","h","hashLen33to64","UZERO","end","last64","and","encodeWeights","specs","dataPromises","names","t","spec","utf8bytes","totalNumBytes","p","bytesOfLength","Uint32Array","concatenateTypedArrays","decodeWeights","float16Decode","quantizationSizeFactor","quantizedArray","Uint16Array","scale","min","getFloat16Decoder","Int32Array","round","dtypeFactor","image","realTensor","imageTensor","xs","totalByteLength","normalizedXs","constructor","useNodeBuffer","Buffer","atob","btoa","stringByteLength","str","arrayBufferToBase64String","toString","buf","l","String","fromCharCode","base64StringToArrayBuffer","byteOffset","charCodeAt","concatenateArrayBuffers","temp","basename","trim","getModelArtifactsInfoForJSON","dateSaved","Date","mantisaTable","convertMantissa","m","computeFloat16MantisaTable","exponentTable","computeFloat16ExponentTable","offsetTable","computeFloat16OffsetTable","bufferUint32View","float16Bits","float32Bits","customGrad","IORouterRegistry","saveRouters","loadRouters","instance","saveRouter","getInstance","loadRouter","getHandlers","handlerType","validHandlers","router","handler","loudRouter","getSaveHandlers","getLoadHandlers","isRegisteredKernelInvocation","kernelInvocation","EngineState","registeredVariables","nextTapeNodeId","numStringTensors","numDataBuffers","gradientDepth","kernelDepth","scopeStack","numDataMovesStack","nextScopeId","tensorInfo","profiling","activeProfile","newBytes","newTensors","peakBytes","kernels","variableName","Engine","registry","registryFactory","pendingBackendInitId","state","pendingBackendInit","backendInstance","sortedBackends","getSortedBackends","initializeBackend","success","asyncInit","initializeBackendsAndReturnBest","setupRegisteredKernels","profiler","kernel","setupFunc","disposeFunc","registryFactoryEntry","promiseId","catch","stack","disposeRegisteredKernels","sort","srcBackend","readSync","disposeData","move","shouldCheckForMemLeaks","scopedRun","startScope","endScope","start","res","ex","nextTensorId","nextVariableId","ENGINE","runKernel","inputs","addTapeNode","activeScope","dy","gradInputs","attrs","runKernelFunc","numDataIdsBefore","outInfos","numDataIdsAfter","numDataIds","numOutputDataIds","numMoves","dataIdsLeaked","kernelParams","outputs","saved","isTapeOn","startingBytecount","startingNumTensors","kernelFunc","kernelOrScopeName","checkKernelForMemLeak","outTensors","outInfo","rank","makeTensorFromDataId","tensorsToSave","getTensorsForGradient","saveTensorsForBackwardMode","forwardFunc","saveFunc","outs","backwardsFunc","kernelProfile","profileKernel","logKernelProfile","bytesAdded","totalBytesSnapshot","tensorsAdded","totalTensorsSnapshot","inputShapes","outputShapes","kernelTimeMs","timeMs","extraInfo","gradConfig","inputsToSave","outputsToSave","inputTensorsToSave","saveAllInputs","inputName","outputTensorsToSave","concat","backendVals","write","trackTensor","initialValue","trainable","incRef","track","removeDataId","varName","disposeVariable","disposeTensor","memory","unreliable","reasons","query","startBytes","startNumTensors","max","gradientsFunc","tapeNode","id","gradFunc","gradient","dys","output","makeTensor","activeTape","kept","scopeInfo","tensorsToTrackInParent","tensorsToTrackInParentSet","oldScope","pop","scopeId","allowNoGradients","startTape","endTape","filteredTape","accumulatedGradientMap","ones","grads","inputMap","input","save","gradRes","gradMap","grad","read","timingInfo","time","wallMs","reset","getOrMakeEngine","ns","_tfengine","environment","kernelRegistry","Map","gradRegistry","getKernel","makeKey","getGradient","getKernelsForBackend","it","entries","done","next","config","registerKernel","Abs","Acos","Acosh","Add","AddN","All","Any","ArgMax","ArgMin","Asin","Asinh","Atan","Atanh","Atan2","AvgPool","AvgPool3D","BatchMatMul","BatchToSpaceND","Bincount","Cast","Ceil","ClipByValue","Complex","ComplexAbs","Concat","Conv2D","Conv2DBackpropFilter","Conv2DBackpropInput","Conv3D","Cos","Cosh","Cumsum","CropAndResize","DenseBincount","DepthToSpace","DepthwiseConv2dNative","DepthwiseConv2dNativeBackpropFilter","DepthwiseConv2dNativeBackpropInput","Dilation2D","RealDiv","Einsum","Elu","Erf","Equal","Exp","ExpandDims","Expm1","FFT","Fill","FlipLeftRight","Floor","FloorDiv","FusedBatchNorm","GatherV2","GatherNd","Greater","GreaterEqual","Identity","IFFT","Imag","IsNan","LeakyRelu","Less","LessEqual","LinSpace","Log","Log1p","LogicalAnd","LogicalNot","LogicalOr","LRN","Max","Maximum","MaxPool","MaxPool3D","MaxPoolWithArgmax","Mean","Min","Minimum","MirrorPad","Mod","Multinomial","Multiply","Neg","NotEqual","NonMaxSuppressionV3","NonMaxSuppressionV4","NonMaxSuppressionV5","OnesLike","OneHot","Pack","PadV2","Pow","Prelu","Prod","Range","Real","Reciprocal","Relu","Reshape","ResizeNearestNeighbor","ResizeBilinear","Relu6","Reverse","Round","Rsqrt","ScatterNd","Select","Selu","Slice","Sin","Sinh","Sign","Sigmoid","Softplus","Sqrt","Sum","SpaceToBatchND","SplitV","Softmax","SparseFillEmptyRows","SparseReshape","SparseSegmentMean","SparseSegmentSum","SparseToDense","SquaredDifference","Square","StridedSlice","StringNGrams","StringSplit","StringToHashBucketFast","Sub","Tan","Tanh","Tile","TopK","Transform","Transpose","Unique","Unpack","ZerosLike","Step","FromPixels","RotateWithOffset","_FusedMatMul","FusedConv2D","FusedDepthwiseConv2D","URL_SCHEME_SUFFIX","ModelStoreManagerRegistry","managers","scheme","manager","parseURL","getSchemes","cloneModelInternal","sourceURL","destURL","deleteSource","loadHandlers","loadHandler","saveHandlers","sourceScheme","sourcePath","sameMedium","load","getManager","removeModel","saveResult","listModels","schemes","schemeOut","schemeAndPath","copyModel","moveModel","globalNameSpace","getGlobalNamespace","global","getGlobal","globalMap","_tfGlobals","getGlobalMap","singleton","TENSORFLOWJS_FLAGS_PREFIX","Environment","flags","flagRegistry","urlFlags","getQueryParams","populateURLFlags","platformName","flagName","evaluationFn","setHook","flagValue","evaluateFlag","location","search","urlParams","keyValue","toLowerCase","parseValue","queryString","params","decodeURIComponent","decodeParam","env","setEnvironmentGlobal","binaryInsert","arr","element","comparator","left","right","middle","compareResult","binarySearch_","defaultComparator","binarySearch","insertionPoint","splice","nonMaxSuppressionV3Impl","boxes","scores","maxOutputSize","iouThreshold","scoreThreshold","nonMaxSuppressionImpl_","nonMaxSuppressionV4Impl","padToMaxOutputSize","nonMaxSuppressionV5Impl","softNmsSigma","returnScoresTensor","returnValidOutputs","candidates","score","boxIndex","suppressBeginIndex","ascendingComparator","selectedIndices","selectedScores","candidate","originalScore","ignoreCandidate","iou","intersectionOverUnion","suppressWeight","validOutputs","elemsToPad","iCoord","subarray","jCoord","yminI","xminI","ymaxI","xmaxI","yminJ","xminJ","ymaxJ","xmaxJ","areaI","areaJ","intersectionYmin","intersectionXmin","intersectionYmax","intersectionXmax","intersectionArea","weight","exp","c1","c2"],"mappings":"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","file":"js/bundle~bundle~fb9c722d.f9a8d1bd.js","sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Required side effectful code for tfjs-core\n// Set up Engine and ENV\nimport { getOrMakeEngine } from './engine';\ngetOrMakeEngine();\n// Register backend-agnostic flags.\nimport './flags';\n// Register platforms\nimport './platforms/platform_browser';\nimport './platforms/platform_node';\n// Set up OpHandler\nimport { buffer } from './ops/buffer';\nimport { cast } from './ops/cast';\nimport { clone } from './ops/clone';\nimport { print } from './ops/print';\nimport { setOpHandler } from './tensor';\nconst opHandler = {\n    buffer,\n    cast,\n    clone,\n    print\n};\nsetOpHandler(opHandler);\n//# sourceMappingURL=base_side_effects.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * IOHandlers related to files, such as browser-triggered file downloads,\n * user-selected files in browser.\n */\nimport '../flags';\nimport { env } from '../environment';\nimport { basename, concatenateArrayBuffers, getModelArtifactsInfoForJSON } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nconst DEFAULT_FILE_NAME_PREFIX = 'model';\nconst DEFAULT_JSON_EXTENSION_NAME = '.json';\nconst DEFAULT_WEIGHT_DATA_EXTENSION_NAME = '.weights.bin';\nfunction defer(f) {\n    return new Promise(resolve => setTimeout(resolve)).then(f);\n}\nexport class BrowserDownloads {\n    constructor(fileNamePrefix) {\n        if (!env().getBool('IS_BROWSER')) {\n            // TODO(cais): Provide info on what IOHandlers are available under the\n            //   current environment.\n            throw new Error('browserDownloads() cannot proceed because the current environment ' +\n                'is not a browser.');\n        }\n        if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {\n            fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);\n        }\n        if (fileNamePrefix == null || fileNamePrefix.length === 0) {\n            fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;\n        }\n        this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;\n        this.weightDataFileName =\n            fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;\n    }\n    async save(modelArtifacts) {\n        if (typeof (document) === 'undefined') {\n            throw new Error('Browser downloads are not supported in ' +\n                'this environment since `document` is not present');\n        }\n        const weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: 'application/octet-stream' }));\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('BrowserDownloads.save() does not support saving model topology ' +\n                'in binary formats yet.');\n        }\n        else {\n            const weightsManifest = [{\n                    paths: ['./' + this.weightDataFileName],\n                    weights: modelArtifacts.weightSpecs\n                }];\n            const modelTopologyAndWeightManifest = {\n                modelTopology: modelArtifacts.modelTopology,\n                format: modelArtifacts.format,\n                generatedBy: modelArtifacts.generatedBy,\n                convertedBy: modelArtifacts.convertedBy,\n                weightsManifest\n            };\n            if (modelArtifacts.signature != null) {\n                modelTopologyAndWeightManifest.signature = modelArtifacts.signature;\n            }\n            if (modelArtifacts.userDefinedMetadata != null) {\n                modelTopologyAndWeightManifest.userDefinedMetadata =\n                    modelArtifacts.userDefinedMetadata;\n            }\n            if (modelArtifacts.modelInitializer != null) {\n                modelTopologyAndWeightManifest.modelInitializer =\n                    modelArtifacts.modelInitializer;\n            }\n            const modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: 'application/json' }));\n            // If anchor elements are not provided, create them without attaching them\n            // to parents, so that the downloaded file names can be controlled.\n            const jsonAnchor = this.jsonAnchor == null ? document.createElement('a') :\n                this.jsonAnchor;\n            jsonAnchor.download = this.modelTopologyFileName;\n            jsonAnchor.href = modelTopologyAndWeightManifestURL;\n            // Trigger downloads by evoking a click event on the download anchors.\n            // When multiple downloads are started synchronously, Firefox will only\n            // save the last one.\n            await defer(() => jsonAnchor.dispatchEvent(new MouseEvent('click')));\n            if (modelArtifacts.weightData != null) {\n                const weightDataAnchor = this.weightDataAnchor == null ?\n                    document.createElement('a') :\n                    this.weightDataAnchor;\n                weightDataAnchor.download = this.weightDataFileName;\n                weightDataAnchor.href = weightsURL;\n                await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent('click')));\n            }\n            return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };\n        }\n    }\n}\nBrowserDownloads.URL_SCHEME = 'downloads://';\nclass BrowserFiles {\n    constructor(files) {\n        if (files == null || files.length < 1) {\n            throw new Error(`When calling browserFiles, at least 1 file is required, ` +\n                `but received ${files}`);\n        }\n        this.files = files;\n    }\n    async load() {\n        const jsonFile = this.files[0];\n        const weightFiles = this.files.slice(1);\n        return new Promise((resolve, reject) => {\n            const jsonReader = new FileReader();\n            jsonReader.onload = (event) => {\n                // tslint:disable-next-line:no-any\n                const modelJSON = JSON.parse(event.target.result);\n                const modelTopology = modelJSON.modelTopology;\n                if (modelTopology == null) {\n                    reject(new Error(`modelTopology field is missing from file ${jsonFile.name}`));\n                    return;\n                }\n                if (weightFiles.length === 0) {\n                    resolve({ modelTopology });\n                }\n                const weightsManifest = modelJSON.weightsManifest;\n                if (weightsManifest == null) {\n                    reject(new Error(`weightManifest field is missing from file ${jsonFile.name}`));\n                    return;\n                }\n                let pathToFile;\n                try {\n                    pathToFile =\n                        this.checkManifestAndWeightFiles(weightsManifest, weightFiles);\n                }\n                catch (err) {\n                    reject(err);\n                    return;\n                }\n                const weightSpecs = [];\n                const paths = [];\n                const perFileBuffers = [];\n                weightsManifest.forEach(weightsGroup => {\n                    weightsGroup.paths.forEach(path => {\n                        paths.push(path);\n                        perFileBuffers.push(null);\n                    });\n                    weightSpecs.push(...weightsGroup.weights);\n                });\n                weightsManifest.forEach(weightsGroup => {\n                    weightsGroup.paths.forEach(path => {\n                        const weightFileReader = new FileReader();\n                        weightFileReader.onload = (event) => {\n                            // tslint:disable-next-line:no-any\n                            const weightData = event.target.result;\n                            const index = paths.indexOf(path);\n                            perFileBuffers[index] = weightData;\n                            if (perFileBuffers.indexOf(null) === -1) {\n                                const result = {\n                                    modelTopology,\n                                    weightSpecs,\n                                    weightData: concatenateArrayBuffers(perFileBuffers),\n                                    format: modelJSON.format,\n                                    generatedBy: modelJSON.generatedBy,\n                                    convertedBy: modelJSON.convertedBy\n                                };\n                                if (modelJSON.signature != null) {\n                                    result.signature = modelJSON.signature;\n                                }\n                                if (modelJSON.userDefinedMetadata != null) {\n                                    result.userDefinedMetadata = modelJSON.userDefinedMetadata;\n                                }\n                                if (modelJSON.modelInitializer != null) {\n                                    result.modelInitializer = modelJSON.modelInitializer;\n                                }\n                                resolve(result);\n                            }\n                        };\n                        weightFileReader.onerror = error => reject(`Failed to weights data from file of path '${path}'.`);\n                        weightFileReader.readAsArrayBuffer(pathToFile[path]);\n                    });\n                });\n            };\n            jsonReader.onerror = error => reject(`Failed to read model topology and weights manifest JSON ` +\n                `from file '${jsonFile.name}'. BrowserFiles supports loading ` +\n                `Keras-style tf.Model artifacts only.`);\n            jsonReader.readAsText(jsonFile);\n        });\n    }\n    /**\n     * Check the compatibility between weights manifest and weight files.\n     */\n    checkManifestAndWeightFiles(manifest, files) {\n        const basenames = [];\n        const fileNames = files.map(file => basename(file.name));\n        const pathToFile = {};\n        for (const group of manifest) {\n            group.paths.forEach(path => {\n                const pathBasename = basename(path);\n                if (basenames.indexOf(pathBasename) !== -1) {\n                    throw new Error(`Duplicate file basename found in weights manifest: ` +\n                        `'${pathBasename}'`);\n                }\n                basenames.push(pathBasename);\n                if (fileNames.indexOf(pathBasename) === -1) {\n                    throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);\n                }\n                else {\n                    pathToFile[path] = files[fileNames.indexOf(pathBasename)];\n                }\n            });\n        }\n        if (basenames.length !== files.length) {\n            throw new Error(`Mismatch in the number of files in weights manifest ` +\n                `(${basenames.length}) and the number of weight files provided ` +\n                `(${files.length}).`);\n        }\n        return pathToFile;\n    }\n}\nexport const browserDownloadsRouter = (url) => {\n    if (!env().getBool('IS_BROWSER')) {\n        return null;\n    }\n    else {\n        if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {\n            return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));\n        }\n        else {\n            return null;\n        }\n    }\n};\nIORouterRegistry.registerSaveRouter(browserDownloadsRouter);\n/**\n * Creates an IOHandler that triggers file downloads from the browser.\n *\n * The returned `IOHandler` instance can be used as model exporting methods such\n * as `tf.Model.save` and supports only saving.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * const saveResult = await model.save('downloads://mymodel');\n * // This will trigger downloading of two files:\n * //   'mymodel.json' and 'mymodel.weights.bin'.\n * console.log(saveResult);\n * ```\n *\n * @param fileNamePrefix Prefix name of the files to be downloaded. For use with\n *   `tf.Model`, `fileNamePrefix` should follow either of the following two\n *   formats:\n *   1. `null` or `undefined`, in which case the default file\n *      names will be used:\n *      - 'model.json' for the JSON file containing the model topology and\n *        weights manifest.\n *      - 'model.weights.bin' for the binary file containing the binary weight\n *        values.\n *   2. A single string or an Array of a single string, as the file name prefix.\n *      For example, if `'foo'` is provided, the downloaded JSON\n *      file and binary weights file will be named 'foo.json' and\n *      'foo.weights.bin', respectively.\n * @param config Additional configuration for triggering downloads.\n * @returns An instance of `BrowserDownloads` `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function browserDownloads(fileNamePrefix = 'model') {\n    return new BrowserDownloads(fileNamePrefix);\n}\n/**\n * Creates an IOHandler that loads model artifacts from user-selected files.\n *\n * This method can be used for loading from files such as user-selected files\n * in the browser.\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * // Note: This code snippet won't run properly without the actual file input\n * //   elements in the HTML DOM.\n *\n * // Suppose there are two HTML file input (`<input type=\"file\" ...>`)\n * // elements.\n * const uploadJSONInput = document.getElementById('upload-json');\n * const uploadWeightsInput = document.getElementById('upload-weights');\n * const model = await tf.loadLayersModel(tf.io.browserFiles(\n *     [uploadJSONInput.files[0], uploadWeightsInput.files[0]]));\n * ```\n *\n * @param files `File`s to load from. Currently, this function supports only\n *   loading from files that contain Keras-style models (i.e., `tf.Model`s), for\n *   which an `Array` of `File`s is expected (in that order):\n *   - A JSON file containing the model topology and weight manifest.\n *   - Optionally, One or more binary files containing the binary weights.\n *     These files must have names that match the paths in the `weightsManifest`\n *     contained by the aforementioned JSON file, or errors will be thrown\n *     during loading. These weights files have the same format as the ones\n *     generated by `tensorflowjs_converter` that comes with the `tensorflowjs`\n *     Python PIP package. If no weights files are provided, only the model\n *     topology will be loaded from the JSON file above.\n * @returns An instance of `Files` `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function browserFiles(files) {\n    return new BrowserFiles(files);\n}\n//# sourceMappingURL=browser_files.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../util';\n/**\n * Monitor Promise.all progress, fire onProgress callback function.\n *\n * @param promises Promise list going to be monitored\n * @param onProgress Callback function. Fired when a promise resolved.\n * @param startFraction Optional fraction start. Default to 0.\n * @param endFraction Optional fraction end. Default to 1.\n */\nexport function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {\n    checkPromises(promises);\n    startFraction = startFraction == null ? 0 : startFraction;\n    endFraction = endFraction == null ? 1 : endFraction;\n    checkFraction(startFraction, endFraction);\n    let resolvedPromise = 0;\n    const registerMonitor = (promise) => {\n        promise.then(value => {\n            const fraction = startFraction +\n                ++resolvedPromise / promises.length * (endFraction - startFraction);\n            // pass fraction as parameter to callback function.\n            onProgress(fraction);\n            return value;\n        });\n        return promise;\n    };\n    function checkPromises(promises) {\n        assert(promises != null && Array.isArray(promises) && promises.length > 0, () => 'promises must be a none empty array');\n    }\n    function checkFraction(startFraction, endFraction) {\n        assert(startFraction >= 0 && startFraction <= 1, () => `Progress fraction must be in range [0, 1], but ` +\n            `got startFraction ${startFraction}`);\n        assert(endFraction >= 0 && endFraction <= 1, () => `Progress fraction must be in range [0, 1], but ` +\n            `got endFraction ${endFraction}`);\n        assert(endFraction >= startFraction, () => `startFraction must be no more than endFraction, but ` +\n            `got startFraction ${startFraction} and endFraction ` +\n            `${endFraction}`);\n    }\n    return Promise.all(promises.map(registerMonitor));\n}\n//# sourceMappingURL=progress.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '../environment';\nimport * as util from '../util';\nimport { decodeWeights } from './io_utils';\nimport { monitorPromisesProgress } from './progress';\nimport { DTYPE_VALUE_SIZE_MAP } from './types';\n/**\n * Reads binary weights data from a number of URLs.\n *\n * @param fetchURLs URLs to send the HTTP requests at, using `fetch` calls.\n * @param requestOptions RequestInit (options) for the HTTP requests.\n * @param fetchFunc Optional overriding value for the `window.fetch` function.\n * @param onProgress Optional, progress callback function, fired periodically\n *   before the load is completed.\n * @returns A `Promise` of an Array of `ArrayBuffer`. The Array has the same\n *   length as `fetchURLs`.\n */\nexport async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {\n    if (loadOptions == null) {\n        loadOptions = {};\n    }\n    const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch :\n        loadOptions.fetchFunc;\n    // Create the requests for all of the weights in parallel.\n    const requests = fetchURLs.map(fetchURL => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));\n    const fetchStartFraction = 0;\n    const fetchEndFraction = 0.5;\n    const responses = loadOptions.onProgress == null ?\n        await Promise.all(requests) :\n        await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);\n    const bufferPromises = responses.map(response => response.arrayBuffer());\n    const bufferStartFraction = 0.5;\n    const bufferEndFraction = 1;\n    const buffers = loadOptions.onProgress == null ?\n        await Promise.all(bufferPromises) :\n        await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);\n    return buffers;\n}\n/**\n * Reads a weights manifest JSON configuration, fetches the weights and\n * returns them as `Tensor`s.\n *\n * @param manifest The weights manifest JSON.\n * @param filePathPrefix The path prefix for filenames given in the manifest.\n *     Defaults to the empty string.\n * @param weightNames The names of the weights to be fetched.\n */\nexport async function loadWeights(manifest, filePathPrefix = '', weightNames, requestInit) {\n    // TODO(nsthorat): Groups are currently fetched atomically. If you need a\n    // single weight from a group, the whole group will be fetched. At a future\n    // date, we should support fetching only the individual shards within a\n    // group that are needed to reconstruct the requested weight.\n    // TODO(cais): Use `decodeWeights` for implementation.\n    const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, { requestInit });\n    const loadWeights = weightsLoaderFactory(fetchWeights);\n    return loadWeights(manifest, filePathPrefix, weightNames);\n}\n/**\n * Creates a function, which reads a weights manifest JSON configuration,\n * fetches the weight files using the specified function and returns them as\n * `Tensor`s.\n *\n * ```js\n * // example for creating a nodejs weight loader, which reads the weight files\n * // from disk using fs.readFileSync\n *\n * import * as fs from 'fs'\n *\n * const fetchWeightsFromDisk = (filePaths: string[]) =>\n *   filePaths.map(filePath => fs.readFileSync(filePath).buffer)\n *\n * const loadWeights = tf.io.weightsLoaderFactory(fetchWeightsFromDisk)\n *\n * const manifest = JSON.parse(\n *   fs.readFileSync('./my_model-weights_manifest').toString()\n * )\n * const weightMap = await loadWeights(manifest, './')\n * ```\n * @param fetchWeightsFunction The function used for fetching the weight files.\n * @returns Weight loading function.\n */\nexport function weightsLoaderFactory(fetchWeightsFunction) {\n    return async (manifest, filePathPrefix = '', weightNames) => {\n        // Collect all the groups, weights, and their relative offsets to be\n        // fetched.\n        const groupIndicesToFetchMap = manifest.map(() => false);\n        const groupWeightsToFetch = {};\n        const weightsFound = weightNames != null ? weightNames.map(() => false) : [];\n        const allManifestWeightNames = [];\n        manifest.forEach((manifestGroupConfig, groupIndex) => {\n            let groupOffset = 0;\n            manifestGroupConfig.weights.forEach(weightsEntry => {\n                const rawDtype = ('quantization' in weightsEntry) ?\n                    weightsEntry.quantization.dtype :\n                    weightsEntry.dtype;\n                const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] *\n                    util.sizeFromShape(weightsEntry.shape);\n                const enqueueWeightsForFetchingFn = () => {\n                    groupIndicesToFetchMap[groupIndex] = true;\n                    if (groupWeightsToFetch[groupIndex] == null) {\n                        groupWeightsToFetch[groupIndex] = [];\n                    }\n                    groupWeightsToFetch[groupIndex].push({\n                        manifestEntry: weightsEntry,\n                        groupOffset,\n                        sizeBytes: weightsBytes\n                    });\n                };\n                if (weightNames != null) {\n                    weightNames.forEach((weightName, weightIndex) => {\n                        if (weightName === weightsEntry.name) {\n                            enqueueWeightsForFetchingFn();\n                            weightsFound[weightIndex] = true;\n                        }\n                    });\n                }\n                else {\n                    enqueueWeightsForFetchingFn();\n                }\n                allManifestWeightNames.push(weightsEntry.name);\n                groupOffset += weightsBytes;\n            });\n        });\n        if (!weightsFound.every(found => found)) {\n            const weightsNotFound = weightNames.filter((_, i) => !weightsFound[i]);\n            throw new Error(`Could not find weights in manifest with names: ` +\n                `${weightsNotFound.join(', ')}. \\n` +\n                `Manifest JSON has weights with names: ` +\n                `${allManifestWeightNames.join(', ')}.`);\n        }\n        // Convert the one-hot boolean groupId => shouldFetch map to a list of group\n        // IDs.\n        const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {\n            if (shouldFetch) {\n                accumulator.push(i);\n            }\n            return accumulator;\n        }, []);\n        const fetchUrls = [];\n        groupIndicesToFetch.forEach(i => {\n            manifest[i].paths.forEach(filepath => {\n                const fetchUrl = filePathPrefix +\n                    (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;\n                fetchUrls.push(fetchUrl);\n            });\n        });\n        const buffers = await fetchWeightsFunction(fetchUrls);\n        const weightsTensorMap = {};\n        let bufferIndexOffset = 0;\n        groupIndicesToFetch.forEach(i => {\n            const numBuffers = manifest[i].paths.length;\n            let groupBytes = 0;\n            for (let i = 0; i < numBuffers; i++) {\n                groupBytes += buffers[bufferIndexOffset + i].byteLength;\n            }\n            // Create a buffer for the whole group.\n            const groupBuffer = new ArrayBuffer(groupBytes);\n            const groupByteBuffer = new Uint8Array(groupBuffer);\n            let groupBufferOffset = 0;\n            for (let i = 0; i < numBuffers; i++) {\n                const buffer = new Uint8Array(buffers[bufferIndexOffset + i]);\n                groupByteBuffer.set(buffer, groupBufferOffset);\n                groupBufferOffset += buffer.byteLength;\n            }\n            const weightsEntries = groupWeightsToFetch[i];\n            weightsEntries.forEach(weightsEntry => {\n                const byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);\n                const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);\n                for (const name in nameToTensorMap) {\n                    weightsTensorMap[name] = nameToTensorMap[name];\n                }\n            });\n            bufferIndexOffset += numBuffers;\n        });\n        return weightsTensorMap;\n    };\n}\n//# sourceMappingURL=weights_loader.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * IOHandler implementations based on HTTP requests in the web browser.\n *\n * Uses [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n */\nimport { env } from '../environment';\nimport { assert } from '../util';\nimport { concatenateArrayBuffers, getModelArtifactsInfoForJSON } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nimport { loadWeightsAsArrayBuffer } from './weights_loader';\nconst OCTET_STREAM_MIME_TYPE = 'application/octet-stream';\nconst JSON_TYPE = 'application/json';\nexport class HTTPRequest {\n    constructor(path, loadOptions) {\n        this.DEFAULT_METHOD = 'POST';\n        if (loadOptions == null) {\n            loadOptions = {};\n        }\n        this.weightPathPrefix = loadOptions.weightPathPrefix;\n        this.onProgress = loadOptions.onProgress;\n        this.weightUrlConverter = loadOptions.weightUrlConverter;\n        if (loadOptions.fetchFunc != null) {\n            assert(typeof loadOptions.fetchFunc === 'function', () => 'Must pass a function that matches the signature of ' +\n                '`fetch` (see ' +\n                'https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)');\n            this.fetch = loadOptions.fetchFunc;\n        }\n        else {\n            this.fetch = env().platform.fetch;\n        }\n        assert(path != null && path.length > 0, () => 'URL path for http must not be null, undefined or ' +\n            'empty.');\n        if (Array.isArray(path)) {\n            assert(path.length === 2, () => 'URL paths for http must have a length of 2, ' +\n                `(actual length is ${path.length}).`);\n        }\n        this.path = path;\n        if (loadOptions.requestInit != null &&\n            loadOptions.requestInit.body != null) {\n            throw new Error('requestInit is expected to have no pre-existing body, but has one.');\n        }\n        this.requestInit = loadOptions.requestInit || {};\n    }\n    async save(modelArtifacts) {\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('BrowserHTTPRequest.save() does not support saving model topology ' +\n                'in binary formats yet.');\n        }\n        const init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);\n        init.body = new FormData();\n        const weightsManifest = [{\n                paths: ['./model.weights.bin'],\n                weights: modelArtifacts.weightSpecs,\n            }];\n        const modelTopologyAndWeightManifest = {\n            modelTopology: modelArtifacts.modelTopology,\n            format: modelArtifacts.format,\n            generatedBy: modelArtifacts.generatedBy,\n            convertedBy: modelArtifacts.convertedBy,\n            weightsManifest\n        };\n        if (modelArtifacts.signature != null) {\n            modelTopologyAndWeightManifest.signature = modelArtifacts.signature;\n        }\n        if (modelArtifacts.userDefinedMetadata != null) {\n            modelTopologyAndWeightManifest.userDefinedMetadata =\n                modelArtifacts.userDefinedMetadata;\n        }\n        if (modelArtifacts.modelInitializer != null) {\n            modelTopologyAndWeightManifest.modelInitializer =\n                modelArtifacts.modelInitializer;\n        }\n        init.body.append('model.json', new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), 'model.json');\n        if (modelArtifacts.weightData != null) {\n            init.body.append('model.weights.bin', new Blob([modelArtifacts.weightData], { type: OCTET_STREAM_MIME_TYPE }), 'model.weights.bin');\n        }\n        const response = await this.fetch(this.path, init);\n        if (response.ok) {\n            return {\n                modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),\n                responses: [response],\n            };\n        }\n        else {\n            throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ` +\n                `${response.status}.`);\n        }\n    }\n    /**\n     * Load model artifacts via HTTP request(s).\n     *\n     * See the documentation to `tf.io.http` for details on the saved\n     * artifacts.\n     *\n     * @returns The loaded model artifacts (if loading succeeds).\n     */\n    async load() {\n        const modelConfigRequest = await this.fetch(this.path, this.requestInit);\n        if (!modelConfigRequest.ok) {\n            throw new Error(`Request to ${this.path} failed with status code ` +\n                `${modelConfigRequest.status}. Please verify this URL points to ` +\n                `the model JSON of the model to load.`);\n        }\n        let modelConfig;\n        try {\n            modelConfig = await modelConfigRequest.json();\n        }\n        catch (e) {\n            let message = `Failed to parse model JSON of response from ${this.path}.`;\n            // TODO(nsthorat): Remove this after some time when we're comfortable that\n            // .pb files are mostly gone.\n            if (this.path.endsWith('.pb')) {\n                message += ' Your path contains a .pb file extension. ' +\n                    'Support for .pb models have been removed in TensorFlow.js 1.0 ' +\n                    'in favor of .json models. You can re-convert your Python ' +\n                    'TensorFlow model using the TensorFlow.js 1.0 conversion scripts ' +\n                    'or you can convert your.pb models with the \\'pb2json\\'' +\n                    'NPM script in the tensorflow/tfjs-converter repository.';\n            }\n            else {\n                message += ' Please make sure the server is serving valid ' +\n                    'JSON for this request.';\n            }\n            throw new Error(message);\n        }\n        const modelTopology = modelConfig.modelTopology;\n        const weightsManifest = modelConfig.weightsManifest;\n        const generatedBy = modelConfig.generatedBy;\n        const convertedBy = modelConfig.convertedBy;\n        const format = modelConfig.format;\n        const signature = modelConfig.signature;\n        const userDefinedMetadata = modelConfig.userDefinedMetadata;\n        // We do not allow both modelTopology and weightsManifest to be missing.\n        if (modelTopology == null && weightsManifest == null) {\n            throw new Error(`The JSON from HTTP path ${this.path} contains neither model ` +\n                `topology or manifest for weights.`);\n        }\n        let weightSpecs;\n        let weightData;\n        if (weightsManifest != null) {\n            const results = await this.loadWeights(weightsManifest);\n            [weightSpecs, weightData] = results;\n        }\n        const artifacts = {\n            modelTopology,\n            weightSpecs,\n            weightData,\n            generatedBy,\n            convertedBy,\n            format\n        };\n        if (signature != null) {\n            artifacts.signature = signature;\n        }\n        if (userDefinedMetadata != null) {\n            artifacts.userDefinedMetadata = userDefinedMetadata;\n        }\n        const initializer = modelConfig.modelInitializer;\n        if (initializer) {\n            artifacts.modelInitializer = initializer;\n        }\n        return artifacts;\n    }\n    async loadWeights(weightsManifest) {\n        const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;\n        const [prefix, suffix] = parseUrl(weightPath);\n        const pathPrefix = this.weightPathPrefix || prefix;\n        const weightSpecs = [];\n        for (const entry of weightsManifest) {\n            weightSpecs.push(...entry.weights);\n        }\n        const fetchURLs = [];\n        const urlPromises = [];\n        for (const weightsGroup of weightsManifest) {\n            for (const path of weightsGroup.paths) {\n                if (this.weightUrlConverter != null) {\n                    urlPromises.push(this.weightUrlConverter(path));\n                }\n                else {\n                    fetchURLs.push(pathPrefix + path + suffix);\n                }\n            }\n        }\n        if (this.weightUrlConverter) {\n            fetchURLs.push(...await Promise.all(urlPromises));\n        }\n        const buffers = await loadWeightsAsArrayBuffer(fetchURLs, {\n            requestInit: this.requestInit,\n            fetchFunc: this.fetch,\n            onProgress: this.onProgress\n        });\n        return [weightSpecs, concatenateArrayBuffers(buffers)];\n    }\n}\nHTTPRequest.URL_SCHEME_REGEX = /^https?:\\/\\//;\n/**\n * Extract the prefix and suffix of the url, where the prefix is the path before\n * the last file, and suffix is the search params after the last file.\n * ```\n * const url = 'http://tfhub.dev/model/1/tensorflowjs_model.pb?tfjs-format=file'\n * [prefix, suffix] = parseUrl(url)\n * // prefix = 'http://tfhub.dev/model/1/'\n * // suffix = '?tfjs-format=file'\n * ```\n * @param url the model url to be parsed.\n */\nexport function parseUrl(url) {\n    const lastSlash = url.lastIndexOf('/');\n    const lastSearchParam = url.lastIndexOf('?');\n    const prefix = url.substring(0, lastSlash);\n    const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : '';\n    return [prefix + '/', suffix];\n}\nexport function isHTTPScheme(url) {\n    return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;\n}\nexport const httpRouter = (url, loadOptions) => {\n    if (typeof fetch === 'undefined' &&\n        (loadOptions == null || loadOptions.fetchFunc == null)) {\n        // `http` uses `fetch` or `node-fetch`, if one wants to use it in\n        // an environment that is not the browser or node they have to setup a\n        // global fetch polyfill.\n        return null;\n    }\n    else {\n        let isHTTP = true;\n        if (Array.isArray(url)) {\n            isHTTP = url.every(urlItem => isHTTPScheme(urlItem));\n        }\n        else {\n            isHTTP = isHTTPScheme(url);\n        }\n        if (isHTTP) {\n            return http(url, loadOptions);\n        }\n    }\n    return null;\n};\nIORouterRegistry.registerSaveRouter(httpRouter);\nIORouterRegistry.registerLoadRouter(httpRouter);\n/**\n * Creates an IOHandler subtype that sends model artifacts to HTTP server.\n *\n * An HTTP request of the `multipart/form-data` mime type will be sent to the\n * `path` URL. The form data includes artifacts that represent the topology\n * and/or weights of the model. In the case of Keras-style `tf.Model`, two\n * blobs (files) exist in form-data:\n *   - A JSON file consisting of `modelTopology` and `weightsManifest`.\n *   - A binary weights file consisting of the concatenated weight values.\n * These files are in the same format as the one generated by\n * [tfjs_converter](https://js.tensorflow.org/tutorials/import-keras.html).\n *\n * The following code snippet exemplifies the client-side code that uses this\n * function:\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save(tf.io.http(\n *     'http://model-server:5000/upload', {requestInit: {method: 'PUT'}}));\n * console.log(saveResult);\n * ```\n *\n * If the default `POST` method is to be used, without any custom parameters\n * such as headers, you can simply pass an HTTP or HTTPS URL to `model.save`:\n *\n * ```js\n * const saveResult = await model.save('http://model-server:5000/upload');\n * ```\n *\n * The following GitHub Gist\n * https://gist.github.com/dsmilkov/1b6046fd6132d7408d5257b0976f7864\n * implements a server based on [flask](https://github.com/pallets/flask) that\n * can receive the request. Upon receiving the model artifacts via the requst,\n * this particular server reconsistutes instances of [Keras\n * Models](https://keras.io/models/model/) in memory.\n *\n *\n * @param path A URL path to the model.\n *   Can be an absolute HTTP path (e.g.,\n *   'http://localhost:8000/model-upload)') or a relative path (e.g.,\n *   './model-upload').\n * @param requestInit Request configurations to be used when sending\n *    HTTP request to server using `fetch`. It can contain fields such as\n *    `method`, `credentials`, `headers`, `mode`, etc. See\n *    https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n *    for more information. `requestInit` must not have a body, because the\n * body will be set by TensorFlow.js. File blobs representing the model\n * topology (filename: 'model.json') and the weights of the model (filename:\n * 'model.weights.bin') will be appended to the body. If `requestInit` has a\n * `body`, an Error will be thrown.\n * @param loadOptions Optional configuration for the loading. It includes the\n *   following fields:\n *   - weightPathPrefix Optional, this specifies the path prefix for weight\n *     files, by default this is calculated from the path param.\n *   - fetchFunc Optional, custom `fetch` function. E.g., in Node.js,\n *     the `fetch` from node-fetch can be used here.\n *   - onProgress Optional, progress callback function, fired periodically\n *     before the load is completed.\n * @returns An instance of `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function http(path, loadOptions) {\n    return new HTTPRequest(path, loadOptions);\n}\n/**\n * Deprecated. Use `tf.io.http`.\n * @param path\n * @param loadOptions\n */\nexport function browserHTTPRequest(path, loadOptions) {\n    return http(path, loadOptions);\n}\n//# sourceMappingURL=http.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nclass PassthroughLoader {\n    constructor(modelArtifacts) {\n        this.modelArtifacts = modelArtifacts;\n    }\n    async load() {\n        return this.modelArtifacts;\n    }\n}\nclass PassthroughSaver {\n    constructor(saveHandler) {\n        this.saveHandler = saveHandler;\n    }\n    async save(modelArtifacts) {\n        return this.saveHandler(modelArtifacts);\n    }\n}\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandler` that simply loads the provided data.\n */\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n    if (arguments.length === 1) {\n        const isModelArtifacts = modelArtifacts.modelTopology != null ||\n            modelArtifacts.weightSpecs != null;\n        if (isModelArtifacts) {\n            return new PassthroughLoader(modelArtifacts);\n        }\n        else {\n            // Legacy support: with only modelTopology.\n            // TODO(cais): Remove this deprecated API.\n            console.warn('Please call tf.io.fromMemory() with only one argument. ' +\n                'The argument should be of type ModelArtifacts. ' +\n                'The multi-argument signature of tf.io.fromMemory() has been ' +\n                'deprecated and will be removed in a future release.');\n            return new PassthroughLoader({ modelTopology: modelArtifacts });\n        }\n    }\n    else {\n        // Legacy support.\n        // TODO(cais): Remove this deprecated API.\n        console.warn('Please call tf.io.fromMemory() with only one argument. ' +\n            'The argument should be of type ModelArtifacts. ' +\n            'The multi-argument signature of tf.io.fromMemory() has been ' +\n            'deprecated and will be removed in a future release.');\n        return new PassthroughLoader({\n            modelTopology: modelArtifacts,\n            weightSpecs,\n            weightData,\n            trainingConfig\n        });\n    }\n}\n/**\n * Creates an IOHandler that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     `SaveResult`.\n */\nexport function withSaveHandler(saveHandler) {\n    return new PassthroughSaver(saveHandler);\n}\n//# sourceMappingURL=passthrough.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n    if (real.length !== imag.length) {\n        throw new Error(`Cannot merge real and imag arrays of different lengths. real:` +\n            `${real.length}, imag: ${imag.length}.`);\n    }\n    const result = new Float32Array(real.length * 2);\n    for (let i = 0; i < result.length; i += 2) {\n        result[i] = real[i / 2];\n        result[i + 1] = imag[i / 2];\n    }\n    return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex) {\n    const real = new Float32Array(complex.length / 2);\n    const imag = new Float32Array(complex.length / 2);\n    for (let i = 0; i < complex.length; i += 2) {\n        real[i / 2] = complex[i];\n        imag[i / 2] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex) {\n    const len = Math.ceil(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 0; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex) {\n    const len = Math.floor(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 2; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(complex, index) {\n    const real = complex[index * 2];\n    const imag = complex[index * 2 + 1];\n    return { real, imag };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(data, real, imag, index) {\n    data[index * 2] = real;\n    data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(n, inverse) {\n    const real = new Float32Array(n / 2);\n    const imag = new Float32Array(n / 2);\n    for (let i = 0; i < Math.ceil(n / 2); i++) {\n        const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n        real[i] = Math.cos(x);\n        imag[i] = Math.sin(x);\n    }\n    return { real, imag };\n}\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(k, n, inverse) {\n    const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n    const real = Math.cos(x);\n    const imag = Math.sin(x);\n    return { real, imag };\n}\n//# sourceMappingURL=complex_util.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../util_base';\nconst ARROW = '->';\nconst ARROW_REGEX = /->/g;\nconst COMMA = ',';\nconst ELLIPSIS = '...';\n/**\n * Parse an equation for einsum.\n *\n * @param equation The einsum equation (e.g., \"ij,jk->ik\").\n * @param numTensors Number of tensors provided along with `equation`. Used to\n *   check matching number of input tensors.\n * @returns An object consisting of the following fields:\n *   - allDims: all dimension names as strings.\n *   - summedDims: a list of all dimensions being summed over, as indices to\n *     the elements of `allDims`.\n *   - idDims: indices of the dimensions in each input tensor, as indices to\n *     the elements of `allDims.\n */\nexport function decodeEinsumEquation(equation, numTensors) {\n    equation = equation.replace(/\\s/g, ''); // Remove witespace in equation.\n    const numArrows = (equation.length - equation.replace(ARROW_REGEX, '').length) /\n        ARROW.length;\n    if (numArrows < 1) {\n        throw new Error('Equations without an arrow are not supported.');\n    }\n    else if (numArrows > 1) {\n        throw new Error(`Equation must contain exactly one arrow (\"${ARROW}\").`);\n    }\n    const [inputString, outputString] = equation.split(ARROW);\n    assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation (\"${ELLIPSIS}\") is not supported yet.`);\n    const inputTerms = inputString.split(COMMA);\n    const numInputs = inputTerms.length;\n    if (numTensors !== numInputs) {\n        throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);\n    }\n    if (numInputs > 2) {\n        throw new Error('Support for more than 2 input tensors is not implemented yet.');\n    }\n    const allDims = [];\n    for (let i = 0; i < outputString.length; ++i) {\n        const dimName = outputString[i];\n        if (!inputTerms.some(inputTerm => inputTerm.indexOf(dimName) !== -1)) {\n            throw new Error(`Output subscripts contain the label ${dimName} ` +\n                `not present in the input subscripts.`);\n        }\n        if (allDims.indexOf(dimName) === -1) {\n            allDims.push(dimName);\n        }\n    }\n    for (let i = 0; i < inputString.length; ++i) {\n        const dimName = inputString[i];\n        if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {\n            allDims.push(dimName);\n        }\n    }\n    const idDims = new Array(inputTerms.length);\n    for (let i = 0; i < numInputs; ++i) {\n        if (new Set(inputTerms[i].split('')).size !== inputTerms[i].length) {\n            throw new Error(`Found duplicate axes in input component ${inputTerms[i]}. ` +\n                `Support for duplicate axes in input is not implemented yet.`);\n        }\n        idDims[i] = [];\n        for (let j = 0; j < inputTerms[i].length; ++j) {\n            idDims[i].push(allDims.indexOf(inputTerms[i][j]));\n        }\n    }\n    const numDims = allDims.length; // Number of unique dimensions.\n    const numOutDims = outputString.length; // Number of output dimensions.\n    const summedDims = []; // Dimensions being summed over.\n    for (let i = numOutDims; i < numDims; ++i) {\n        summedDims.push(i);\n    }\n    return { allDims, summedDims, idDims };\n}\n/**\n * Get the permutation for a given input tensor.\n *\n * @param nDims Total number of dimension of all tensors involved in the einsum\n *   operation.\n * @param idDims Dimension indices involve in the tensor in question.\n * @returns An object consisting of the following fields:\n *   - permutationIndices: Indices to permute the axes of the tensor with.\n *   - expandDims: Indices to the dimension that need to be expanded from the\n *     tensor after permutation.\n */\nexport function getEinsumPermutation(nDims, idDims) {\n    let permutationIndices = new Array(nDims);\n    permutationIndices.fill(-1);\n    for (let i = 0; i < idDims.length; ++i) {\n        permutationIndices[idDims[i]] = i;\n    }\n    const expandDims = [];\n    for (let i = 0; i < nDims; ++i) {\n        if (permutationIndices[i] === -1) {\n            expandDims.push(i);\n        }\n    }\n    permutationIndices = permutationIndices.filter(d => d !== -1);\n    return { permutationIndices, expandDims };\n}\n/**\n * Checks that the dimension sizes from different input tensors match the\n * equation.\n */\nexport function checkEinsumDimSizes(nDims, idDims, tensors) {\n    const dimSizes = new Array(nDims);\n    for (let i = 0; i < tensors.length; ++i) {\n        const shape = tensors[i].shape;\n        for (let j = 0; j < idDims[i].length; ++j) {\n            if (dimSizes[idDims[i][j]] === undefined) {\n                dimSizes[idDims[i][j]] = shape[j];\n            }\n            else {\n                assert(dimSizes[idDims[i][j]] === shape[j], () => `Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} ` +\n                    `of input shaped ${JSON.stringify(shape)}, ` +\n                    `but got dimension ${shape[j]}`);\n            }\n        }\n    }\n}\n/**\n * Gets path of computation for einsum.\n *\n * @param summedDims indices to the dimensions being summed over.\n * @param idDims A look up table for the dimensions present in each input\n *     tensor. Each consituent array contains indices for the dimensions in the\n *     corresponding input tensor.\n *\n * @return A map with two fields:\n *   - path: The path of computation, with each element indicating the dimension\n *     being summed over after the element-wise multiplication in that step.\n *   - steps: With the same length as `path`. Each element contains the indices\n *     to the input tensors being used for element-wise multiplication in the\n *     corresponding step.\n */\nexport function getEinsumComputePath(summedDims, idDims) {\n    const path = summedDims;\n    const steps = [];\n    let nSteps = 0;\n    if (summedDims.length === 0) {\n        // Einsum that involes no summing: e.g., transpose and outer product.\n        path.push(-1);\n    }\n    nSteps = summedDims.length + 1;\n    for (let i = 0; i < nSteps; ++i) {\n        steps.push([]);\n    }\n    const computedTermIndices = [];\n    for (let i = 0; i < path.length; ++i) {\n        const summedDim = path[i];\n        const termIndices = findTermsWithDim(idDims, summedDim);\n        for (const termIndex of termIndices) {\n            if (computedTermIndices.indexOf(termIndex) === -1) {\n                steps[i].push(termIndex);\n                computedTermIndices.push(termIndex);\n            }\n        }\n    }\n    return { path, steps };\n}\n/** Determines if an axes permutation is the identity permutation. */\nexport function isIdentityPermutation(perm) {\n    return perm.every((dim, index) => dim === index);\n}\nfunction findTermsWithDim(idDims, dim) {\n    const termIndices = [];\n    for (let i = 0; i < idDims.length; ++i) {\n        if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {\n            termIndices.push(i);\n        }\n    }\n    return termIndices;\n}\n//# sourceMappingURL=einsum_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { decodeString, encodeString } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../backends/einsum_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function fromUint8ToStringArray(vals) {\n    try {\n        // Decode the bytes into string.\n        return vals.map(val => decodeString(val));\n    }\n    catch (err) {\n        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n    }\n}\nexport function fromStringArrayToUint8(strings) {\n    return strings.map(s => encodeString(s));\n}\n//# sourceMappingURL=backend_util.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport './engine';\nimport * as device_util from './device_util';\nimport { env } from './environment';\nconst ENV = env();\n/**\n * This file contains environment-related flag registrations.\n */\n/** Whether to enable debug mode. */\nENV.registerFlag('DEBUG', () => false, debugValue => {\n    if (debugValue) {\n        console.warn('Debugging mode is ON. The output of every math call will ' +\n            'be downloaded to CPU and checked for NaNs. ' +\n            'This significantly impacts performance.');\n    }\n});\n/** Whether we are in a browser (as versus, say, node.js) environment. */\nENV.registerFlag('IS_BROWSER', () => device_util.isBrowser());\n/** Whether we are in a browser (as versus, say, node.js) environment. */\nENV.registerFlag('IS_NODE', () => (typeof process !== 'undefined') &&\n    (typeof process.versions !== 'undefined') &&\n    (typeof process.versions.node !== 'undefined'));\n/** Whether this browser is Chrome. */\nENV.registerFlag('IS_CHROME', () => typeof navigator !== 'undefined' && navigator != null &&\n    navigator.userAgent != null && /Chrome/.test(navigator.userAgent) &&\n    /Google Inc/.test(navigator.vendor));\n/**\n * True when the environment is \"production\" where we disable safety checks\n * to gain performance.\n */\nENV.registerFlag('PROD', () => false);\n/**\n * Whether to do sanity checks when inferring a shape from user-provided\n * values, used when creating a new tensor.\n */\nENV.registerFlag('TENSORLIKE_CHECK_SHAPE_CONSISTENCY', () => ENV.getBool('DEBUG'));\n/** Whether deprecation warnings are enabled. */\nENV.registerFlag('DEPRECATION_WARNINGS_ENABLED', () => true);\n/** True if running unit tests. */\nENV.registerFlag('IS_TEST', () => false);\n/** Whether to check computation result for errors. */\nENV.registerFlag('CHECK_COMPUTATION_FOR_ERRORS', () => true);\n/** Whether the backend needs to wrap input to imageBitmap. */\nENV.registerFlag('WRAP_TO_IMAGEBITMAP', () => false);\n//# sourceMappingURL=flags.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n/** Convenient class for storing tensor-related data. */\nexport class DataStorage {\n    constructor(backend, dataMover) {\n        this.backend = backend;\n        this.dataMover = dataMover;\n        this.data = new WeakMap();\n        this.dataIdsCount = 0;\n    }\n    get(dataId) {\n        if (!this.data.has(dataId)) {\n            this.dataMover.moveData(this.backend, dataId);\n        }\n        return this.data.get(dataId);\n    }\n    set(dataId, value) {\n        this.dataIdsCount++;\n        this.data.set(dataId, value);\n    }\n    has(dataId) {\n        return this.data.has(dataId);\n    }\n    delete(dataId) {\n        this.dataIdsCount--;\n        return this.data.delete(dataId);\n    }\n    numDataIds() {\n        return this.dataIdsCount;\n    }\n}\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nexport class KernelBackend {\n    refCount(dataId) {\n        return notYetImplemented('refCount');\n    }\n    incRef(dataId) {\n        return notYetImplemented('incRef');\n    }\n    timerAvailable() {\n        return true;\n    }\n    time(f) {\n        return notYetImplemented('time');\n    }\n    read(dataId) {\n        return notYetImplemented('read');\n    }\n    readSync(dataId) {\n        return notYetImplemented('readSync');\n    }\n    numDataIds() {\n        return notYetImplemented('numDataIds');\n    }\n    disposeData(dataId, force) {\n        return notYetImplemented('disposeData');\n    }\n    write(values, shape, dtype) {\n        return notYetImplemented('write');\n    }\n    move(dataId, values, shape, dtype, refCount) {\n        return notYetImplemented('move');\n    }\n    memory() {\n        return notYetImplemented('memory');\n    }\n    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n    floatPrecision() {\n        return notYetImplemented('floatPrecision');\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n    dispose() {\n        return notYetImplemented('dispose');\n    }\n}\nfunction notYetImplemented(kernelName) {\n    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. ` +\n        `This kernel may not be supported by the tfjs backend you have chosen`);\n}\n//# sourceMappingURL=backend.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/* Type definitions for exporting and importing of models. */\n/**\n * A map from Tensor dtype to number of bytes per element of the Tensor.\n */\nexport const DTYPE_VALUE_SIZE_MAP = {\n    'float32': 4,\n    'float16': 2,\n    'int32': 4,\n    'uint16': 2,\n    'uint8': 1,\n    'bool': 1,\n    'complex64': 8\n};\n//# sourceMappingURL=types.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line:no-any\nfunction _isNavigatorDefined() {\n    return typeof navigator !== 'undefined' && navigator != null;\n}\nexport function isMobile(nav) {\n    if (nav || _isNavigatorDefined()) {\n        if (!nav) {\n            nav = navigator;\n        }\n        if (nav.product === 'ReactNative') {\n            return true;\n        }\n        // tslint:disable-next-line:no-any\n        const a = nav.userAgent || nav.vendor || window.opera;\n        // tslint:disable-next-line:max-line-length\n        return /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i\n            .test(a) ||\n            // tslint:disable-next-line:max-line-length\n            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i\n                .test(a.substr(0, 4));\n    }\n    return false;\n}\nexport function isBrowser() {\n    return (typeof window !== 'undefined' && window.document != null) ||\n        //@ts-ignore\n        (typeof WorkerGlobalScope !== 'undefined');\n}\n//# sourceMappingURL=device_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { setDeprecationWarningFn } from './tensor';\nimport { getTensorsInContainer } from './tensor_util';\n/**\n * Enables production mode which disables correctness checks in favor of\n * performance.\n *\n * @doc {heading: 'Environment'}\n */\nexport function enableProdMode() {\n    env().set('PROD', true);\n}\n/**\n * Enables debug mode which will log information about all executed kernels:\n * the elapsed time of the kernel execution, as well as the rank, shape, and\n * size of the output tensor.\n *\n * Debug mode will significantly slow down your application as it will\n * download the result of every operation to the CPU. This should not be used in\n * production. Debug mode does not affect the timing information of the kernel\n * execution as we do not measure download time in the kernel execution time.\n *\n * See also: `tf.profile`, `tf.memory`.\n *\n * @doc {heading: 'Environment'}\n */\nexport function enableDebugMode() {\n    env().set('DEBUG', true);\n}\n/** Globally disables deprecation warnings */\nexport function disableDeprecationWarnings() {\n    env().set('DEPRECATION_WARNINGS_ENABLED', false);\n    console.warn(`TensorFlow.js deprecation warnings have been disabled.`);\n}\n/** Warn users about deprecated functionality. */\nexport function deprecationWarn(msg) {\n    if (env().getBool('DEPRECATION_WARNINGS_ENABLED')) {\n        console.warn(msg + ' You can disable deprecation warnings with ' +\n            'tf.disableDeprecationWarnings().');\n    }\n}\nsetDeprecationWarningFn(deprecationWarn);\n/**\n * Dispose all variables kept in backend engine.\n *\n * @doc {heading: 'Environment'}\n */\nexport function disposeVariables() {\n    ENGINE.disposeVariables();\n}\n/**\n * It returns the global engine that keeps track of all tensors and backends.\n *\n * @doc {heading: 'Environment'}\n */\nexport function engine() {\n    return ENGINE;\n}\n/**\n * Returns memory info at the current time in the program. The result is an\n * object with the following properties:\n *\n * - `numBytes`: Number of bytes allocated (undisposed) at this time.\n * - `numTensors`: Number of unique tensors allocated.\n * - `numDataBuffers`: Number of unique data buffers allocated\n *   (undisposed) at this time, which is  the number of tensors\n *   (e.g. `a.reshape(newShape)` makes a new Tensor that shares the same\n *   data buffer with `a`).\n * - `unreliable`: True if the memory usage is unreliable. See `reasons` when\n *    `unreliable` is true.\n * - `reasons`: `string[]`, reasons why the memory is unreliable, present if\n *    `unreliable` is true.\n *\n * WebGL Properties:\n * - `numBytesInGPU`: Number of bytes allocated (undisposed) in the GPU only at\n *     this time.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function memory() {\n    return ENGINE.memory();\n}\n/**\n * Executes the provided function `f()` and returns a promise that resolves\n * with information about the function's memory use:\n * - `newBytes`: the number of new bytes allocated\n * - `newTensors`: the number of new tensors created\n * - `peakBytes`: the peak number of bytes allocated\n * - `kernels`: an array of objects for each kernel involved that reports\n * their input and output shapes, number of bytes used, and number of new\n * tensors created.\n * - `kernelNames`: an array of unique strings with just the names of the\n * kernels in the `kernels` array.\n *\n * ```js\n * const profile = await tf.profile(() => {\n *   const x = tf.tensor1d([1, 2, 3]);\n *   let x2 = x.square();\n *   x2.dispose();\n *   x2 = x.square();\n *   x2.dispose();\n *   return x;\n * });\n *\n * console.log(`newBytes: ${profile.newBytes}`);\n * console.log(`newTensors: ${profile.newTensors}`);\n * console.log(`byte usage over all kernels: ${profile.kernels.map(k =>\n * k.totalBytesSnapshot)}`);\n * ```\n *\n *\n * @doc {heading: 'Performance', subheading: 'Profile'}\n */\nexport function profile(f) {\n    return ENGINE.profile(f);\n}\n/**\n * Executes the provided function `fn` and after it is executed, cleans up all\n * intermediate tensors allocated by `fn` except those returned by `fn`.\n * `fn` must not return a Promise (async functions not allowed). The returned\n * result can be a complex object.\n *\n * Using this method helps avoid memory leaks. In general, wrap calls to\n * operations in `tf.tidy` for automatic memory cleanup.\n *\n * NOTE: Variables do *not* get cleaned up when inside a tidy(). If you want to\n * dispose variables, please use `tf.disposeVariables` or call dispose()\n * directly on variables.\n *\n * ```js\n * // y = 2 ^ 2 + 1\n * const y = tf.tidy(() => {\n *   // a, b, and one will be cleaned up when the tidy ends.\n *   const one = tf.scalar(1);\n *   const a = tf.scalar(2);\n *   const b = a.square();\n *\n *   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n *\n *   // The value returned inside the tidy function will return\n *   // through the tidy, in this case to the variable y.\n *   return b.add(one);\n * });\n *\n * console.log('numTensors (outside tidy): ' + tf.memory().numTensors);\n * y.print();\n * ```\n *\n * @param nameOrFn The name of the closure, or the function to execute.\n *     If a name is provided, the 2nd argument should be the function.\n *     If debug mode is on, the timing and the memory usage of the function\n *     will be tracked and displayed on the console using the provided name.\n * @param fn The function to execute.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function tidy(nameOrFn, fn) {\n    return ENGINE.tidy(nameOrFn, fn);\n}\n/**\n * Disposes any `tf.Tensor`s found within the provided object.\n *\n * @param container an object that may be a `tf.Tensor` or may directly\n *     contain `tf.Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. If\n *     the object is not a `tf.Tensor` or does not contain `Tensors`, nothing\n *     happens. In general it is safe to pass any object here, except that\n *     `Promise`s are not supported.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function dispose(container) {\n    const tensors = getTensorsInContainer(container);\n    tensors.forEach(tensor => tensor.dispose());\n}\n/**\n * Keeps a `tf.Tensor` generated inside a `tf.tidy` from being disposed\n * automatically.\n *\n * ```js\n * let b;\n * const y = tf.tidy(() => {\n *   const one = tf.scalar(1);\n *   const a = tf.scalar(2);\n *\n *   // b will not be cleaned up by the tidy. a and one will be cleaned up\n *   // when the tidy ends.\n *   b = tf.keep(a.square());\n *\n *   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n *\n *   // The value returned inside the tidy function will return\n *   // through the tidy, in this case to the variable y.\n *   return b.add(one);\n * });\n *\n * console.log('numTensors (outside tidy): ' + tf.memory().numTensors);\n * console.log('y:');\n * y.print();\n * console.log('b:');\n * b.print();\n * ```\n *\n * @param result The tensor to keep from being disposed.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function keep(result) {\n    return ENGINE.keep(result);\n}\n/**\n * Executes `f()` and returns a promise that resolves with timing\n * information.\n *\n * The result is an object with the following properties:\n *\n * - `wallMs`: Wall execution time.\n * - `kernelMs`: Kernel execution time, ignoring data transfer. If using the\n * WebGL backend and the query timer extension is not available, this will\n * return an error object.\n * - On `WebGL` The following additional properties exist:\n *   - `uploadWaitMs`: CPU blocking time on texture uploads.\n *   - `downloadWaitMs`: CPU blocking time on texture downloads (readPixels).\n *\n * ```js\n * const x = tf.randomNormal([20, 20]);\n * const time = await tf.time(() => x.matMul(x));\n *\n * console.log(`kernelMs: ${time.kernelMs}, wallTimeMs: ${time.wallMs}`);\n * ```\n *\n * @param f The function to execute and time.\n *\n * @doc {heading: 'Performance', subheading: 'Timing'}\n */\nexport function time(f) {\n    return ENGINE.time(f);\n}\n/**\n * Sets the backend (cpu, webgl, wasm, etc) responsible for creating tensors and\n * executing operations on those tensors. Returns a promise that resolves\n * to a boolean if the backend initialization was successful.\n *\n * Note this disposes the current backend, if any, as well as any tensors\n * associated with it. A new backend is initialized, even if it is of the\n * same type as the previous one.\n *\n * @param backendName The name of the backend. Currently supports\n *     `'webgl'|'cpu'` in the browser, `'tensorflow'` under node.js\n *     (requires tfjs-node), and `'wasm'` (requires tfjs-backend-wasm).\n *\n * @doc {heading: 'Backends'}\n */\nexport function setBackend(backendName) {\n    return ENGINE.setBackend(backendName);\n}\n/**\n * Returns a promise that resolves when the currently selected backend (or the\n * highest priority one) has initialized. Await this promise when you are using\n * a backend that has async initialization.\n *\n * @doc {heading: 'Backends'}\n */\nexport function ready() {\n    return ENGINE.ready();\n}\n/**\n * Returns the current backend name (cpu, webgl, etc). The backend is\n * responsible for creating tensors and executing operations on those tensors.\n *\n * @doc {heading: 'Backends'}\n */\nexport function getBackend() {\n    return ENGINE.backendName;\n}\n/**\n * Removes a backend and the registered factory.\n *\n * @doc {heading: 'Backends'}\n */\nexport function removeBackend(name) {\n    ENGINE.removeBackend(name);\n}\n/**\n * Finds the backend registered under the provided name. Returns null if the\n * name is not in the registry, or the registration hasn't finished yet.\n */\nexport function findBackend(name) {\n    return ENGINE.findBackend(name);\n}\n/**\n * Finds the backend factory registered under the provided name. Returns a\n * function that produces a new backend when called. Returns null if the name\n * is not in the registry.\n */\nexport function findBackendFactory(name) {\n    return ENGINE.findBackendFactory(name);\n}\n/**\n * Registers a global backend. The registration should happen when importing\n * a module file (e.g. when importing `backend_webgl.ts`), and is used for\n * modular builds (e.g. custom tfjs bundle with only webgl support).\n *\n * @param factory The backend factory function. When called, it should\n * return a backend instance, or a promise of an instance.\n * @param priority The priority of the backend (higher = more important).\n *     In case multiple backends are registered, the priority is used to find\n *     the best backend. Defaults to 1.\n * @return False if there is already a registered backend under this name, true\n *     if not.\n *\n * @doc {heading: 'Backends'}\n */\nexport function registerBackend(name, factory, priority = 1) {\n    return ENGINE.registerBackend(name, factory, priority);\n}\n/**\n * Gets the current backend. If no backends have been initialized, this will\n * attempt to initialize the best backend. Will throw an error if the highest\n * priority backend has async initialization, in which case, you should call\n * 'await tf.ready()' before running other code.\n *\n * @doc {heading: 'Backends'}\n */\nexport function backend() {\n    return ENGINE.backend;\n}\n/**\n * Sets the global platform.\n *\n * @param platformName The name of this platform.\n * @param platform A platform implementation.\n */\nexport function setPlatform(platformName, platform) {\n    env().setPlatform(platformName, platform);\n}\n//# sourceMappingURL=globals.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport '../flags';\nimport { env } from '../environment';\nimport { getModelArtifactsInfoForJSON } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nconst DATABASE_NAME = 'tensorflowjs';\nconst DATABASE_VERSION = 1;\n// Model data and ModelArtifactsInfo (metadata) are stored in two separate\n// stores for efficient access of the list of stored models and their metadata.\n// 1. The object store for model data: topology, weights and weight manifests.\nconst MODEL_STORE_NAME = 'models_store';\n// 2. The object store for ModelArtifactsInfo, including meta-information such\n//    as the type of topology (JSON vs binary), byte size of the topology, byte\n//    size of the weights, etc.\nconst INFO_STORE_NAME = 'model_info_store';\n/**\n * Delete the entire database for tensorflow.js, including the models store.\n */\nexport async function deleteDatabase() {\n    const idbFactory = getIndexedDBFactory();\n    return new Promise((resolve, reject) => {\n        const deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);\n        deleteRequest.onsuccess = () => resolve();\n        deleteRequest.onerror = error => reject(error);\n    });\n}\nfunction getIndexedDBFactory() {\n    if (!env().getBool('IS_BROWSER')) {\n        // TODO(cais): Add more info about what IOHandler subtypes are available.\n        //   Maybe point to a doc page on the web and/or automatically determine\n        //   the available IOHandlers and print them in the error message.\n        throw new Error('Failed to obtain IndexedDB factory because the current environment' +\n            'is not a web browser.');\n    }\n    // tslint:disable-next-line:no-any\n    const theWindow = typeof window === 'undefined' ? self : window;\n    const factory = theWindow.indexedDB || theWindow.mozIndexedDB ||\n        theWindow.webkitIndexedDB || theWindow.msIndexedDB ||\n        theWindow.shimIndexedDB;\n    if (factory == null) {\n        throw new Error('The current browser does not appear to support IndexedDB.');\n    }\n    return factory;\n}\nfunction setUpDatabase(openRequest) {\n    const db = openRequest.result;\n    db.createObjectStore(MODEL_STORE_NAME, { keyPath: 'modelPath' });\n    db.createObjectStore(INFO_STORE_NAME, { keyPath: 'modelPath' });\n}\n/**\n * IOHandler subclass: Browser IndexedDB.\n *\n * See the doc string of `browserIndexedDB` for more details.\n */\nexport class BrowserIndexedDB {\n    constructor(modelPath) {\n        this.indexedDB = getIndexedDBFactory();\n        if (modelPath == null || !modelPath) {\n            throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');\n        }\n        this.modelPath = modelPath;\n    }\n    async save(modelArtifacts) {\n        // TODO(cais): Support saving GraphDef models.\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +\n                'in binary formats yet.');\n        }\n        return this.databaseAction(this.modelPath, modelArtifacts);\n    }\n    async load() {\n        return this.databaseAction(this.modelPath);\n    }\n    /**\n     * Perform database action to put model artifacts into or read model artifacts\n     * from IndexedDB object store.\n     *\n     * Whether the action is put or get depends on whether `modelArtifacts` is\n     * specified. If it is specified, the action will be put; otherwise the action\n     * will be get.\n     *\n     * @param modelPath A unique string path for the model.\n     * @param modelArtifacts If specified, it will be the model artifacts to be\n     *   stored in IndexedDB.\n     * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`\n     *   of `ModelArtifacts`, if the action is get.\n     */\n    databaseAction(modelPath, modelArtifacts) {\n        return new Promise((resolve, reject) => {\n            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (modelArtifacts == null) {\n                    // Read model out from object store.\n                    const modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');\n                    const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                    const getRequest = modelStore.get(this.modelPath);\n                    getRequest.onsuccess = () => {\n                        if (getRequest.result == null) {\n                            db.close();\n                            return reject(new Error(`Cannot find model with path '${this.modelPath}' ` +\n                                `in IndexedDB.`));\n                        }\n                        else {\n                            resolve(getRequest.result.modelArtifacts);\n                        }\n                    };\n                    getRequest.onerror = error => {\n                        db.close();\n                        return reject(getRequest.error);\n                    };\n                    modelTx.oncomplete = () => db.close();\n                }\n                else {\n                    // Put model into object store.\n                    const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);\n                    // First, put ModelArtifactsInfo into info store.\n                    const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n                    let infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                    const putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });\n                    let modelTx;\n                    putInfoRequest.onsuccess = () => {\n                        // Second, put model data into model store.\n                        modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n                        const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                        const putModelRequest = modelStore.put({\n                            modelPath: this.modelPath,\n                            modelArtifacts,\n                            modelArtifactsInfo\n                        });\n                        putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });\n                        putModelRequest.onerror = error => {\n                            // If the put-model request fails, roll back the info entry as\n                            // well.\n                            infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                            const deleteInfoRequest = infoStore.delete(this.modelPath);\n                            deleteInfoRequest.onsuccess = () => {\n                                db.close();\n                                return reject(putModelRequest.error);\n                            };\n                            deleteInfoRequest.onerror = error => {\n                                db.close();\n                                return reject(putModelRequest.error);\n                            };\n                        };\n                    };\n                    putInfoRequest.onerror = error => {\n                        db.close();\n                        return reject(putInfoRequest.error);\n                    };\n                    infoTx.oncomplete = () => {\n                        if (modelTx == null) {\n                            db.close();\n                        }\n                        else {\n                            modelTx.oncomplete = () => db.close();\n                        }\n                    };\n                }\n            };\n            openRequest.onerror = error => reject(openRequest.error);\n        });\n    }\n}\nBrowserIndexedDB.URL_SCHEME = 'indexeddb://';\nexport const indexedDBRouter = (url) => {\n    if (!env().getBool('IS_BROWSER')) {\n        return null;\n    }\n    else {\n        if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {\n            return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));\n        }\n        else {\n            return null;\n        }\n    }\n};\nIORouterRegistry.registerSaveRouter(indexedDBRouter);\nIORouterRegistry.registerLoadRouter(indexedDBRouter);\n/**\n * Creates a browser IndexedDB IOHandler for saving and loading models.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save('indexeddb://MyModel'));\n * console.log(saveResult);\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `BrowserIndexedDB` (sublcass of `IOHandler`),\n *   which can be used with, e.g., `tf.Model.save`.\n */\nexport function browserIndexedDB(modelPath) {\n    return new BrowserIndexedDB(modelPath);\n}\nfunction maybeStripScheme(key) {\n    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ?\n        key.slice(BrowserIndexedDB.URL_SCHEME.length) :\n        key;\n}\nexport class BrowserIndexedDBManager {\n    constructor() {\n        this.indexedDB = getIndexedDBFactory();\n    }\n    async listModels() {\n        return new Promise((resolve, reject) => {\n            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                const tx = db.transaction(INFO_STORE_NAME, 'readonly');\n                const store = tx.objectStore(INFO_STORE_NAME);\n                // tslint:disable:max-line-length\n                // Need to cast `store` as `any` here because TypeScript's DOM\n                // library does not have the `getAll()` method even though the\n                // method is supported in the latest version of most mainstream\n                // browsers:\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                // tslint:enable:max-line-length\n                // tslint:disable-next-line:no-any\n                const getAllInfoRequest = store.getAll();\n                getAllInfoRequest.onsuccess = () => {\n                    const out = {};\n                    for (const item of getAllInfoRequest.result) {\n                        out[item.modelPath] = item.modelArtifactsInfo;\n                    }\n                    resolve(out);\n                };\n                getAllInfoRequest.onerror = error => {\n                    db.close();\n                    return reject(getAllInfoRequest.error);\n                };\n                tx.oncomplete = () => db.close();\n            };\n            openRequest.onerror = error => reject(openRequest.error);\n        });\n    }\n    async removeModel(path) {\n        path = maybeStripScheme(path);\n        return new Promise((resolve, reject) => {\n            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n                const infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                const getInfoRequest = infoStore.get(path);\n                let modelTx;\n                getInfoRequest.onsuccess = () => {\n                    if (getInfoRequest.result == null) {\n                        db.close();\n                        return reject(new Error(`Cannot find model with path '${path}' ` +\n                            `in IndexedDB.`));\n                    }\n                    else {\n                        // First, delete the entry in the info store.\n                        const deleteInfoRequest = infoStore.delete(path);\n                        const deleteModelData = () => {\n                            // Second, delete the entry in the model store.\n                            modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n                            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                            const deleteModelRequest = modelStore.delete(path);\n                            deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);\n                            deleteModelRequest.onerror = error => reject(getInfoRequest.error);\n                        };\n                        // Proceed with deleting model data regardless of whether deletion\n                        // of info data succeeds or not.\n                        deleteInfoRequest.onsuccess = deleteModelData;\n                        deleteInfoRequest.onerror = error => {\n                            deleteModelData();\n                            db.close();\n                            return reject(getInfoRequest.error);\n                        };\n                    }\n                };\n                getInfoRequest.onerror = error => {\n                    db.close();\n                    return reject(getInfoRequest.error);\n                };\n                infoTx.oncomplete = () => {\n                    if (modelTx == null) {\n                        db.close();\n                    }\n                    else {\n                        modelTx.oncomplete = () => db.close();\n                    }\n                };\n            };\n            openRequest.onerror = error => reject(openRequest.error);\n        });\n    }\n}\n//# sourceMappingURL=indexed_db.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport '../flags';\nimport { env } from '../environment';\nimport { assert } from '../util';\nimport { arrayBufferToBase64String, base64StringToArrayBuffer, getModelArtifactsInfoForJSON } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nconst PATH_SEPARATOR = '/';\nconst PATH_PREFIX = 'tensorflowjs_models';\nconst INFO_SUFFIX = 'info';\nconst MODEL_TOPOLOGY_SUFFIX = 'model_topology';\nconst WEIGHT_SPECS_SUFFIX = 'weight_specs';\nconst WEIGHT_DATA_SUFFIX = 'weight_data';\nconst MODEL_METADATA_SUFFIX = 'model_metadata';\n/**\n * Purge all tensorflow.js-saved model artifacts from local storage.\n *\n * @returns Paths of the models purged.\n */\nexport function purgeLocalStorageArtifacts() {\n    if (!env().getBool('IS_BROWSER') || typeof window === 'undefined' ||\n        typeof window.localStorage === 'undefined') {\n        throw new Error('purgeLocalStorageModels() cannot proceed because local storage is ' +\n            'unavailable in the current environment.');\n    }\n    const LS = window.localStorage;\n    const purgedModelPaths = [];\n    for (let i = 0; i < LS.length; ++i) {\n        const key = LS.key(i);\n        const prefix = PATH_PREFIX + PATH_SEPARATOR;\n        if (key.startsWith(prefix) && key.length > prefix.length) {\n            LS.removeItem(key);\n            const modelName = getModelPathFromKey(key);\n            if (purgedModelPaths.indexOf(modelName) === -1) {\n                purgedModelPaths.push(modelName);\n            }\n        }\n    }\n    return purgedModelPaths;\n}\nfunction getModelKeys(path) {\n    return {\n        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),\n        topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),\n        weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),\n        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),\n        modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)\n    };\n}\n/**\n * Get model path from a local-storage key.\n *\n * E.g., 'tensorflowjs_models/my/model/1/info' --> 'my/model/1'\n *\n * @param key\n */\nfunction getModelPathFromKey(key) {\n    const items = key.split(PATH_SEPARATOR);\n    if (items.length < 3) {\n        throw new Error(`Invalid key format: ${key}`);\n    }\n    return items.slice(1, items.length - 1).join(PATH_SEPARATOR);\n}\nfunction maybeStripScheme(key) {\n    return key.startsWith(BrowserLocalStorage.URL_SCHEME) ?\n        key.slice(BrowserLocalStorage.URL_SCHEME.length) :\n        key;\n}\n/**\n * IOHandler subclass: Browser Local Storage.\n *\n * See the doc string to `browserLocalStorage` for more details.\n */\nexport class BrowserLocalStorage {\n    constructor(modelPath) {\n        if (!env().getBool('IS_BROWSER') || typeof window === 'undefined' ||\n            typeof window.localStorage === 'undefined') {\n            // TODO(cais): Add more info about what IOHandler subtypes are\n            // available.\n            //   Maybe point to a doc page on the web and/or automatically determine\n            //   the available IOHandlers and print them in the error message.\n            throw new Error('The current environment does not support local storage.');\n        }\n        this.LS = window.localStorage;\n        if (modelPath == null || !modelPath) {\n            throw new Error('For local storage, modelPath must not be null, undefined or empty.');\n        }\n        this.modelPath = modelPath;\n        this.keys = getModelKeys(this.modelPath);\n    }\n    /**\n     * Save model artifacts to browser local storage.\n     *\n     * See the documentation to `browserLocalStorage` for details on the saved\n     * artifacts.\n     *\n     * @param modelArtifacts The model artifacts to be stored.\n     * @returns An instance of SaveResult.\n     */\n    async save(modelArtifacts) {\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +\n                'in binary formats yet.');\n        }\n        else {\n            const topology = JSON.stringify(modelArtifacts.modelTopology);\n            const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);\n            const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);\n            try {\n                this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));\n                this.LS.setItem(this.keys.topology, topology);\n                this.LS.setItem(this.keys.weightSpecs, weightSpecs);\n                this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(modelArtifacts.weightData));\n                const result = {\n                    format: modelArtifacts.format,\n                    generatedBy: modelArtifacts.generatedBy,\n                    convertedBy: modelArtifacts.convertedBy\n                };\n                if (modelArtifacts.signature != null) {\n                    result.signature = modelArtifacts.signature;\n                }\n                if (modelArtifacts.userDefinedMetadata != null) {\n                    result.userDefinedMetadata = modelArtifacts.userDefinedMetadata;\n                }\n                if (modelArtifacts.modelInitializer != null) {\n                    result.modelInitializer = modelArtifacts.modelInitializer;\n                }\n                this.LS.setItem(this.keys.modelMetadata, JSON.stringify(result));\n                return { modelArtifactsInfo };\n            }\n            catch (err) {\n                // If saving failed, clean up all items saved so far.\n                this.LS.removeItem(this.keys.info);\n                this.LS.removeItem(this.keys.topology);\n                this.LS.removeItem(this.keys.weightSpecs);\n                this.LS.removeItem(this.keys.weightData);\n                this.LS.removeItem(this.keys.modelMetadata);\n                throw new Error(`Failed to save model '${this.modelPath}' to local storage: ` +\n                    `size quota being exceeded is a possible cause of this failure: ` +\n                    `modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, ` +\n                    `weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, ` +\n                    `weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);\n            }\n        }\n    }\n    /**\n     * Load a model from local storage.\n     *\n     * See the documentation to `browserLocalStorage` for details on the saved\n     * artifacts.\n     *\n     * @returns The loaded model (if loading succeeds).\n     */\n    async load() {\n        const info = JSON.parse(this.LS.getItem(this.keys.info));\n        if (info == null) {\n            throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);\n        }\n        if (info.modelTopologyType !== 'JSON') {\n            throw new Error('BrowserLocalStorage does not support loading non-JSON model ' +\n                'topology yet.');\n        }\n        const out = {};\n        // Load topology.\n        const topology = JSON.parse(this.LS.getItem(this.keys.topology));\n        if (topology == null) {\n            throw new Error(`In local storage, the topology of model '${this.modelPath}' ` +\n                `is missing.`);\n        }\n        out.modelTopology = topology;\n        // Load weight specs.\n        const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));\n        if (weightSpecs == null) {\n            throw new Error(`In local storage, the weight specs of model '${this.modelPath}' ` +\n                `are missing.`);\n        }\n        out.weightSpecs = weightSpecs;\n        // Load meta-data fields.\n        const metadataString = this.LS.getItem(this.keys.modelMetadata);\n        if (metadataString != null) {\n            const metadata = JSON.parse(metadataString);\n            out.format = metadata['format'];\n            out.generatedBy = metadata['generatedBy'];\n            out.convertedBy = metadata['convertedBy'];\n            if (metadata['signature'] != null) {\n                out.signature = metadata['signature'];\n            }\n            if (metadata['userDefinedMetadata'] != null) {\n                out.userDefinedMetadata = metadata['userDefinedMetadata'];\n            }\n            if (metadata['modelInitializer'] != null) {\n                out.modelInitializer = metadata['modelInitializer'];\n            }\n        }\n        // Load weight data.\n        const weightDataBase64 = this.LS.getItem(this.keys.weightData);\n        if (weightDataBase64 == null) {\n            throw new Error(`In local storage, the binary weight values of model ` +\n                `'${this.modelPath}' are missing.`);\n        }\n        out.weightData = base64StringToArrayBuffer(weightDataBase64);\n        return out;\n    }\n}\nBrowserLocalStorage.URL_SCHEME = 'localstorage://';\nexport const localStorageRouter = (url) => {\n    if (!env().getBool('IS_BROWSER')) {\n        return null;\n    }\n    else {\n        if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {\n            return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));\n        }\n        else {\n            return null;\n        }\n    }\n};\nIORouterRegistry.registerSaveRouter(localStorageRouter);\nIORouterRegistry.registerLoadRouter(localStorageRouter);\n/**\n * Factory function for local storage IOHandler.\n *\n * This `IOHandler` supports both `save` and `load`.\n *\n * For each model's saved artifacts, four items are saved to local storage.\n *   - `${PATH_SEPARATOR}/${modelPath}/info`: Contains meta-info about the\n *     model, such as date saved, type of the topology, size in bytes, etc.\n *   - `${PATH_SEPARATOR}/${modelPath}/topology`: Model topology. For Keras-\n *     style models, this is a stringized JSON.\n *   - `${PATH_SEPARATOR}/${modelPath}/weight_specs`: Weight specs of the\n *     model, can be used to decode the saved binary weight values (see\n *     item below).\n *   - `${PATH_SEPARATOR}/${modelPath}/weight_data`: Concatenated binary\n *     weight values, stored as a base64-encoded string.\n *\n * Saving may throw an `Error` if the total size of the artifacts exceed the\n * browser-specific quota.\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `IOHandler`, which can be used with, e.g.,\n *   `tf.Model.save`.\n */\nexport function browserLocalStorage(modelPath) {\n    return new BrowserLocalStorage(modelPath);\n}\nexport class BrowserLocalStorageManager {\n    constructor() {\n        assert(env().getBool('IS_BROWSER'), () => 'Current environment is not a web browser');\n        assert(typeof window === 'undefined' ||\n            typeof window.localStorage !== 'undefined', () => 'Current browser does not appear to support localStorage');\n        this.LS = window.localStorage;\n    }\n    async listModels() {\n        const out = {};\n        const prefix = PATH_PREFIX + PATH_SEPARATOR;\n        const suffix = PATH_SEPARATOR + INFO_SUFFIX;\n        for (let i = 0; i < this.LS.length; ++i) {\n            const key = this.LS.key(i);\n            if (key.startsWith(prefix) && key.endsWith(suffix)) {\n                const modelPath = getModelPathFromKey(key);\n                out[modelPath] = JSON.parse(this.LS.getItem(key));\n            }\n        }\n        return out;\n    }\n    async removeModel(path) {\n        path = maybeStripScheme(path);\n        const keys = getModelKeys(path);\n        if (this.LS.getItem(keys.info) == null) {\n            throw new Error(`Cannot find model at path '${path}'`);\n        }\n        const info = JSON.parse(this.LS.getItem(keys.info));\n        this.LS.removeItem(keys.info);\n        this.LS.removeItem(keys.topology);\n        this.LS.removeItem(keys.weightSpecs);\n        this.LS.removeItem(keys.weightData);\n        return info;\n    }\n}\n//# sourceMappingURL=local_storage.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Workaround for allowing cjs module to be included in bundle created by\n// rollup.\nimport * as LongExports from 'long';\n// tslint:disable-next-line\nconst Long = \n// tslint:disable-next-line\nLongExports.default || LongExports;\nexport function hexToLong(hex) {\n    return Long.fromString(hex, true, 16);\n}\n// Some primes between 2^63 and 2^64 for various uses.\n// Hex 0xc3a5c85c97cb3127\nconst k0 = hexToLong('c3a5c85c97cb3127');\n// Hex 0xb492b66fbe98f273\nconst k1 = hexToLong('b492b66fbe98f273');\n// Hex 0x9ae16a3b2f90404f\nconst k2 = hexToLong('9ae16a3b2f90404f');\nfunction shiftMix(val) {\n    return val.xor(val.shru(47));\n}\nfunction fetch(s, offset, numBytes) {\n    const bytes = s.slice(offset, offset + numBytes);\n    return Long.fromBytes(Array.from(bytes), true, true);\n}\nfunction fetch64(s, offset) {\n    return fetch(s, offset, 8);\n}\nfunction fetch32(s, offset) {\n    return fetch(s, offset, 4);\n}\nfunction rotate64(val, shift) {\n    // Avoid shifting by 64: doing so yields an undefined result.\n    return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));\n}\nfunction hashLen16(u, v, mul = hexToLong('9ddfea08eb382d69')) {\n    // Murmur-inspired hashing.\n    let a = u.xor(v).mul(mul);\n    a = a.xor(a.shru(47));\n    let b = v.xor(a).mul(mul);\n    b = b.xor(b.shru(47));\n    b = b.mul(mul);\n    return b;\n}\n// Return a 16-byte hash for 48 bytes.  Quick and dirty.\n// Callers do best to use \"random-looking\" values for a and b.\nfunction weakHashLen32WithSeeds(w, x, y, z, a, b) {\n    a = a.add(w);\n    b = rotate64(b.add(a).add(z), 21);\n    const c = a;\n    a = a.add(x);\n    a = a.add(y);\n    b = b.add(rotate64(a, 44));\n    return [a.add(z), b.add(c)];\n}\nfunction weakHashLen32WithSeedsStr(s, offset, a, b) {\n    return weakHashLen32WithSeeds(fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16), fetch64(s, offset + 24), a, b);\n}\nfunction hashLen0to16(s, len = s.length) {\n    if (len >= 8) {\n        const mul = k2.add(len * 2);\n        const a = fetch64(s, 0).add(k2);\n        const b = fetch64(s, len - 8);\n        const c = rotate64(b, 37).mul(mul).add(a);\n        const d = rotate64(a, 25).add(b).mul(mul);\n        return hashLen16(c, d, mul);\n    }\n    if (len >= 4) {\n        const mul = k2.add(len * 2);\n        const a = fetch32(s, 0);\n        return hashLen16(a.shl(3).add(len), fetch32(s, len - 4), mul);\n    }\n    if (len > 0) {\n        const a = s[0];\n        const b = s[len >> 1];\n        const c = s[len - 1];\n        const y = a + (b << 8);\n        const z = len + (c << 2);\n        return shiftMix(k2.mul(y).xor(k0.mul(z))).mul(k2);\n    }\n    return k2;\n}\nfunction hashLen17to32(s, len = s.length) {\n    const mul = k2.add(len * 2);\n    const a = fetch64(s, 0).mul(k1);\n    const b = fetch64(s, 8);\n    const c = fetch64(s, len - 8).mul(mul);\n    const d = fetch64(s, len - 16).mul(k2);\n    return hashLen16(rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d), a.add(rotate64(b.add(k2), 18)).add(c), mul);\n}\nfunction hashLen33to64(s, len = s.length) {\n    const mul = k2.add(len * 2);\n    const a = fetch64(s, 0).mul(k2);\n    const b = fetch64(s, 8);\n    const c = fetch64(s, len - 8).mul(mul);\n    const d = fetch64(s, len - 16).mul(k2);\n    const y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);\n    const z = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul);\n    const e = fetch64(s, 16).mul(mul);\n    const f = fetch64(s, 24);\n    const g = y.add(fetch64(s, len - 32)).mul(mul);\n    const h = z.add(fetch64(s, len - 24)).mul(mul);\n    return hashLen16(rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h), e.add(rotate64(f.add(a), 18)).add(g), mul);\n}\nexport function fingerPrint64(s, len = s.length) {\n    const seed = Long.fromNumber(81, true);\n    if (len <= 32) {\n        if (len <= 16) {\n            return hashLen0to16(s, len);\n        }\n        else {\n            return hashLen17to32(s, len);\n        }\n    }\n    else if (len <= 64) {\n        return hashLen33to64(s, len);\n    }\n    // For strings over 64 bytes we loop.  Internal state consists of\n    // 56 bytes: v, w, x, y, and z.\n    let x = seed;\n    let y = seed.mul(k1).add(113);\n    let z = shiftMix(y.mul(k2).add(113)).mul(k2);\n    let v = [Long.UZERO, Long.UZERO];\n    let w = [Long.UZERO, Long.UZERO];\n    x = x.mul(k2).add(fetch64(s, 0));\n    let offset = 0;\n    // Set end so that after the loop we have 1 to 64 bytes left to process.\n    const end = ((len - 1) >> 6) * 64;\n    const last64 = end + ((len - 1) & 63) - 63;\n    do {\n        x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);\n        y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);\n        x = x.xor(w[1]);\n        y = y.add(v[0]).add(fetch64(s, offset + 40));\n        z = rotate64(z.add(w[0]), 33).mul(k1);\n        v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));\n        w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));\n        [z, x] = [x, z];\n        offset += 64;\n    } while (offset !== end);\n    const mul = k1.add(z.and(0xff).shl(1));\n    // Point to the last 64 bytes of input.\n    offset = last64;\n    w[0] = w[0].add((len - 1) & 63);\n    v[0] = v[0].add(w[0]);\n    w[0] = w[0].add(v[0]);\n    x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul);\n    y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul);\n    x = x.xor(w[1].mul(9));\n    y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));\n    z = rotate64(z.add(w[0]), 33).mul(mul);\n    v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul), x.add(w[0]));\n    w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));\n    [z, x] = [x, z];\n    return hashLen16(hashLen16(v[0], w[0], mul).add(shiftMix(y).mul(k0)).add(z), hashLen16(v[1], w[1], mul).add(x), mul);\n}\n//# sourceMappingURL=hash_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { complex } from '../ops/complex';\nimport { tensor } from '../ops/tensor';\nimport { sizeFromShape } from '../util';\nimport { DTYPE_VALUE_SIZE_MAP } from './types';\n/** Number of bytes reserved for the length of the string. (32bit integer). */\nconst NUM_BYTES_STRING_LENGTH = 4;\n/**\n * Encode a map from names to weight values as an ArrayBuffer, along with an\n * `Array` of `WeightsManifestEntry` as specification of the encoded weights.\n *\n * This function does not perform sharding.\n *\n * This function is the reverse of `decodeWeights`.\n *\n * @param tensors A map (\"dict\") from names to tensors.\n * @param group Group to which the weights belong (optional).\n * @returns A `Promise` of\n *   - A flat `ArrayBuffer` with all the binary values of the `Tensor`s\n *     concatenated.\n *   - An `Array` of `WeightManifestEntry`s, carrying information including\n *     tensor names, `dtype`s and shapes.\n * @throws Error: on unsupported tensor `dtype`.\n */\nexport async function encodeWeights(tensors, group) {\n    // TODO(adarob, cais): Support quantization.\n    const specs = [];\n    const dataPromises = [];\n    const names = Array.isArray(tensors) ?\n        tensors.map(tensor => tensor.name) :\n        Object.keys(tensors);\n    for (let i = 0; i < names.length; ++i) {\n        const name = names[i];\n        const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];\n        if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool' &&\n            t.dtype !== 'string' && t.dtype !== 'complex64') {\n            throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);\n        }\n        const spec = { name, shape: t.shape, dtype: t.dtype };\n        if (t.dtype === 'string') {\n            const utf8bytes = new Promise(async (resolve) => {\n                const vals = await t.bytes();\n                const totalNumBytes = vals.reduce((p, c) => p + c.length, 0) +\n                    NUM_BYTES_STRING_LENGTH * vals.length;\n                const bytes = new Uint8Array(totalNumBytes);\n                let offset = 0;\n                for (let i = 0; i < vals.length; i++) {\n                    const val = vals[i];\n                    const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);\n                    bytes.set(bytesOfLength, offset);\n                    offset += NUM_BYTES_STRING_LENGTH;\n                    bytes.set(val, offset);\n                    offset += val.length;\n                }\n                resolve(bytes);\n            });\n            dataPromises.push(utf8bytes);\n        }\n        else {\n            dataPromises.push(t.data());\n        }\n        if (group != null) {\n            spec.group = group;\n        }\n        specs.push(spec);\n    }\n    const tensorValues = await Promise.all(dataPromises);\n    return { data: concatenateTypedArrays(tensorValues), specs };\n}\n/**\n * Decode flat ArrayBuffer as weights.\n *\n * This function does not handle sharding.\n *\n * This function is the reverse of `encodeWeights`.\n *\n * @param buffer A flat ArrayBuffer carrying the binary values of the tensors\n *   concatenated in the order specified in `specs`.\n * @param specs Specifications of the names, dtypes and shapes of the tensors\n *   whose value are encoded by `buffer`.\n * @return A map from tensor name to tensor value, with the names corresponding\n *   to names in `specs`.\n * @throws Error, if any of the tensors has unsupported dtype.\n */\nexport function decodeWeights(buffer, specs) {\n    // TODO(adarob, cais): Support quantization.\n    const out = {};\n    let float16Decode;\n    let offset = 0;\n    for (const spec of specs) {\n        const name = spec.name;\n        const dtype = spec.dtype;\n        const shape = spec.shape;\n        const size = sizeFromShape(shape);\n        let values;\n        if ('quantization' in spec) {\n            const quantization = spec.quantization;\n            if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {\n                if (!('min' in quantization && 'scale' in quantization)) {\n                    throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} ` +\n                        `doesn't have corresponding metadata min and scale.`);\n                }\n            }\n            else if (quantization.dtype === 'float16') {\n                if (dtype !== 'float32') {\n                    throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} ` +\n                        `which only supports weights of type float32 not ${dtype}.`);\n                }\n            }\n            else {\n                throw new Error(`Weight ${spec.name} has unknown ` +\n                    `quantization dtype ${quantization.dtype}. ` +\n                    `Supported quantization dtypes are: ` +\n                    `'uint8', 'uint16', and 'float16'.`);\n            }\n            const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];\n            const byteBuffer = buffer.slice(offset, offset + size * quantizationSizeFactor);\n            const quantizedArray = (quantization.dtype === 'uint8') ?\n                new Uint8Array(byteBuffer) :\n                new Uint16Array(byteBuffer);\n            if (dtype === 'float32') {\n                if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {\n                    values = new Float32Array(quantizedArray.length);\n                    for (let i = 0; i < quantizedArray.length; i++) {\n                        const v = quantizedArray[i];\n                        values[i] = v * quantization.scale + quantization.min;\n                    }\n                }\n                else if (quantization.dtype === 'float16') {\n                    if (float16Decode === undefined) {\n                        float16Decode = getFloat16Decoder();\n                    }\n                    values = float16Decode(quantizedArray);\n                }\n                else {\n                    throw new Error(`Unsupported quantization type ${quantization.dtype} ` +\n                        `for weight type float32.`);\n                }\n            }\n            else if (dtype === 'int32') {\n                if (quantization.dtype !== 'uint8' && quantization.dtype !== 'uint16') {\n                    throw new Error(`Unsupported quantization type ${quantization.dtype} ` +\n                        `for weight type int32.`);\n                }\n                values = new Int32Array(quantizedArray.length);\n                for (let i = 0; i < quantizedArray.length; i++) {\n                    const v = quantizedArray[i];\n                    values[i] = Math.round(v * quantization.scale + quantization.min);\n                }\n            }\n            else {\n                throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);\n            }\n            offset += size * quantizationSizeFactor;\n        }\n        else if (dtype === 'string') {\n            const size = sizeFromShape(spec.shape);\n            values = [];\n            for (let i = 0; i < size; i++) {\n                const byteLength = new Uint32Array(buffer.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];\n                offset += NUM_BYTES_STRING_LENGTH;\n                const bytes = new Uint8Array(buffer.slice(offset, offset + byteLength));\n                values.push(bytes);\n                offset += byteLength;\n            }\n        }\n        else {\n            const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];\n            const byteBuffer = buffer.slice(offset, offset + size * dtypeFactor);\n            if (dtype === 'float32') {\n                values = new Float32Array(byteBuffer);\n            }\n            else if (dtype === 'int32') {\n                values = new Int32Array(byteBuffer);\n            }\n            else if (dtype === 'bool') {\n                values = new Uint8Array(byteBuffer);\n            }\n            else if (dtype === 'complex64') {\n                values = new Float32Array(byteBuffer);\n                const real = new Float32Array(values.length / 2);\n                const image = new Float32Array(values.length / 2);\n                for (let i = 0; i < real.length; i++) {\n                    real[i] = values[i * 2];\n                    image[i] = values[i * 2 + 1];\n                }\n                const realTensor = tensor(real, shape, 'float32');\n                const imageTensor = tensor(image, shape, 'float32');\n                out[name] = complex(realTensor, imageTensor);\n                realTensor.dispose();\n                imageTensor.dispose();\n            }\n            else {\n                throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);\n            }\n            offset += size * dtypeFactor;\n        }\n        if (dtype !== 'complex64') {\n            out[name] = tensor(values, shape, dtype);\n        }\n    }\n    return out;\n}\n/**\n * Concatenate TypedArrays into an ArrayBuffer.\n */\nexport function concatenateTypedArrays(xs) {\n    // TODO(adarob, cais): Support quantization.\n    if (xs === null) {\n        throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);\n    }\n    let totalByteLength = 0;\n    // `normalizedXs` is here for this reason: a `TypedArray`'s `buffer'\n    // can have a different byte length from that of the `TypedArray` itself,\n    // for example, when the `TypedArray` is created from an offset in an\n    // `ArrayBuffer`. `normliazedXs` holds `TypedArray`s whose `buffer`s match\n    // the `TypedArray` in byte length. If an element of `xs` does not show\n    // this property, a new `TypedArray` that satisfy this property will be\n    // constructed and pushed into `normalizedXs`.\n    const normalizedXs = [];\n    xs.forEach((x) => {\n        totalByteLength += x.byteLength;\n        // tslint:disable:no-any\n        normalizedXs.push(x.byteLength === x.buffer.byteLength ? x :\n            new x.constructor(x));\n        if (!(x instanceof Float32Array || x instanceof Int32Array ||\n            x instanceof Uint8Array)) {\n            throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);\n        }\n        // tslint:enable:no-any\n    });\n    const y = new Uint8Array(totalByteLength);\n    let offset = 0;\n    normalizedXs.forEach((x) => {\n        y.set(new Uint8Array(x.buffer), offset);\n        offset += x.byteLength;\n    });\n    return y.buffer;\n}\n// Use Buffer on Node.js instead of Blob/atob/btoa\nconst useNodeBuffer = typeof Buffer !== 'undefined' &&\n    (typeof Blob === 'undefined' || typeof atob === 'undefined' ||\n        typeof btoa === 'undefined');\n/**\n * Calculate the byte length of a JavaScript string.\n *\n * Note that a JavaScript string can contain wide characters, therefore the\n * length of the string is not necessarily equal to the byte length.\n *\n * @param str Input string.\n * @returns Byte length.\n */\nexport function stringByteLength(str) {\n    if (useNodeBuffer) {\n        return Buffer.byteLength(str);\n    }\n    return new Blob([str]).size;\n}\n/**\n * Encode an ArrayBuffer as a base64 encoded string.\n *\n * @param buffer `ArrayBuffer` to be converted.\n * @returns A string that base64-encodes `buffer`.\n */\nexport function arrayBufferToBase64String(buffer) {\n    if (useNodeBuffer) {\n        return Buffer.from(buffer).toString('base64');\n    }\n    const buf = new Uint8Array(buffer);\n    let s = '';\n    for (let i = 0, l = buf.length; i < l; i++) {\n        s += String.fromCharCode(buf[i]);\n    }\n    return btoa(s);\n}\n/**\n * Decode a base64 string as an ArrayBuffer.\n *\n * @param str Base64 string.\n * @returns Decoded `ArrayBuffer`.\n */\nexport function base64StringToArrayBuffer(str) {\n    if (useNodeBuffer) {\n        const buf = Buffer.from(str, 'base64');\n        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    }\n    const s = atob(str);\n    const buffer = new Uint8Array(s.length);\n    for (let i = 0; i < s.length; ++i) {\n        buffer.set([s.charCodeAt(i)], i);\n    }\n    return buffer.buffer;\n}\n/**\n * Concatenate a number of ArrayBuffers into one.\n *\n * @param buffers A number of array buffers to concatenate.\n * @returns Result of concatenating `buffers` in order.\n */\nexport function concatenateArrayBuffers(buffers) {\n    if (buffers.length === 1) {\n        return buffers[0];\n    }\n    let totalByteLength = 0;\n    buffers.forEach((buffer) => {\n        totalByteLength += buffer.byteLength;\n    });\n    const temp = new Uint8Array(totalByteLength);\n    let offset = 0;\n    buffers.forEach((buffer) => {\n        temp.set(new Uint8Array(buffer), offset);\n        offset += buffer.byteLength;\n    });\n    return temp.buffer;\n}\n/**\n * Get the basename of a path.\n *\n * Behaves in a way analogous to Linux's basename command.\n *\n * @param path\n */\nexport function basename(path) {\n    const SEPARATOR = '/';\n    path = path.trim();\n    while (path.endsWith(SEPARATOR)) {\n        path = path.slice(0, path.length - 1);\n    }\n    const items = path.split(SEPARATOR);\n    return items[items.length - 1];\n}\n/**\n * Populate ModelArtifactsInfo fields for a model with JSON topology.\n * @param modelArtifacts\n * @returns A ModelArtifactsInfo object.\n */\nexport function getModelArtifactsInfoForJSON(modelArtifacts) {\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n        throw new Error('Expected JSON model topology, received ArrayBuffer.');\n    }\n    return {\n        dateSaved: new Date(),\n        modelTopologyType: 'JSON',\n        modelTopologyBytes: modelArtifacts.modelTopology == null ?\n            0 :\n            stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),\n        weightSpecsBytes: modelArtifacts.weightSpecs == null ?\n            0 :\n            stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),\n        weightDataBytes: modelArtifacts.weightData == null ?\n            0 :\n            modelArtifacts.weightData.byteLength,\n    };\n}\n/**\n * Computes mantisa table for casting Float16 to Float32\n * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n *\n * @returns Uint32Array, 2048 mantissa lookup values.\n */\nfunction computeFloat16MantisaTable() {\n    const convertMantissa = (i) => {\n        let m = i << 13;\n        let e = 0;\n        while ((m & 0x00800000) === 0) {\n            e -= 0x00800000;\n            m <<= 1;\n        }\n        m &= ~0x00800000;\n        e += 0x38800000;\n        return m | e;\n    };\n    const mantisaTable = new Uint32Array(2048);\n    mantisaTable[0] = 0;\n    for (let i = 1; i < 1024; i++) {\n        mantisaTable[i] = convertMantissa(i);\n    }\n    for (let i = 1024; i < 2048; i++) {\n        mantisaTable[i] = 0x38000000 + ((i - 1024) << 13);\n    }\n    return mantisaTable;\n}\n/**\n * Computes exponent table for casting Float16 to Float32\n * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n *\n * @returns Uint32Array, 64 exponent lookup values.\n */\nfunction computeFloat16ExponentTable() {\n    const exponentTable = new Uint32Array(64);\n    exponentTable[0] = 0;\n    exponentTable[31] = 0x47800000;\n    exponentTable[32] = 0x80000000;\n    exponentTable[63] = 0xc7800000;\n    for (let i = 1; i < 31; i++) {\n        exponentTable[i] = i << 23;\n    }\n    for (let i = 33; i < 63; i++) {\n        exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n    }\n    return exponentTable;\n}\n/**\n * Computes offset table for casting Float16 to Float32\n * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n *\n * @returns Uint32Array, 6d offset values.\n */\nfunction computeFloat16OffsetTable() {\n    const offsetTable = new Uint32Array(64);\n    for (let i = 0; i < 64; i++) {\n        offsetTable[i] = 1024;\n    }\n    offsetTable[0] = offsetTable[32] = 0;\n    return offsetTable;\n}\n/**\n * Retrieve a Float16 decoder which will decode a ByteArray of Float16 values\n * to a Float32Array.\n *\n * @returns Function (buffer: Uint16Array) => Float32Array which decodes\n *          the Uint16Array of Float16 bytes to a Float32Array.\n */\nexport function getFloat16Decoder() {\n    // Algorithm is based off of\n    // http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n    // Cache lookup tables\n    const mantisaTable = computeFloat16MantisaTable();\n    const exponentTable = computeFloat16ExponentTable();\n    const offsetTable = computeFloat16OffsetTable();\n    return (quantizedArray) => {\n        const buffer = new ArrayBuffer(4 * quantizedArray.length);\n        const bufferUint32View = new Uint32Array(buffer);\n        for (let index = 0; index < quantizedArray.length; index++) {\n            const float16Bits = quantizedArray[index];\n            const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 0x3ff)] +\n                exponentTable[float16Bits >> 10];\n            bufferUint32View[index] = float32Bits;\n        }\n        return new Float32Array(buffer);\n    };\n}\n//# sourceMappingURL=io_utils.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { Tensor, Variable } from './tensor';\nimport { convertToTensor, convertToTensorArray } from './tensor_util_env';\nimport * as util from './util';\n/**\n * Provided `f(x)`, returns another function `g(x, dy?)`, which gives the\n * gradient of `f(x)` with respect to `x`.\n *\n * If `dy` is provided, the gradient of `f(x).mul(dy).sum()` with respect to\n * `x` is computed instead. `f(x)` must take a single tensor `x` and return a\n * single tensor `y`. If `f()` takes multiple inputs, use `tf.grads` instead.\n *\n * ```js\n * // f(x) = x ^ 2\n * const f = x => x.square();\n * // f'(x) = 2x\n * const g = tf.grad(f);\n *\n * const x = tf.tensor1d([2, 3]);\n * g(x).print();\n * ```\n *\n * ```js\n * // f(x) = x ^ 3\n * const f = x => x.pow(tf.scalar(3, 'int32'));\n * // f'(x) = 3x ^ 2\n * const g = tf.grad(f);\n * // f''(x) = 6x\n * const gg = tf.grad(g);\n *\n * const x = tf.tensor1d([2, 3]);\n * gg(x).print();\n * ```\n *\n * @param f The function f(x), to compute gradient for.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction grad(f) {\n    util.assert(util.isFunction(f), () => 'The f passed in grad(f) must be a function');\n    return (x, dy) => {\n        // x can be of any dtype, thus null as the last argument.\n        const $x = convertToTensor(x, 'x', 'tf.grad', 'string_or_numeric');\n        const $dy = (dy != null) ? convertToTensor(dy, 'dy', 'tf.grad') : null;\n        return ENGINE.tidy(() => {\n            const { value, grads } = ENGINE.gradients(() => f($x), [$x], $dy);\n            if ($dy != null) {\n                util.assertShapesMatch(value.shape, $dy.shape, 'The shape of dy passed in grad(f)(x, dy) must match the shape ' +\n                    'returned by f(x)');\n            }\n            checkGrads(grads);\n            return grads[0];\n        });\n    };\n}\n/**\n * Provided `f(x1, x2,...)`, returns another function `g([x1, x2,...], dy?)`,\n * which gives an array of gradients of `f()` with respect to each input\n * [`x1`,`x2`,...].\n *\n * If `dy` is passed when calling `g()`, the gradient of\n * `f(x1,...).mul(dy).sum()` with respect to each input is computed instead.\n * The provided `f` must take one or more tensors and return a single tensor\n * `y`. If `f()` takes a single input, we recommend using `tf.grad` instead.\n *\n * ```js\n * // f(a, b) = a * b\n * const f = (a, b) => a.mul(b);\n * // df / da = b, df / db = a\n * const g = tf.grads(f);\n *\n * const a = tf.tensor1d([2, 3]);\n * const b = tf.tensor1d([-2, -3]);\n * const [da, db] = g([a, b]);\n * console.log('da');\n * da.print();\n * console.log('db');\n * db.print();\n * ```\n *\n * @param f The function `f(x1, x2,...)` to compute gradients for.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction grads(f) {\n    util.assert(util.isFunction(f), () => 'The f passed in grads(f) must be a function');\n    return (args, dy) => {\n        util.assert(Array.isArray(args), () => 'The args passed in grads(f)(args) must be an array ' +\n            'of `Tensor`s or `TensorLike`s');\n        // args can be of any dtype, thus null as the last argument.\n        const $args = convertToTensorArray(args, 'args', 'tf.grads', 'string_or_numeric');\n        const $dy = (dy != null) ? convertToTensor(dy, 'dy', 'tf.grads') : null;\n        return ENGINE.tidy(() => {\n            const { value, grads } = ENGINE.gradients(() => f(...$args), $args, $dy);\n            if ($dy != null) {\n                util.assertShapesMatch(value.shape, $dy.shape, 'The shape of dy passed in grads(f)([x1,...], dy) must ' +\n                    'match the shape returned by f([x1,...])');\n            }\n            checkGrads(grads);\n            return grads;\n        });\n    };\n}\n/**\n * Like `tf.grad`, but also returns the value of `f()`. Useful when `f()`\n * returns a metric you want to show.\n *\n * The result is a rich object with the following properties:\n * - grad: The gradient of `f(x)` w.r.t `x` (result of `tf.grad`).\n * - value: The value returned by `f(x)`.\n *\n * ```js\n * // f(x) = x ^ 2\n * const f = x => x.square();\n * // f'(x) = 2x\n * const g = tf.valueAndGrad(f);\n *\n * const x = tf.tensor1d([2, 3]);\n * const {value, grad} = g(x);\n *\n * console.log('value');\n * value.print();\n * console.log('grad');\n * grad.print();\n * ```\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction valueAndGrad(f) {\n    util.assert(util.isFunction(f), () => 'The f passed in valueAndGrad(f) must be a function');\n    return (x, dy) => {\n        util.assert(x instanceof Tensor, () => 'The x passed in valueAndGrad(f)(x) must be a tensor');\n        util.assert(dy == null || dy instanceof Tensor, () => 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor');\n        const { grads, value } = ENGINE.gradients(() => f(x), [x], dy);\n        checkGrads(grads);\n        return { grad: grads[0], value };\n    };\n}\n/**\n * Like `tf.grads`, but returns also the value of `f()`. Useful when `f()`\n * returns a metric you want to show.\n *\n * The result is a rich object with the following properties:\n * - grads: The gradients of `f()` w.r.t each input (result of `tf.grads`).\n * - value: The value returned by `f(x)`.\n *\n * ```js\n * // f(a, b) = a * b\n * const f = (a, b) => a.mul(b);\n * // df/da = b, df/db = a\n * const g = tf.valueAndGrads(f);\n *\n * const a = tf.tensor1d([2, 3]);\n * const b = tf.tensor1d([-2, -3]);\n * const {value, grads} = g([a, b]);\n *\n * const [da, db] = grads;\n *\n * console.log('value');\n * value.print();\n *\n * console.log('da');\n * da.print();\n * console.log('db');\n * db.print();\n * ```\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction valueAndGrads(f) {\n    util.assert(util.isFunction(f), () => 'The f passed in valueAndGrads(f) must be a function');\n    return (args, dy) => {\n        util.assert(Array.isArray(args) && args.every(arg => arg instanceof Tensor), () => 'The args passed in valueAndGrads(f)(args) must be array of ' +\n            'tensors');\n        util.assert(dy == null || dy instanceof Tensor, () => 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor');\n        const res = ENGINE.gradients(() => f(...args), args, dy);\n        if (dy != null) {\n            util.assertShapesMatch(res.value.shape, dy.shape, 'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must ' +\n                'match the shape returned by f([x1,...])');\n        }\n        checkGrads(res.grads);\n        return res;\n    };\n}\n/**\n * Computes and returns the gradient of f(x) with respect to the list of\n * trainable variables provided by `varList`. If no list is provided, it\n * defaults to all trainable variables.\n *\n * ```js\n * const a = tf.variable(tf.tensor1d([3, 4]));\n * const b = tf.variable(tf.tensor1d([5, 6]));\n * const x = tf.tensor1d([1, 2]);\n *\n * // f(a, b) = a * x ^ 2 + b * x\n * const f = () => a.mul(x.square()).add(b.mul(x)).sum();\n * // df/da = x ^ 2, df/db = x\n * const {value, grads} = tf.variableGrads(f);\n *\n * Object.keys(grads).forEach(varName => grads[varName].print());\n * ```\n *\n * @param f The function to execute. f() should return a scalar.\n * @param varList The list of variables to compute the gradients with respect\n *     to. Defaults to all trainable variables.\n * @returns An object with the following keys and values:\n *   - `value`: The value of the function `f`.\n *   - `grads`: A map from the names of the variables to the gradients.\n *     If the `varList` argument is provided explicitly and contains a subset of\n *     non-trainable variables, this map in the return value will contain keys\n *     that map the names of the non-trainable variables to `null`.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction variableGrads(f, varList) {\n    util.assert(util.isFunction(f), () => 'The f passed in variableGrads(f) must be a function');\n    util.assert(varList == null ||\n        Array.isArray(varList) && varList.every(v => v instanceof Variable), () => 'The varList passed in variableGrads(f, varList) must be an array ' +\n        'of variables');\n    const specifiedVarList = varList != null;\n    if (!specifiedVarList) {\n        // Get all of the trainable variables.\n        varList = [];\n        for (const varName in ENGINE.registeredVariables) {\n            varList.push(ENGINE.registeredVariables[varName]);\n        }\n    }\n    const specifiedNonTrainable = specifiedVarList ? varList.filter(variable => !variable.trainable) : null;\n    // Prune non-trainable variables.\n    const originalVarCount = varList.length;\n    varList = varList.filter(variable => variable.trainable);\n    util.assert(varList.length > 0, () => `variableGrads() expects at least one of the input variables to ` +\n        `be trainable, but none of the ${originalVarCount} variables is ` +\n        `trainable.`);\n    const allowNoGradients = true;\n    const { value, grads } = ENGINE.gradients(f, varList, null, allowNoGradients);\n    util.assert(grads.some(g => g != null), () => 'Cannot find a connection between any variable and the result of ' +\n        'the loss function y=f(x). Please make sure the operations that ' +\n        'use variables are inside the function f passed to minimize().');\n    util.assert(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it ` +\n        `returned a rank-${value.rank} tensor`);\n    const namedGrads = {};\n    varList.forEach((v, i) => {\n        if (grads[i] != null) {\n            namedGrads[v.name] = grads[i];\n        }\n    });\n    if (specifiedNonTrainable != null) {\n        // If varList is explicitly provided and contains non-trainable values,\n        // add them to the returned gradients with `null` values.\n        specifiedNonTrainable.forEach(v => namedGrads[v.name] = null);\n    }\n    return { value, grads: namedGrads };\n}\n/**\n * Overrides the gradient computation of a function `f`.\n *\n * Takes a function\n * `f(...inputs, save) => {value: Tensor, gradFunc: (dy, saved) => Tensor[]}`\n * and returns another function `g(...inputs)` which takes the same inputs as\n * `f`. When called, `g` returns `f().value`. In backward mode, custom gradients\n * with respect to each input of `f` are computed using `f().gradFunc`.\n *\n * The `save` function passsed to `f` should be used for saving tensors needed\n * in the gradient. And the `saved` passed to the `gradFunc` is a\n * `NamedTensorMap`, which contains those saved tensor.\n *\n * ```js\n * const customOp = tf.customGrad((x, save) => {\n *   // Save x to make sure it's available later for the gradient.\n *   save([x]);\n *   // Override gradient of our custom x ^ 2 op to be dy * abs(x);\n *   return {\n *     value: x.square(),\n *     // Note `saved.x` which points to the `x` we saved earlier.\n *     gradFunc: (dy, saved) => [dy.mul(saved[0].abs())]\n *   };\n * });\n *\n * const x = tf.tensor1d([-1, -2, 3]);\n * const dx = tf.grad(x => customOp(x));\n *\n * console.log(`f(x):`);\n * customOp(x).print();\n * console.log(`f'(x):`);\n * dx(x).print();\n * ```\n *\n * @param f The function to evaluate in forward mode, which should return\n *     `{value: Tensor, gradFunc: (dy, saved) => Tensor[]}`, where `gradFunc`\n *     returns the custom gradients of `f` with respect to its inputs.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction customGrad(f) {\n    return ENGINE.customGrad(f);\n}\nfunction checkGrads(grads) {\n    const numNullGradients = grads.filter(g => g == null).length;\n    if (numNullGradients > 0) {\n        throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.`);\n    }\n}\nexport { customGrad, variableGrads, valueAndGrad, valueAndGrads, grad, grads, };\n//# sourceMappingURL=gradients.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class IORouterRegistry {\n    constructor() {\n        this.saveRouters = [];\n        this.loadRouters = [];\n    }\n    static getInstance() {\n        if (IORouterRegistry.instance == null) {\n            IORouterRegistry.instance = new IORouterRegistry();\n        }\n        return IORouterRegistry.instance;\n    }\n    /**\n     * Register a save-handler router.\n     *\n     * @param saveRouter A function that maps a URL-like string onto an instance\n     * of `IOHandler` with the `save` method defined or `null`.\n     */\n    static registerSaveRouter(saveRouter) {\n        IORouterRegistry.getInstance().saveRouters.push(saveRouter);\n    }\n    /**\n     * Register a load-handler router.\n     *\n     * @param loadRouter A function that maps a URL-like string onto an instance\n     * of `IOHandler` with the `load` method defined or `null`.\n     */\n    static registerLoadRouter(loadRouter) {\n        IORouterRegistry.getInstance().loadRouters.push(loadRouter);\n    }\n    /**\n     * Look up IOHandler for saving, given a URL-like string.\n     *\n     * @param url\n     * @returns If only one match is found, an instance of IOHandler with the\n     * `save` method defined. If no match is found, `null`.\n     * @throws Error, if more than one match is found.\n     */\n    static getSaveHandlers(url) {\n        return IORouterRegistry.getHandlers(url, 'save');\n    }\n    /**\n     * Look up IOHandler for loading, given a URL-like string.\n     *\n     * @param url\n     * @param loadOptions Optional, custom load options.\n     * @returns All valid handlers for `url`, given the currently registered\n     *   handler routers.\n     */\n    static getLoadHandlers(url, loadOptions) {\n        return IORouterRegistry.getHandlers(url, 'load', loadOptions);\n    }\n    static getHandlers(url, handlerType, loadOptions) {\n        const validHandlers = [];\n        const routers = handlerType === 'load' ?\n            IORouterRegistry.getInstance().loadRouters :\n            IORouterRegistry.getInstance().saveRouters;\n        routers.forEach(router => {\n            const handler = router(url, loadOptions);\n            if (handler !== null) {\n                validHandlers.push(handler);\n            }\n        });\n        return validHandlers;\n    }\n}\nexport const registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter);\nexport const registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter);\nexport const getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url);\nexport const getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);\n//# sourceMappingURL=router_registry.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { KernelBackend } from './backends/backend';\nimport { Environment, setEnvironmentGlobal } from './environment';\nimport { getGlobalNamespace } from './global_util';\nimport { Add, Cast, Identity } from './kernel_names';\nimport { getGradient, getKernel, getKernelsForBackend } from './kernel_registry';\nimport { Profiler } from './profiler';\nimport { backpropagateGradients, getFilteredNodesXToY } from './tape';\nimport { setTensorTracker, Tensor, Variable } from './tensor';\nimport { getTensorsInContainer } from './tensor_util';\nimport * as util from './util';\nimport { bytesFromStringArray, makeOnesTypedArray, now, sizeFromShape } from './util';\nfunction isRegisteredKernelInvocation(kernelInvocation) {\n    return kernelInvocation.kernelName != null;\n}\nclass EngineState {\n    constructor() {\n        // Public since optimizers will use it.\n        this.registeredVariables = {};\n        this.nextTapeNodeId = 0;\n        this.numBytes = 0;\n        this.numTensors = 0;\n        this.numStringTensors = 0;\n        this.numDataBuffers = 0;\n        // Number of nested tf.grad() statements when computing higher-order\n        // gradients. E.g. `1` for first-order gradients and `2` for second-order\n        // gradients. Used to track if the tape should be removed after a backprop.\n        this.gradientDepth = 0;\n        // Number of nested kernel calls. When kernel depth is greater than 1, we turn\n        // off the tape.\n        this.kernelDepth = 0;\n        this.scopeStack = [];\n        /**\n         * Keeps track of the number of data moves during a kernel execution. We\n         * maintain a stack since kernels can call other kernels, recursively.\n         */\n        this.numDataMovesStack = [];\n        this.nextScopeId = 0;\n        this.tensorInfo = new WeakMap();\n        this.profiling = false;\n        this.activeProfile = {\n            newBytes: 0,\n            newTensors: 0,\n            peakBytes: 0,\n            kernels: [],\n            result: null,\n            get kernelNames() {\n                return Array.from(new Set(this.kernels.map(k => k.name)));\n            }\n        };\n    }\n    dispose() {\n        for (const variableName in this.registeredVariables) {\n            this.registeredVariables[variableName].dispose();\n        }\n    }\n}\nexport class Engine {\n    constructor(ENV) {\n        this.ENV = ENV;\n        this.registry = {};\n        this.registryFactory = {};\n        this.pendingBackendInitId = 0;\n        this.state = new EngineState();\n    }\n    async ready() {\n        if (this.pendingBackendInit != null) {\n            return this.pendingBackendInit.then(() => { });\n        }\n        if (this.backendInstance != null) {\n            return;\n        }\n        const sortedBackends = this.getSortedBackends();\n        for (let i = 0; i < sortedBackends.length; i++) {\n            const backendName = sortedBackends[i];\n            const success = await this.initializeBackend(backendName).success;\n            if (success) {\n                await this.setBackend(backendName);\n                return;\n            }\n        }\n        throw new Error(`Could not initialize any backends, all backend initializations ` +\n            `failed.`);\n    }\n    get backend() {\n        if (this.pendingBackendInit != null) {\n            throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make ` +\n                `sure to await tf.ready() or await tf.setBackend() before calling ` +\n                `other methods`);\n        }\n        if (this.backendInstance == null) {\n            const { name, asyncInit } = this.initializeBackendsAndReturnBest();\n            if (asyncInit) {\n                throw new Error(`The highest priority backend '${name}' has not yet been ` +\n                    `initialized. Make sure to await tf.ready() or ` +\n                    `await tf.setBackend() before calling other methods`);\n            }\n            this.setBackend(name);\n        }\n        return this.backendInstance;\n    }\n    backendNames() {\n        return Object.keys(this.registryFactory);\n    }\n    findBackend(backendName) {\n        if (!(backendName in this.registry)) {\n            // If the backend hasn't been initialized but we have a registry entry for\n            // it, initialize it and return it.\n            if (backendName in this.registryFactory) {\n                const { asyncInit } = this.initializeBackend(backendName);\n                if (asyncInit) {\n                    // Backend is not ready yet.\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        return this.registry[backendName];\n    }\n    findBackendFactory(backendName) {\n        if (!(backendName in this.registryFactory)) {\n            return null;\n        }\n        return this.registryFactory[backendName].factory;\n    }\n    registerBackend(backendName, factory, priority = 1) {\n        if (backendName in this.registryFactory) {\n            console.warn(`${backendName} backend was already registered. ` +\n                `Reusing existing backend factory.`);\n            return false;\n        }\n        this.registryFactory[backendName] = { factory, priority };\n        return true;\n    }\n    async setBackend(backendName) {\n        if (this.registryFactory[backendName] == null) {\n            throw new Error(`Backend name '${backendName}' not found in registry`);\n        }\n        this.backendName = backendName;\n        if (this.registry[backendName] == null) {\n            this.backendInstance = null;\n            const { success, asyncInit } = this.initializeBackend(backendName);\n            const result = asyncInit ? await success : success;\n            if (!result) {\n                return false;\n            }\n        }\n        this.backendInstance = this.registry[backendName];\n        this.setupRegisteredKernels();\n        // Reset the profiler.\n        this.profiler = new Profiler(this.backendInstance);\n        return true;\n    }\n    setupRegisteredKernels() {\n        const kernels = getKernelsForBackend(this.backendName);\n        kernels.forEach(kernel => {\n            if (kernel.setupFunc != null) {\n                kernel.setupFunc(this.backendInstance);\n            }\n        });\n    }\n    disposeRegisteredKernels(backendName) {\n        const kernels = getKernelsForBackend(backendName);\n        kernels.forEach(kernel => {\n            if (kernel.disposeFunc != null) {\n                kernel.disposeFunc(this.registry[backendName]);\n            }\n        });\n    }\n    /**\n     * Initializes a backend by looking up the backend name in the factory\n     * registry and calling the factory method. Returns a boolean representing\n     * whether the initialization of the backend suceeded. Throws an error if\n     * there is no backend in the factory registry.\n     */\n    initializeBackend(backendName) {\n        const registryFactoryEntry = this.registryFactory[backendName];\n        if (registryFactoryEntry == null) {\n            throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);\n        }\n        try {\n            const backend = registryFactoryEntry.factory();\n            /* Test if the factory returns a promise.\n            Done in a more liberal way than\n            previous 'Promise.resolve(backend)===backend'\n            as we needed to account for custom Promise\n            implementations (e.g. Angular) */\n            if (backend && !(backend instanceof KernelBackend) &&\n                typeof backend.then === 'function') {\n                const promiseId = ++this.pendingBackendInitId;\n                const success = backend\n                    .then(backendInstance => {\n                    // Outdated promise. Another backend was set in the meantime.\n                    if (promiseId < this.pendingBackendInitId) {\n                        return false;\n                    }\n                    this.registry[backendName] = backendInstance;\n                    this.pendingBackendInit = null;\n                    return true;\n                })\n                    .catch(err => {\n                    // Outdated promise. Another backend was set in the meantime.\n                    if (promiseId < this.pendingBackendInitId) {\n                        return false;\n                    }\n                    this.pendingBackendInit = null;\n                    console.warn(`Initialization of backend ${backendName} failed`);\n                    console.warn(err.stack || err.message);\n                    return false;\n                });\n                this.pendingBackendInit = success;\n                return { success, asyncInit: true };\n            }\n            else {\n                this.registry[backendName] = backend;\n                return { success: true, asyncInit: false };\n            }\n        }\n        catch (err) {\n            console.warn(`Initialization of backend ${backendName} failed`);\n            console.warn(err.stack || err.message);\n            return { success: false, asyncInit: false };\n        }\n    }\n    removeBackend(backendName) {\n        if (!(backendName in this.registryFactory)) {\n            throw new Error(`${backendName} backend not found in registry`);\n        }\n        if (this.backendName === backendName && this.pendingBackendInit != null) {\n            // There is a pending promise of the backend we want to remove. Make it\n            // obsolete.\n            this.pendingBackendInitId++;\n        }\n        if (backendName in this.registry) {\n            this.disposeRegisteredKernels(backendName);\n            this.registry[backendName].dispose();\n            delete this.registry[backendName];\n        }\n        delete this.registryFactory[backendName];\n        // Unset the backend if it is active.\n        if (this.backendName === backendName) {\n            this.pendingBackendInit = null;\n            this.backendName = null;\n            this.backendInstance = null;\n        }\n    }\n    getSortedBackends() {\n        if (Object.keys(this.registryFactory).length === 0) {\n            throw new Error('No backend found in registry.');\n        }\n        return Object.keys(this.registryFactory).sort((a, b) => {\n            // Highest priority comes first.\n            return this.registryFactory[b].priority -\n                this.registryFactory[a].priority;\n        });\n    }\n    initializeBackendsAndReturnBest() {\n        const sortedBackends = this.getSortedBackends();\n        for (let i = 0; i < sortedBackends.length; i++) {\n            const backendName = sortedBackends[i];\n            const { success, asyncInit } = this.initializeBackend(backendName);\n            if (asyncInit || success) {\n                return { name: backendName, asyncInit };\n            }\n        }\n        throw new Error(`Could not initialize any backends, all backend initializations ` +\n            `failed.`);\n    }\n    moveData(backend, dataId) {\n        const info = this.state.tensorInfo.get(dataId);\n        const srcBackend = info.backend;\n        const values = this.readSync(dataId);\n        const refCount = srcBackend.refCount(dataId);\n        // Delete the tensor from the old backend and move it to the new\n        // backend.\n        srcBackend.disposeData(dataId, true);\n        info.backend = backend;\n        backend.move(dataId, values, info.shape, info.dtype, refCount);\n        if (this.shouldCheckForMemLeaks()) {\n            // Track the number of moves during a kernel execution to correctly\n            // detect memory leaks.\n            this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;\n        }\n    }\n    tidy(nameOrFn, fn) {\n        let name = null;\n        if (fn == null) {\n            // Called with only 1 argument.\n            if (typeof nameOrFn !== 'function') {\n                throw new Error('Please provide a function to tidy()');\n            }\n            fn = nameOrFn;\n        }\n        else {\n            // Called with 2 arguments.\n            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {\n                throw new Error('When calling with two arguments, the first argument ' +\n                    'to tidy() must be a string');\n            }\n            if (typeof fn !== 'function') {\n                throw new Error('When calling with two arguments, the 2nd argument ' +\n                    'to tidy() must be a function');\n            }\n            name = nameOrFn;\n            // TODO(nsthorat,smilkov): Do operation logging and performance\n            // profiling.\n        }\n        let result;\n        return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {\n            result = fn();\n            if (result instanceof Promise) {\n                console.error('Cannot return a Promise inside of tidy.');\n            }\n            return result;\n        });\n    }\n    scopedRun(start, end, f) {\n        start();\n        try {\n            const res = f();\n            end();\n            return res;\n        }\n        catch (ex) {\n            end();\n            throw ex;\n        }\n    }\n    nextTensorId() {\n        return Engine.nextTensorId++;\n    }\n    nextVariableId() {\n        return Engine.nextVariableId++;\n    }\n    /**\n     * This method is called instead of the public-facing tensor.clone() when\n     * saving a tensor for backwards pass. It makes sure to add the clone\n     * operation to the tape regardless of being called inside a kernel\n     * execution.\n     */\n    clone(x) {\n        const y = ENGINE.runKernel(Identity, { x });\n        const inputs = { x };\n        const grad = (dy) => ({\n            x: () => {\n                const dtype = 'float32';\n                const gradInputs = { x: dy };\n                const attrs = { dtype };\n                return ENGINE.runKernel(Cast, gradInputs, \n                // tslint:disable-next-line: no-unnecessary-type-assertion\n                attrs);\n            }\n        });\n        const saved = [];\n        this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});\n        return y;\n    }\n    /**\n     * Execute a kernel with the given name and return the output tensor.\n     *\n     * @param kernelName The name of the kernel to execute.\n     * @param inputs A map of input names to tensors.\n     * @param attrs A map of attribute names to their values. An attribute is a\n     *     primitive (non-tensor) input to the kernel.\n     * @param inputsToSave A list of tensors, inputs to save for the backprop\n     *     computation.\n     * @param outputsToSave A list of booleans, specifying which output to save\n     *     for the backprop computation. These are booleans since the output\n     * tensors are not visible to the user.\n     */\n    runKernel(kernelName, inputs, attrs) {\n        const hasKernel = getKernel(kernelName, this.backendName) != null;\n        if (!hasKernel) {\n            throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);\n        }\n        return this.runKernelFunc({ kernelName, inputs, attrs });\n    }\n    shouldCheckForMemLeaks() {\n        return this.ENV.getBool('IS_TEST');\n    }\n    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {\n        const numDataIdsAfter = this.backend.numDataIds();\n        // Count the number of data ids associated with the result of the kernel.\n        let numOutputDataIds = 0;\n        outInfos.forEach(info => {\n            // Complex numbers allocate 3 data ids, one for 'real', one for\n            // 'imaginary', and one for the container that holds the former two.\n            numOutputDataIds += (info.dtype === 'complex64' ? 3 : 1);\n        });\n        // Account for the number of moves during kernel execution. A \"data move\"\n        // can happen in the middle of a kernel execution, placing a new (key,value)\n        // pair in the data storage. Since data moves have net zero effect (we\n        // always remove the data from the old backend), we have to cancel them out\n        // when detecting memory leaks.\n        const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];\n        const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;\n        if (dataIdsLeaked > 0) {\n            throw new Error(`Backend '${this.backendName}' has an internal memory leak ` +\n                `(${dataIdsLeaked} data ids) after running '${kernelName}'`);\n        }\n    }\n    /**\n     * Internal helper method to execute a kernel Func\n     *\n     * Use `runKernel` to execute kernels from outside of engine.\n     */\n    runKernelFunc(kernelParams) {\n        let outputs;\n        let saved = [];\n        const isTapeOn = this.isTapeOn();\n        const startingBytecount = this.state.numBytes;\n        const startingNumTensors = this.state.numTensors;\n        if (this.shouldCheckForMemLeaks()) {\n            this.state.numDataMovesStack.push(0);\n        }\n        let kernelFunc;\n        if (this.backendName == null) {\n            // backend has not been initialized yet (backend initialization is lazy\n            // can be deferred until an op/ kernel is run).\n            // The below getter has side effects that will try to initialize the\n            // backend and set properties like this.backendName\n            // tslint:disable-next-line: no-unused-expression\n            this.backend;\n        }\n        let out;\n        const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ?\n            kernelParams.kernelName :\n            this.state.activeScope != null ? this.state.activeScope.name : '';\n        // Create the kernelFunc from either a registered kernel OR passed in\n        // forward/backward functions (used by custom grad). In this context a\n        // kernelFunc wraps a kernel implementation with some bookkeeping.\n        if (isRegisteredKernelInvocation(kernelParams)) {\n            const { kernelName, inputs, attrs } = kernelParams;\n            if (this.backendName == null) {\n                // backend has not been initialized yet (backend initialization is lazy\n                // can be deferred until an op/ kernel is run).\n                // The below getter has side effects that will try to initialize the\n                // backend and set properties like this.backendName\n                // tslint:disable-next-line: no-unused-expression\n                this.backend;\n            }\n            const kernel = getKernel(kernelName, this.backendName);\n            util.assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);\n            kernelFunc = () => {\n                const numDataIdsBefore = this.backend.numDataIds();\n                out = kernel.kernelFunc({ inputs, attrs, backend: this.backend });\n                const outInfos = Array.isArray(out) ? out : [out];\n                if (this.shouldCheckForMemLeaks()) {\n                    this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);\n                }\n                const outTensors = outInfos.map((outInfo) => {\n                    // todo (yassogba) remove this option (Tensor) when node backend\n                    // methods have been modularized and they all return tensorInfo.\n                    // TensorInfos do not have a rank attribute.\n                    if (outInfo.rank != null) {\n                        return outInfo;\n                    }\n                    const { dataId, shape, dtype } = outInfo;\n                    return this.makeTensorFromDataId(dataId, shape, dtype);\n                });\n                // Save any required inputs and outputs.\n                // Do not save unless we are recording to the tape. Otherwise it would\n                // cause a mem leak since there would be no backprop for these tensors\n                // (which would otherwise dispose them).\n                if (isTapeOn) {\n                    const tensorsToSave = this.getTensorsForGradient(kernelName, inputs, outTensors);\n                    saved = this.saveTensorsForBackwardMode(tensorsToSave);\n                }\n                return outTensors;\n            };\n        }\n        else {\n            const { forwardFunc } = kernelParams;\n            // Running a customGrad op.\n            const saveFunc = (tensors) => {\n                // Do not save unless we are recording to the tape. Otherwise it would\n                // cause a mem leak since we would never run backprop, which disposes\n                // the kept tensors.\n                if (!isTapeOn) {\n                    return;\n                }\n                saved = tensors.map(tensor => this.keep(this.clone(tensor)));\n            };\n            kernelFunc = () => {\n                const numDataIdsBefore = this.backend.numDataIds();\n                out = this.tidy(() => forwardFunc(this.backend, saveFunc));\n                const outs = (Array.isArray(out) ? out : [out]);\n                if (this.shouldCheckForMemLeaks()) {\n                    // Scope name is used to print a more helpful error message if needed.\n                    this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);\n                }\n                return outs;\n            };\n        }\n        //\n        // Run the kernelFunc. Optionally profiling it.\n        //\n        const { inputs, attrs } = kernelParams;\n        const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ?\n            null :\n            kernelParams.backwardsFunc;\n        let kernelProfile;\n        this.scopedRun(\n        // Stop recording to a tape when running a kernel.\n        () => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {\n            if (!this.ENV.getBool('DEBUG') && !this.state.profiling) {\n                outputs = kernelFunc();\n            }\n            else {\n                kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());\n                if (this.ENV.getBool('DEBUG')) {\n                    this.profiler.logKernelProfile(kernelProfile);\n                }\n                outputs = kernelProfile.outputs;\n            }\n        });\n        if (isTapeOn) {\n            this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);\n        }\n        if (this.state.profiling) {\n            this.state.activeProfile.kernels.push({\n                name: kernelOrScopeName,\n                bytesAdded: this.state.numBytes - startingBytecount,\n                totalBytesSnapshot: this.state.numBytes,\n                tensorsAdded: this.state.numTensors - startingNumTensors,\n                totalTensorsSnapshot: this.state.numTensors,\n                inputShapes: Object.keys(inputs).map(key => inputs[key] != null ? inputs[key].shape : null),\n                outputShapes: outputs.map(item => item.shape),\n                kernelTimeMs: kernelProfile.timeMs,\n                extraInfo: kernelProfile.extraInfo\n            });\n        }\n        return (Array.isArray(out) ? outputs : outputs[0]);\n    }\n    /**\n     * Saves tensors used in forward mode for use in backward mode.\n     *\n     * @param tensors the list of tensors to save.\n     */\n    saveTensorsForBackwardMode(tensors) {\n        const saved = tensors.map(tensor => this.keep(this.clone(tensor)));\n        return saved;\n    }\n    /**\n     * Returns a list of tensors to save for a given gradient calculation.\n     *\n     * @param kernelName name of kernel to look up gradient for.\n     * @param inputs a map of input tensors.\n     * @param outputs an array of output tensors from forward mode of kernel.\n     */\n    getTensorsForGradient(kernelName, inputs, outputs) {\n        const gradConfig = getGradient(kernelName);\n        if (gradConfig != null) {\n            const inputsToSave = gradConfig.inputsToSave || [];\n            const outputsToSave = gradConfig.outputsToSave || [];\n            // If saveAllInputs is true, all inputs will be saved. Otherwise, inputs\n            // specified in inputsToSave will be saved.\n            let inputTensorsToSave;\n            if (gradConfig.saveAllInputs) {\n                util.assert(Array.isArray(inputs), () => 'saveAllInputs is true, expected inputs to be an array.');\n                inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);\n            }\n            else {\n                inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);\n            }\n            const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);\n            return inputTensorsToSave.concat(outputTensorsToSave);\n        }\n        // We return an empty list rather than throw an error because the kernel we\n        // are looking up may not actually be relevant to backproping through the\n        // overall function\n        //\n        // See 'does not error if irrelevant (pruned) ops are missing grads' test\n        // in gradients_test.ts for an example.\n        return [];\n    }\n    /**\n     * Internal method used by public APIs for tensor creation. Makes a new\n     * tensor with the provided shape, dtype and values. It always\n     * creates a new data id and writes the values to the underlying backend.\n     */\n    makeTensor(values, shape, dtype, backend) {\n        if (values == null) {\n            throw new Error('Values passed to engine.makeTensor() are null');\n        }\n        dtype = dtype || 'float32';\n        backend = backend || this.backend;\n        let backendVals = values;\n        if (dtype === 'string' && util.isString(values[0])) {\n            backendVals = values.map(d => util.encodeString(d));\n        }\n        const dataId = backend.write(backendVals, shape, dtype);\n        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());\n        this.trackTensor(t, backend);\n        // Count bytes for string tensors.\n        if (dtype === 'string') {\n            const info = this.state.tensorInfo.get(dataId);\n            const newBytes = bytesFromStringArray(backendVals);\n            this.state.numBytes += newBytes - info.bytes;\n            info.bytes = newBytes;\n        }\n        return t;\n    }\n    /**\n     * Internal method used by backends. Makes a new tensor\n     * that is a wrapper around an existing data id. It doesn't create\n     * a new data id, only increments the ref count used in memory tracking.\n     */\n    makeTensorFromDataId(dataId, shape, dtype, backend) {\n        dtype = dtype || 'float32';\n        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());\n        this.trackTensor(t, backend);\n        return t;\n    }\n    makeVariable(initialValue, trainable = true, name, dtype) {\n        name = name || this.nextVariableId().toString();\n        if (dtype != null && dtype !== initialValue.dtype) {\n            initialValue = initialValue.cast(dtype);\n        }\n        const v = new Variable(initialValue, trainable, name, this.nextTensorId());\n        if (this.state.registeredVariables[v.name] != null) {\n            throw new Error(`Variable with name ${v.name} was already registered`);\n        }\n        this.state.registeredVariables[v.name] = v;\n        this.incRef(v, this.backend);\n        return v;\n    }\n    trackTensor(a, backend) {\n        this.state.numTensors++;\n        if (a.dtype === 'string') {\n            this.state.numStringTensors++;\n        }\n        // Bytes for complex numbers are counted by their components. Bytes for\n        // string tensors are counted when writing values.\n        let bytes = 0;\n        if (a.dtype !== 'complex64' && a.dtype !== 'string') {\n            bytes = a.size * util.bytesPerElement(a.dtype);\n        }\n        this.state.numBytes += bytes;\n        if (!this.state.tensorInfo.has(a.dataId)) {\n            this.state.numDataBuffers++;\n            this.state.tensorInfo.set(a.dataId, {\n                backend: backend || this.backend,\n                dtype: a.dtype,\n                shape: a.shape,\n                bytes\n            });\n        }\n        if (!(a instanceof Variable)) {\n            this.track(a);\n        }\n    }\n    // Track the tensor by dataId and increase the refCount for the dataId in the\n    // backend.\n    // TODO(pyu10055): This is currently used by makeVariable method, to increase\n    // refCount on the backend for the dataId. It can potentially be replaced with\n    // Identity op indead of calling backend directly.\n    incRef(a, backend) {\n        this.trackTensor(a, backend);\n        this.backend.incRef(a.dataId);\n    }\n    removeDataId(dataId, backend) {\n        if (this.state.tensorInfo.has(dataId) &&\n            this.state.tensorInfo.get(dataId).backend === backend) {\n            this.state.tensorInfo.delete(dataId);\n            this.state.numDataBuffers--;\n        }\n    }\n    disposeTensor(a) {\n        if (!this.state.tensorInfo.has(a.dataId)) {\n            return;\n        }\n        const info = this.state.tensorInfo.get(a.dataId);\n        this.state.numTensors--;\n        if (a.dtype === 'string') {\n            this.state.numStringTensors--;\n            this.state.numBytes -= info.bytes;\n        }\n        // Don't count bytes for complex numbers as they are counted by their\n        // components.\n        if (a.dtype !== 'complex64' && a.dtype !== 'string') {\n            const bytes = a.size * util.bytesPerElement(a.dtype);\n            this.state.numBytes -= bytes;\n        }\n        // Remove the reference to dataId if backend dispose the data successfully\n        if (info.backend.disposeData(a.dataId)) {\n            this.removeDataId(a.dataId, info.backend);\n        }\n        // TODO(nsthorat): Construct an error and save the stack trace for\n        // debugging when in debug mode. Creating a stack trace is too expensive\n        // to do unconditionally.\n    }\n    disposeVariables() {\n        for (const varName in this.state.registeredVariables) {\n            const v = this.state.registeredVariables[varName];\n            this.disposeVariable(v);\n        }\n    }\n    disposeVariable(v) {\n        this.disposeTensor(v);\n        if (this.state.registeredVariables[v.name] != null) {\n            delete this.state.registeredVariables[v.name];\n        }\n    }\n    memory() {\n        const info = this.backend.memory();\n        info.numTensors = this.state.numTensors;\n        info.numDataBuffers = this.state.numDataBuffers;\n        info.numBytes = this.state.numBytes;\n        if (this.state.numStringTensors > 0) {\n            info.unreliable = true;\n            if (info.reasons == null) {\n                info.reasons = [];\n            }\n            info.reasons.push('Memory usage by string tensors is approximate ' +\n                '(2 bytes per character)');\n        }\n        return info;\n    }\n    async profile(query) {\n        this.state.profiling = true;\n        const startBytes = this.state.numBytes;\n        const startNumTensors = this.state.numTensors;\n        this.state.activeProfile.kernels = [];\n        this.state.activeProfile.result = await query();\n        this.state.profiling = false;\n        this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map(d => d.totalBytesSnapshot));\n        this.state.activeProfile.newBytes = this.state.numBytes - startBytes;\n        this.state.activeProfile.newTensors =\n            this.state.numTensors - startNumTensors;\n        for (const kernel of this.state.activeProfile.kernels) {\n            kernel.kernelTimeMs = await kernel.kernelTimeMs;\n            kernel.extraInfo = await kernel.extraInfo;\n        }\n        return this.state.activeProfile;\n    }\n    isTapeOn() {\n        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;\n    }\n    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {\n        const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };\n        const gradConfig = getGradient(kernelName);\n        if (gradConfig != null) {\n            gradientsFunc = gradConfig.gradFunc;\n        }\n        if (gradientsFunc != null) {\n            tapeNode.gradient = (dys) => {\n                // TODO(smilkov): To optimize back-prop, pass dys that are not used in\n                // the backprop graph to the user as null instead of zeros\n                dys = dys.map((dy, i) => {\n                    if (dy == null) {\n                        const output = outputs[i];\n                        const vals = util.makeZerosTypedArray(output.size, output.dtype);\n                        return this.makeTensor(vals, output.shape, output.dtype);\n                    }\n                    return dy;\n                });\n                // Grad functions of ops with single outputs expect a dy, while ops\n                // with multiple outputs expect dys (array of dy).\n                return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);\n            };\n        }\n        this.state.activeTape.push(tapeNode);\n    }\n    keep(result) {\n        result.kept = true;\n        return result;\n    }\n    startTape() {\n        if (this.state.gradientDepth === 0) {\n            this.state.activeTape = [];\n        }\n        this.state.gradientDepth++;\n    }\n    endTape() {\n        this.state.gradientDepth--;\n    }\n    /**\n     * Start a scope. Use this with endScope() to achieve the same functionality\n     * as scope() without the need for a function closure.\n     */\n    startScope(name) {\n        const scopeInfo = {\n            track: [],\n            name: 'unnamed scope',\n            id: this.state.nextScopeId++\n        };\n        if (name) {\n            scopeInfo.name = name;\n        }\n        this.state.scopeStack.push(scopeInfo);\n        this.state.activeScope = scopeInfo;\n    }\n    /**\n     * End a scope. Use this with startScope() to achieve the same functionality\n     * as scope() without the need for a function closure.\n     */\n    endScope(result) {\n        const tensorsToTrackInParent = getTensorsInContainer(result);\n        const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map(t => t.id));\n        // Dispose the arrays tracked in this scope.\n        for (let i = 0; i < this.state.activeScope.track.length; i++) {\n            const tensor = this.state.activeScope.track[i];\n            if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) {\n                tensor.dispose();\n            }\n        }\n        const oldScope = this.state.scopeStack.pop();\n        this.state.activeScope = this.state.scopeStack.length === 0 ?\n            null :\n            this.state.scopeStack[this.state.scopeStack.length - 1];\n        // Track the current result in the parent scope.\n        tensorsToTrackInParent.forEach(tensor => {\n            // Only track the tensor if was allocated in the inner scope and is not\n            // globally kept.\n            if (!tensor.kept && tensor.scopeId === oldScope.id) {\n                this.track(tensor);\n            }\n        });\n    }\n    /**\n     * Returns gradients of `f` with respect to each of the `xs`. The gradients\n     * returned are of the same length as `xs`, but some might be null if `f`\n     * was not a function of that `x`. It also takes optional dy to multiply the\n     * gradient, which defaults to `1`.\n     */\n    gradients(f, xs, dy, allowNoGradients = false) {\n        util.assert(xs.length > 0, () => 'gradients() received an empty list of xs.');\n        if (dy != null && dy.dtype !== 'float32') {\n            throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);\n        }\n        const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy('forward', f));\n        util.assert(y instanceof Tensor, () => 'The result y returned by f() must be a tensor.');\n        // Filter out the nodes that don't connect x => y.\n        const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);\n        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {\n            throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +\n                'that the f you passed encloses all operations that lead from x ' +\n                'to y.');\n        }\n        return this.tidy('backward', () => {\n            const accumulatedGradientMap = {};\n            accumulatedGradientMap[y.id] = (dy == null) ? ones(y.shape) : dy;\n            // Backprop gradients through the filtered nodes.\n            backpropagateGradients(accumulatedGradientMap, filteredTape, \n            // Pass the tidy function to avoid circular dep with `tape.ts`.\n            f => this.tidy(f), \n            // Pass an add function to avoide a circular dep with `tape.ts`.\n            add);\n            const grads = xs.map(x => accumulatedGradientMap[x.id]);\n            if (this.state.gradientDepth === 0) {\n                // This means that we are not computing higher-order gradients\n                // and can clean up the tape.\n                this.state.activeTape.forEach(node => {\n                    for (const tensor of node.saved) {\n                        tensor.dispose();\n                    }\n                });\n                this.state.activeTape = null;\n            }\n            return { value: y, grads };\n        });\n    }\n    customGrad(f) {\n        util.assert(util.isFunction(f), () => 'The f passed in customGrad(f) must be a function.');\n        return (...inputs) => {\n            util.assert(inputs.every(t => t instanceof Tensor), () => 'The args passed in customGrad(f)(x1, x2,...) must all be ' +\n                'tensors');\n            let res;\n            const inputMap = {};\n            inputs.forEach((input, i) => {\n                inputMap[i] = input;\n            });\n            const forwardFunc = (_, save) => {\n                res = f(...[...inputs, save]);\n                util.assert(res.value instanceof Tensor, () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.value` is a tensor');\n                util.assert(util.isFunction(res.gradFunc), () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.gradFunc` is a function.');\n                return res.value;\n            };\n            const backwardsFunc = (dy, saved) => {\n                const gradRes = res.gradFunc(dy, saved);\n                const grads = Array.isArray(gradRes) ? gradRes : [gradRes];\n                util.assert(grads.length === inputs.length, () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.gradFunc` is a function that returns ' +\n                    'the same number of tensors as inputs passed to f(...).');\n                util.assert(grads.every(t => t instanceof Tensor), () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.gradFunc` is a function that returns ' +\n                    'a list of only tensors.');\n                const gradMap = {};\n                grads.forEach((grad, i) => {\n                    gradMap[i] = () => grad;\n                });\n                return gradMap;\n            };\n            return this.runKernelFunc({\n                forwardFunc,\n                backwardsFunc,\n                inputs: inputMap,\n            });\n        };\n    }\n    readSync(dataId) {\n        // Route the read to the correct backend.\n        const info = this.state.tensorInfo.get(dataId);\n        return info.backend.readSync(dataId);\n    }\n    read(dataId) {\n        // Route the read to the correct backend.\n        const info = this.state.tensorInfo.get(dataId);\n        return info.backend.read(dataId);\n    }\n    async time(query) {\n        const start = now();\n        const timingInfo = await this.backend.time(query);\n        timingInfo.wallMs = now() - start;\n        return timingInfo;\n    }\n    /**\n     * Tracks a Tensor in the current scope to be automatically cleaned up\n     * when the current scope ends, and returns the value.\n     *\n     * @param result The Tensor to track in the current scope.\n     */\n    track(result) {\n        if (this.state.activeScope != null) {\n            result.scopeId = this.state.activeScope.id;\n            this.state.activeScope.track.push(result);\n        }\n        return result;\n    }\n    get registeredVariables() {\n        return this.state.registeredVariables;\n    }\n    /**\n     * Resets the engine state. Removes all backends but does not remove\n     * registered backend factories.\n     */\n    reset() {\n        // Make any pending promise obsolete.\n        this.pendingBackendInitId++;\n        this.state.dispose();\n        this.ENV.reset();\n        this.state = new EngineState();\n        for (const backendName in this.registry) {\n            this.disposeRegisteredKernels(backendName);\n            this.registry[backendName].dispose();\n            delete this.registry[backendName];\n        }\n        this.backendName = null;\n        this.backendInstance = null;\n        this.pendingBackendInit = null;\n    }\n}\nEngine.nextTensorId = 0;\nEngine.nextVariableId = 0;\nfunction ones(shape) {\n    const values = makeOnesTypedArray(sizeFromShape(shape), 'float32');\n    return ENGINE.makeTensor(values, shape, 'float32');\n}\nexport function getOrMakeEngine() {\n    const ns = getGlobalNamespace();\n    if (ns._tfengine == null) {\n        const environment = new Environment(ns);\n        ns._tfengine = new Engine(environment);\n    }\n    setEnvironmentGlobal(ns._tfengine.ENV);\n    // Tell the current tensor interface that the global engine is responsible\n    // for tracking.\n    setTensorTracker(() => ns._tfengine);\n    return ns._tfengine;\n}\nexport const ENGINE = getOrMakeEngine();\n/**\n * A implementation of the add op for use within engine and tape.\n *\n * This allows us to avoid a circular dependency between add.ts and engine.\n * It is exported to be available in tape tests.\n */\nexport function add(a, b) {\n    // We duplicate Add here to avoid a circular dependency with add.ts.\n    const inputs = { a, b };\n    return ENGINE.runKernel(Add, inputs);\n}\n//# sourceMappingURL=engine.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from './environment';\nimport { getGlobal } from './global_util';\nconst kernelRegistry = getGlobal('kernelRegistry', () => new Map());\nconst gradRegistry = getGlobal('gradRegistry', () => new Map());\n/**\n * Returns the kernel function (code) associated with the provided names.\n *\n * @param kernelName The official name of the kernel.\n * @param backendName The official name of the backend.\n */\nexport function getKernel(kernelName, backendName) {\n    const key = makeKey(kernelName, backendName);\n    return kernelRegistry.get(key);\n}\n/**\n * Returns the registered gradient info associated with the provided kernel.\n * @param kernelName The official TF kernel name.\n */\nexport function getGradient(kernelName) {\n    return gradRegistry.get(kernelName);\n}\nexport function getKernelsForBackend(backendName) {\n    const it = kernelRegistry.entries();\n    const result = [];\n    while (true) {\n        const { done, value } = it.next();\n        if (done) {\n            break;\n        }\n        const [key, config] = value;\n        const [backend,] = key.split('_');\n        if (backend === backendName) {\n            result.push(config);\n        }\n    }\n    return result;\n}\n/**\n * Registers the function (forward pass) for the kernel in a global registry.\n *\n * @param config A config object with the following properties:\n * - `kernelName` The official name of the kernel.\n * - `backendName` The official name of the backend.\n * - `kernelFunc` The function to run during the forward pass of the kernel.\n * - `setupFunc` Optional. Gets called once, after the backend initializes.\n * - `disposeFunc` Optional. Gets called once, right before the backend is\n * disposed.\n */\nexport function registerKernel(config) {\n    const { kernelName, backendName } = config;\n    const key = makeKey(kernelName, backendName);\n    if (kernelRegistry.has(key)) {\n        console.warn(`The kernel '${kernelName}' for backend ` +\n            `'${backendName}' is already registered`);\n    }\n    kernelRegistry.set(key, config);\n}\n/**\n * Registers a gradient function for a given kernel in the global registry,\n * to be used during the back-propagation of that kernel.\n *\n * @param config An object with the following properties:\n * - `kernelName` The name of the kernel that the gradient function is for.\n * - `gradFunc` The function to run during back-propagation.\n */\nexport function registerGradient(config) {\n    const { kernelName } = config;\n    if (gradRegistry.has(kernelName)) {\n        // TODO (yassogba) after 3.0 assess whether we need to keep this gated\n        // to debug mode.\n        if (env().getBool('DEBUG')) {\n            console.warn(`Overriding the gradient for '${kernelName}'`);\n        }\n    }\n    gradRegistry.set(kernelName, config);\n}\n/**\n * Removes the kernel function from the registry.\n *\n * @param kernelName The official name of the kernel.\n * @param backendName The official name of the backend.\n *\n */\nexport function unregisterKernel(kernelName, backendName) {\n    const key = makeKey(kernelName, backendName);\n    if (!kernelRegistry.has(key)) {\n        throw new Error(`The kernel '${kernelName}' for backend ` +\n            `'${backendName}' is not registered`);\n    }\n    kernelRegistry.delete(key);\n}\n/** Removes the registered gradient from the global registry. */\nexport function unregisterGradient(kernelName) {\n    if (!gradRegistry.has(kernelName)) {\n        throw new Error(`The gradient '${kernelName}' for backend is not registered`);\n    }\n    gradRegistry.delete(kernelName);\n}\n/**\n * Finds kernels that have already been registered to a backend and re-registers\n * them for a new backend. Useful for registering custom backends.\n * @param registeredBackendName Already registered backend.\n * @param newBackendName New backend.\n */\nexport function copyRegisteredKernels(registeredBackendName, newBackendName) {\n    const kernels = getKernelsForBackend(registeredBackendName);\n    kernels.forEach(kernelConfig => {\n        const newKernelConfig = Object.assign({}, kernelConfig, { backendName: newBackendName });\n        registerKernel(newKernelConfig);\n    });\n}\nfunction makeKey(kernelName, backendName) {\n    return `${backendName}_${kernelName}`;\n}\n//# sourceMappingURL=kernel_registry.js.map","export const Abs = 'Abs';\nexport const Acos = 'Acos';\nexport const Acosh = 'Acosh';\nexport const Add = 'Add';\nexport const AddN = 'AddN';\nexport const All = 'All';\nexport const Any = 'Any';\nexport const ArgMax = 'ArgMax';\nexport const ArgMin = 'ArgMin';\nexport const Asin = 'Asin';\nexport const Asinh = 'Asinh';\nexport const Atan = 'Atan';\nexport const Atanh = 'Atanh';\nexport const Atan2 = 'Atan2';\nexport const AvgPool = 'AvgPool';\nexport const AvgPoolGrad = 'AvgPoolGrad';\nexport const AvgPool3D = 'AvgPool3D';\nexport const AvgPool3DGrad = 'AvgPool3DGrad';\nexport const BatchMatMul = 'BatchMatMul';\nexport const BatchToSpaceND = 'BatchToSpaceND';\nexport const Bincount = 'Bincount';\nexport const BroadcastTo = 'BroadcastTo';\nexport const Cast = 'Cast';\nexport const Ceil = 'Ceil';\nexport const ClipByValue = 'ClipByValue';\nexport const Complex = 'Complex';\nexport const ComplexAbs = 'ComplexAbs';\nexport const Concat = 'Concat';\nexport const Conv2D = 'Conv2D';\nexport const Conv2DBackpropFilter = 'Conv2DBackpropFilter';\nexport const Conv2DBackpropInput = 'Conv2DBackpropInput';\nexport const Conv3D = 'Conv3D';\nexport const Conv3DBackpropFilterV2 = 'Conv3DBackpropFilterV2';\nexport const Conv3DBackpropInputV2 = 'Conv3DBackpropInputV2';\nexport const Cos = 'Cos';\nexport const Cosh = 'Cosh';\nexport const Cumsum = 'Cumsum';\nexport const CropAndResize = 'CropAndResize';\nexport const DenseBincount = 'DenseBincount';\nexport const DepthToSpace = 'DepthToSpace';\nexport const DepthwiseConv2dNative = 'DepthwiseConv2dNative';\nexport const DepthwiseConv2dNativeBackpropFilter = 'DepthwiseConv2dNativeBackpropFilter';\nexport const DepthwiseConv2dNativeBackpropInput = 'DepthwiseConv2dNativeBackpropInput';\nexport const Diag = 'Diag';\nexport const Dilation2D = 'Dilation2D';\nexport const Dilation2DBackpropInput = 'Dilation2DBackpropInput';\nexport const Dilation2DBackpropFilter = 'Dilation2DBackpropFilter';\nexport const RealDiv = 'RealDiv';\nexport const Einsum = 'Einsum';\nexport const Elu = 'Elu';\nexport const EluGrad = 'EluGrad';\nexport const Erf = 'Erf';\nexport const Equal = 'Equal';\nexport const Exp = 'Exp';\nexport const ExpandDims = 'ExpandDims';\nexport const Expm1 = 'Expm1';\nexport const FFT = 'FFT';\nexport const Fill = 'Fill';\nexport const FlipLeftRight = 'FlipLeftRight';\nexport const Floor = 'Floor';\nexport const FloorDiv = 'FloorDiv';\nexport const FusedBatchNorm = 'FusedBatchNorm';\nexport const GatherV2 = 'GatherV2';\nexport const GatherNd = 'GatherNd';\nexport const Greater = 'Greater';\nexport const GreaterEqual = 'GreaterEqual';\nexport const Identity = 'Identity';\nexport const IFFT = 'IFFT';\nexport const Imag = 'Imag';\nexport const IsFinite = 'IsFinite';\nexport const IsInf = 'IsInf';\nexport const IsNan = 'IsNan';\nexport const LeakyRelu = 'LeakyRelu';\nexport const Less = 'Less';\nexport const LessEqual = 'LessEqual';\nexport const LinSpace = 'LinSpace';\nexport const Log = 'Log';\nexport const Log1p = 'Log1p';\nexport const LogicalAnd = 'LogicalAnd';\nexport const LogicalNot = 'LogicalNot';\nexport const LogicalOr = 'LogicalOr';\nexport const LogSoftmax = 'LogSoftmax';\nexport const LRN = 'LRN';\nexport const LRNGrad = 'LRNGrad';\nexport const Max = 'Max';\nexport const Maximum = 'Maximum';\nexport const MaxPool = 'MaxPool';\nexport const MaxPoolGrad = 'MaxPoolGrad';\nexport const MaxPool3D = 'MaxPool3D';\nexport const MaxPool3DGrad = 'MaxPool3DGrad';\nexport const MaxPoolWithArgmax = 'MaxPoolWithArgmax';\nexport const Mean = 'Mean';\nexport const Min = 'Min';\nexport const Minimum = 'Minimum';\nexport const MirrorPad = 'MirrorPad';\nexport const Mod = 'Mod';\nexport const Multinomial = 'Multinomial';\nexport const Multiply = 'Multiply';\nexport const Neg = 'Neg';\nexport const NotEqual = 'NotEqual';\nexport const NonMaxSuppressionV3 = 'NonMaxSuppressionV3';\nexport const NonMaxSuppressionV4 = 'NonMaxSuppressionV4';\nexport const NonMaxSuppressionV5 = 'NonMaxSuppressionV5';\nexport const OnesLike = 'OnesLike';\nexport const OneHot = 'OneHot';\nexport const Pack = 'Pack';\nexport const PadV2 = 'PadV2';\nexport const Pool = 'Pool';\nexport const Pow = 'Pow';\nexport const Prelu = 'Prelu';\nexport const Prod = 'Prod';\nexport const Range = 'Range';\nexport const Real = 'Real';\nexport const Reciprocal = 'Reciprocal';\nexport const Relu = 'Relu';\nexport const Reshape = 'Reshape';\nexport const ResizeNearestNeighbor = 'ResizeNearestNeighbor';\nexport const ResizeNearestNeighborGrad = 'ResizeNearestNeighborGrad';\nexport const ResizeBilinear = 'ResizeBilinear';\nexport const ResizeBilinearGrad = 'ResizeBilinearGrad';\nexport const Relu6 = 'Relu6';\nexport const Reverse = 'Reverse';\nexport const Round = 'Round';\nexport const Rsqrt = 'Rsqrt';\nexport const ScatterNd = 'ScatterNd';\nexport const Select = 'Select';\nexport const Selu = 'Selu';\nexport const Slice = 'Slice';\nexport const Sin = 'Sin';\nexport const Sinh = 'Sinh';\nexport const Sign = 'Sign';\nexport const Sigmoid = 'Sigmoid';\nexport const Softplus = 'Softplus';\nexport const Sqrt = 'Sqrt';\nexport const Sum = 'Sum';\nexport const SpaceToBatchND = 'SpaceToBatchND';\nexport const SplitV = 'SplitV';\nexport const Softmax = 'Softmax';\nexport const SparseFillEmptyRows = 'SparseFillEmptyRows';\nexport const SparseReshape = 'SparseReshape';\nexport const SparseSegmentMean = 'SparseSegmentMean';\nexport const SparseSegmentSum = 'SparseSegmentSum';\nexport const SparseToDense = 'SparseToDense';\nexport const SquaredDifference = 'SquaredDifference';\nexport const Square = 'Square';\nexport const StridedSlice = 'StridedSlice';\nexport const StringNGrams = 'StringNGrams';\nexport const StringSplit = 'StringSplit';\nexport const StringToHashBucketFast = 'StringToHashBucketFast';\nexport const Sub = 'Sub';\nexport const Tan = 'Tan';\nexport const Tanh = 'Tanh';\nexport const Tile = 'Tile';\nexport const TopK = 'TopK';\nexport const Transform = 'Transform';\nexport const Transpose = 'Transpose';\nexport const Unique = 'Unique';\nexport const Unpack = 'Unpack';\nexport const UnsortedSegmentSum = 'UnsortedSegmentSum';\nexport const ZerosLike = 'ZerosLike';\n/**\n * TensorFlow.js-only kernels\n */\nexport const Step = 'Step';\nexport const FromPixels = 'FromPixels';\nexport const RotateWithOffset = 'RotateWithOffset';\nexport const _FusedMatMul = '_FusedMatMul';\nexport const FusedConv2D = 'FusedConv2D';\nexport const FusedDepthwiseConv2D = 'FusedDepthwiseConv2D';\n//# sourceMappingURL=kernel_names.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Classes and functions for model management across multiple storage mediums.\n *\n * Supported client actions:\n * - Listing models on all registered storage mediums.\n * - Remove model by URL from any registered storage mediums, by using URL\n *   string.\n * - Moving or copying model from one path to another in the same medium or from\n *   one medium to another, by using URL strings.\n */\nimport { assert } from '../util';\nimport { IORouterRegistry } from './router_registry';\nconst URL_SCHEME_SUFFIX = '://';\nexport class ModelStoreManagerRegistry {\n    constructor() {\n        this.managers = {};\n    }\n    static getInstance() {\n        if (ModelStoreManagerRegistry.instance == null) {\n            ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();\n        }\n        return ModelStoreManagerRegistry.instance;\n    }\n    /**\n     * Register a save-handler router.\n     *\n     * @param saveRouter A function that maps a URL-like string onto an instance\n     * of `IOHandler` with the `save` method defined or `null`.\n     */\n    static registerManager(scheme, manager) {\n        assert(scheme != null, () => 'scheme must not be undefined or null.');\n        if (scheme.endsWith(URL_SCHEME_SUFFIX)) {\n            scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));\n        }\n        assert(scheme.length > 0, () => 'scheme must not be an empty string.');\n        const registry = ModelStoreManagerRegistry.getInstance();\n        assert(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);\n        registry.managers[scheme] = manager;\n    }\n    static getManager(scheme) {\n        const manager = this.getInstance().managers[scheme];\n        if (manager == null) {\n            throw new Error(`Cannot find model manager for scheme '${scheme}'`);\n        }\n        return manager;\n    }\n    static getSchemes() {\n        return Object.keys(this.getInstance().managers);\n    }\n}\n/**\n * Helper method for parsing a URL string into a scheme and a path.\n *\n * @param url E.g., 'localstorage://my-model'\n * @returns A dictionary with two fields: scheme and path.\n *   Scheme: e.g., 'localstorage' in the example above.\n *   Path: e.g., 'my-model' in the example above.\n */\nfunction parseURL(url) {\n    if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {\n        throw new Error(`The url string provided does not contain a scheme. ` +\n            `Supported schemes are: ` +\n            `${ModelStoreManagerRegistry.getSchemes().join(',')}`);\n    }\n    return {\n        scheme: url.split(URL_SCHEME_SUFFIX)[0],\n        path: url.split(URL_SCHEME_SUFFIX)[1],\n    };\n}\nasync function cloneModelInternal(sourceURL, destURL, deleteSource = false) {\n    assert(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);\n    const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);\n    assert(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);\n    assert(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) ` +\n        `load handlers for source URL ${sourceURL}.`);\n    const loadHandler = loadHandlers[0];\n    const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);\n    assert(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination ` +\n        `URL ${destURL}.`);\n    assert(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) ` +\n        `save handlers for destination URL ${destURL}.`);\n    const saveHandler = saveHandlers[0];\n    const sourceScheme = parseURL(sourceURL).scheme;\n    const sourcePath = parseURL(sourceURL).path;\n    const sameMedium = sourceScheme === parseURL(sourceURL).scheme;\n    const modelArtifacts = await loadHandler.load();\n    // If moving within the same storage medium, remove the old model as soon as\n    // the loading is done. Without doing this, it is possible that the combined\n    // size of the two models will cause the cloning to fail.\n    if (deleteSource && sameMedium) {\n        await ModelStoreManagerRegistry.getManager(sourceScheme)\n            .removeModel(sourcePath);\n    }\n    const saveResult = await saveHandler.save(modelArtifacts);\n    // If moving between mediums, the deletion is done after the save succeeds.\n    // This guards against the case in which saving to the destination medium\n    // fails.\n    if (deleteSource && !sameMedium) {\n        await ModelStoreManagerRegistry.getManager(sourceScheme)\n            .removeModel(sourcePath);\n    }\n    return saveResult.modelArtifactsInfo;\n}\n/**\n * List all models stored in registered storage mediums.\n *\n * For a web browser environment, the registered mediums are Local Storage and\n * IndexedDB.\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Delete the model.\n * await tf.io.removeModel('localstorage://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n * ```\n *\n * @returns A `Promise` of a dictionary mapping URLs of existing models to\n * their model artifacts info. URLs include medium-specific schemes, e.g.,\n *   'indexeddb://my/model/1'. Model artifacts info include type of the\n * model's topology, byte sizes of the topology, weights, etc.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function listModels() {\n    const schemes = ModelStoreManagerRegistry.getSchemes();\n    const out = {};\n    for (const scheme of schemes) {\n        const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();\n        for (const path in schemeOut) {\n            const url = scheme + URL_SCHEME_SUFFIX + path;\n            out[url] = schemeOut[path];\n        }\n    }\n    return out;\n}\n/**\n * Remove a model specified by URL from a reigstered storage medium.\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Delete the model.\n * await tf.io.removeModel('localstorage://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n * ```\n *\n * @param url A URL to a stored model, with a scheme prefix, e.g.,\n *   'localstorage://my-model-1', 'indexeddb://my/model/2'.\n * @returns ModelArtifactsInfo of the deleted model (if and only if deletion\n *   is successful).\n * @throws Error if deletion fails, e.g., if no model exists at `path`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function removeModel(url) {\n    const schemeAndPath = parseURL(url);\n    const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);\n    return manager.removeModel(schemeAndPath.path);\n}\n/**\n * Copy a model from one URL to another.\n *\n * This function supports:\n *\n * 1. Copying within a storage medium, e.g.,\n *    `tf.io.copyModel('localstorage://model-1', 'localstorage://model-2')`\n * 2. Copying between two storage mediums, e.g.,\n *    `tf.io.copyModel('localstorage://model-1', 'indexeddb://model-1')`\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Copy the model, from Local Storage to IndexedDB.\n * await tf.io.copyModel(\n *     'localstorage://demo/management/model1',\n *     'indexeddb://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Remove both models.\n * await tf.io.removeModel('localstorage://demo/management/model1');\n * await tf.io.removeModel('indexeddb://demo/management/model1');\n * ```\n *\n * @param sourceURL Source URL of copying.\n * @param destURL Destination URL of copying.\n * @returns ModelArtifactsInfo of the copied model (if and only if copying\n *   is successful).\n * @throws Error if copying fails, e.g., if no model exists at `sourceURL`, or\n *   if `oldPath` and `newPath` are identical.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function copyModel(sourceURL, destURL) {\n    const deleteSource = false;\n    return cloneModelInternal(sourceURL, destURL, deleteSource);\n}\n/**\n * Move a model from one URL to another.\n *\n * This function supports:\n *\n * 1. Moving within a storage medium, e.g.,\n *    `tf.io.moveModel('localstorage://model-1', 'localstorage://model-2')`\n * 2. Moving between two storage mediums, e.g.,\n *    `tf.io.moveModel('localstorage://model-1', 'indexeddb://model-1')`\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Move the model, from Local Storage to IndexedDB.\n * await tf.io.moveModel(\n *     'localstorage://demo/management/model1',\n *     'indexeddb://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Remove the moved model.\n * await tf.io.removeModel('indexeddb://demo/management/model1');\n * ```\n *\n * @param sourceURL Source URL of moving.\n * @param destURL Destination URL of moving.\n * @returns ModelArtifactsInfo of the copied model (if and only if copying\n *   is successful).\n * @throws Error if moving fails, e.g., if no model exists at `sourceURL`, or\n *   if `oldPath` and `newPath` are identical.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function moveModel(sourceURL, destURL) {\n    const deleteSource = true;\n    return cloneModelInternal(sourceURL, destURL, deleteSource);\n}\nexport { moveModel, copyModel, removeModel, listModels };\n//# sourceMappingURL=model_management.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Note that the identifier globalNameSpace is scoped to this module, but will\n// always resolve to the same global object regardless of how the module is\n// resolved.\n// tslint:disable-next-line:no-any\nlet globalNameSpace;\n// tslint:disable-next-line:no-any\nexport function getGlobalNamespace() {\n    if (globalNameSpace == null) {\n        // tslint:disable-next-line:no-any\n        let ns;\n        if (typeof (window) !== 'undefined') {\n            ns = window;\n        }\n        else if (typeof (global) !== 'undefined') {\n            ns = global;\n        }\n        else if (typeof (process) !== 'undefined') {\n            ns = process;\n        }\n        else if (typeof (self) !== 'undefined') {\n            ns = self;\n        }\n        else {\n            throw new Error('Could not find a global object');\n        }\n        globalNameSpace = ns;\n    }\n    return globalNameSpace;\n}\n// tslint:disable-next-line:no-any\nfunction getGlobalMap() {\n    const ns = getGlobalNamespace();\n    if (ns._tfGlobals == null) {\n        ns._tfGlobals = new Map();\n    }\n    return ns._tfGlobals;\n}\n/**\n * Returns a globally accessible 'singleton' object.\n *\n * @param key the name of the object\n * @param init a function to initialize to initialize this object\n *             the first time it is fetched.\n */\nexport function getGlobal(key, init) {\n    const globalMap = getGlobalMap();\n    if (globalMap.has(key)) {\n        return globalMap.get(key);\n    }\n    else {\n        const singleton = init();\n        globalMap.set(key, singleton);\n        return globalMap.get(key);\n    }\n}\n//# sourceMappingURL=global_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { isPromise } from './util_base';\n// Expects flags from URL in the format ?tfjsflags=FLAG1:1,FLAG2:true.\nconst TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';\n/**\n * The environment contains evaluated flags as well as the registered platform.\n * This is always used as a global singleton and can be retrieved with\n * `tf.env()`.\n *\n * @doc {heading: 'Environment'}\n */\nexport class Environment {\n    // tslint:disable-next-line: no-any\n    constructor(global) {\n        this.global = global;\n        this.flags = {};\n        this.flagRegistry = {};\n        this.urlFlags = {};\n        // Jasmine spies on this in 'environment_test.ts'\n        this.getQueryParams = getQueryParams;\n        this.populateURLFlags();\n    }\n    setPlatform(platformName, platform) {\n        if (this.platform != null) {\n            console.warn(`Platform ${this.platformName} has already been set. ` +\n                `Overwriting the platform with ${platform}.`);\n        }\n        this.platformName = platformName;\n        this.platform = platform;\n    }\n    registerFlag(flagName, evaluationFn, setHook) {\n        this.flagRegistry[flagName] = { evaluationFn, setHook };\n        // Override the flag value from the URL. This has to happen here because the\n        // environment is initialized before flags get registered.\n        if (this.urlFlags[flagName] != null) {\n            const flagValue = this.urlFlags[flagName];\n            console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);\n            this.set(flagName, flagValue);\n        }\n    }\n    async getAsync(flagName) {\n        if (flagName in this.flags) {\n            return this.flags[flagName];\n        }\n        this.flags[flagName] = await this.evaluateFlag(flagName);\n        return this.flags[flagName];\n    }\n    get(flagName) {\n        if (flagName in this.flags) {\n            return this.flags[flagName];\n        }\n        const flagValue = this.evaluateFlag(flagName);\n        if (isPromise(flagValue)) {\n            throw new Error(`Flag ${flagName} cannot be synchronously evaluated. ` +\n                `Please use getAsync() instead.`);\n        }\n        this.flags[flagName] = flagValue;\n        return this.flags[flagName];\n    }\n    getNumber(flagName) {\n        return this.get(flagName);\n    }\n    getBool(flagName) {\n        return this.get(flagName);\n    }\n    getFlags() {\n        return this.flags;\n    }\n    // For backwards compatibility.\n    get features() {\n        return this.flags;\n    }\n    set(flagName, value) {\n        if (this.flagRegistry[flagName] == null) {\n            throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);\n        }\n        this.flags[flagName] = value;\n        if (this.flagRegistry[flagName].setHook != null) {\n            this.flagRegistry[flagName].setHook(value);\n        }\n    }\n    evaluateFlag(flagName) {\n        if (this.flagRegistry[flagName] == null) {\n            throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);\n        }\n        return this.flagRegistry[flagName].evaluationFn();\n    }\n    setFlags(flags) {\n        this.flags = Object.assign({}, flags);\n    }\n    reset() {\n        this.flags = {};\n        this.urlFlags = {};\n        this.populateURLFlags();\n    }\n    populateURLFlags() {\n        if (typeof this.global === 'undefined' ||\n            typeof this.global.location === 'undefined' ||\n            typeof this.global.location.search === 'undefined') {\n            return;\n        }\n        const urlParams = this.getQueryParams(this.global.location.search);\n        if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {\n            const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');\n            keyValues.forEach(keyValue => {\n                const [key, value] = keyValue.split(':');\n                this.urlFlags[key] = parseValue(key, value);\n            });\n        }\n    }\n}\nexport function getQueryParams(queryString) {\n    const params = {};\n    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {\n        decodeParam(params, t[0], t[1]);\n        return t.join('=');\n    });\n    return params;\n}\nfunction decodeParam(params, name, value) {\n    params[decodeURIComponent(name)] = decodeURIComponent(value || '');\n}\nfunction parseValue(flagName, value) {\n    value = value.toLowerCase();\n    if (value === 'true' || value === 'false') {\n        return value === 'true';\n    }\n    else if (`${+value}` === value) {\n        return +value;\n    }\n    throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);\n}\n/**\n * Returns the current environment (a global singleton).\n *\n * The environment object contains the evaluated feature values as well as the\n * active platform.\n *\n * @doc {heading: 'Environment'}\n */\nexport function env() {\n    return ENV;\n}\nexport let ENV = null;\nexport function setEnvironmentGlobal(environment) {\n    ENV = environment;\n}\n//# sourceMappingURL=environment.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Inserts a value into a sorted array. This method allows duplicate, meaning it\n * allows inserting duplicate value, in which case, the element will be inserted\n * at the lowest index of the value.\n * @param arr The array to modify.\n * @param element The element to insert.\n * @param comparator Optional. If no comparator is specified, elements are\n * compared using array_util.defaultComparator, which is suitable for Strings\n * and Numbers in ascending arrays. If the array contains multiple instances of\n * the target value, the left-most instance will be returned. To provide a\n * comparator, it should take 2 arguments to compare and return a negative,\n * zero, or a positive number.\n */\nexport function binaryInsert(arr, element, comparator) {\n    const index = binarySearch(arr, element, comparator);\n    const insertionPoint = index < 0 ? -(index + 1) : index;\n    arr.splice(insertionPoint, 0, element);\n}\n/**\n * Searches the array for the target using binary search, returns the index\n * of the found element, or position to insert if element not found. If no\n * comparator is specified, elements are compared using array_\n * util.defaultComparator, which is suitable for Strings and Numbers in\n * ascending arrays. If the array contains multiple instances of the target\n * value, the left-most instance will be returned.\n * @param arr The array to be searched in.\n * @param target The target to be searched for.\n * @param comparator Should take 2 arguments to compare and return a negative,\n *    zero, or a positive number.\n * @return Lowest index of the target value if found, otherwise the insertion\n *    point where the target should be inserted, in the form of\n *    (-insertionPoint - 1).\n */\nexport function binarySearch(arr, target, comparator) {\n    return binarySearch_(arr, target, comparator || defaultComparator);\n}\n/**\n * Compares its two arguments for order.\n * @param a The first element to be compared.\n * @param b The second element to be compared.\n * @return A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nfunction defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n}\nfunction binarySearch_(arr, target, comparator) {\n    let left = 0;\n    let right = arr.length;\n    let middle = 0;\n    let found = false;\n    while (left < right) {\n        middle = left + ((right - left) >>> 1);\n        const compareResult = comparator(target, arr[middle]);\n        if (compareResult > 0) {\n            left = middle + 1;\n        }\n        else {\n            right = middle;\n            // If compareResult is 0, the value is found. We record it is found,\n            // and then keep looking because there may be duplicate.\n            found = !compareResult;\n        }\n    }\n    return found ? left : -left - 1;\n}\n//# sourceMappingURL=non_max_suppression_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { binaryInsert } from './non_max_suppression_util';\nexport function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */);\n}\nexport function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */, false /* returnScoresTensor */, padToMaxOutputSize /* padToMaxOutputSize */, true\n    /* returnValidOutputs */ );\n}\nexport function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true /* returnScoresTensor */);\n}\nfunction nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {\n    // The list is sorted in ascending order, so that we can always pop the\n    // candidate with the largest score in O(1) time.\n    const candidates = [];\n    for (let i = 0; i < scores.length; i++) {\n        if (scores[i] > scoreThreshold) {\n            candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });\n        }\n    }\n    candidates.sort(ascendingComparator);\n    // If softNmsSigma is 0, the outcome of this algorithm is exactly same as\n    // before.\n    const scale = softNmsSigma > 0 ? (-0.5 / softNmsSigma) : 0.0;\n    const selectedIndices = [];\n    const selectedScores = [];\n    while (selectedIndices.length < maxOutputSize && candidates.length > 0) {\n        const candidate = candidates.pop();\n        const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;\n        if (originalScore < scoreThreshold) {\n            break;\n        }\n        // Overlapping boxes are likely to have similar scores, therefore we\n        // iterate through the previously selected boxes backwards in order to\n        // see if candidate's score should be suppressed. We use\n        // suppressBeginIndex to track and ensure a candidate can be suppressed\n        // by a selected box no more than once. Also, if the overlap exceeds\n        // iouThreshold, we simply ignore the candidate.\n        let ignoreCandidate = false;\n        for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {\n            const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);\n            if (iou >= iouThreshold) {\n                ignoreCandidate = true;\n                break;\n            }\n            candidate.score =\n                candidate.score * suppressWeight(iouThreshold, scale, iou);\n            if (candidate.score <= scoreThreshold) {\n                break;\n            }\n        }\n        // At this point, if `candidate.score` has not dropped below\n        // `scoreThreshold`, then we know that we went through all of the\n        // previous selections and can safely update `suppressBeginIndex` to the\n        // end of the selected array. Then we can re-insert the candidate with\n        // the updated score and suppressBeginIndex back in the candidate list.\n        // If on the other hand, `candidate.score` has dropped below the score\n        // threshold, we will not add it back to the candidates list.\n        candidate.suppressBeginIndex = selectedIndices.length;\n        if (!ignoreCandidate) {\n            // Candidate has passed all the tests, and is not suppressed, so\n            // select the candidate.\n            if (candidate.score === originalScore) {\n                selectedIndices.push(boxIndex);\n                selectedScores.push(candidate.score);\n            }\n            else if (candidate.score > scoreThreshold) {\n                // Candidate's score is suppressed but is still high enough to be\n                // considered, so add back to the candidates list.\n                binaryInsert(candidates, candidate, ascendingComparator);\n            }\n        }\n    }\n    // NonMaxSuppressionV4 feature: padding output to maxOutputSize.\n    const validOutputs = selectedIndices.length;\n    const elemsToPad = maxOutputSize - validOutputs;\n    if (padToMaxOutputSize && elemsToPad > 0) {\n        selectedIndices.push(...new Array(elemsToPad).fill(0));\n        selectedScores.push(...new Array(elemsToPad).fill(0.0));\n    }\n    const result = { selectedIndices };\n    if (returnScoresTensor) {\n        result['selectedScores'] = selectedScores;\n    }\n    if (returnValidOutputs) {\n        result['validOutputs'] = validOutputs;\n    }\n    return result;\n}\nfunction intersectionOverUnion(boxes, i, j) {\n    const iCoord = boxes.subarray(i * 4, i * 4 + 4);\n    const jCoord = boxes.subarray(j * 4, j * 4 + 4);\n    const yminI = Math.min(iCoord[0], iCoord[2]);\n    const xminI = Math.min(iCoord[1], iCoord[3]);\n    const ymaxI = Math.max(iCoord[0], iCoord[2]);\n    const xmaxI = Math.max(iCoord[1], iCoord[3]);\n    const yminJ = Math.min(jCoord[0], jCoord[2]);\n    const xminJ = Math.min(jCoord[1], jCoord[3]);\n    const ymaxJ = Math.max(jCoord[0], jCoord[2]);\n    const xmaxJ = Math.max(jCoord[1], jCoord[3]);\n    const areaI = (ymaxI - yminI) * (xmaxI - xminI);\n    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n    if (areaI <= 0 || areaJ <= 0) {\n        return 0.0;\n    }\n    const intersectionYmin = Math.max(yminI, yminJ);\n    const intersectionXmin = Math.max(xminI, xminJ);\n    const intersectionYmax = Math.min(ymaxI, ymaxJ);\n    const intersectionXmax = Math.min(xmaxI, xmaxJ);\n    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *\n        Math.max(intersectionXmax - intersectionXmin, 0.0);\n    return intersectionArea / (areaI + areaJ - intersectionArea);\n}\n// A Gaussian penalty function, this method always returns values in [0, 1].\n// The weight is a function of similarity, the more overlap two boxes are, the\n// smaller the weight is, meaning highly overlapping boxe will be significantly\n// penalized. On the other hand, a non-overlapping box will not be penalized.\nfunction suppressWeight(iouThreshold, scale, iou) {\n    const weight = Math.exp(scale * iou * iou);\n    return iou <= iouThreshold ? weight : 0.0;\n}\nfunction ascendingComparator(c1, c2) {\n    // For objects with same scores, we make the object with the larger index go\n    // first. In an array that pops from the end, this means that the object with\n    // the smaller index will be popped first. This ensures the same output as\n    // the TensorFlow python version.\n    return (c1.score - c2.score) ||\n        ((c1.score === c2.score) && (c2.boxIndex - c1.boxIndex));\n}\n//# sourceMappingURL=non_max_suppression_impl.js.map"],"sourceRoot":""}